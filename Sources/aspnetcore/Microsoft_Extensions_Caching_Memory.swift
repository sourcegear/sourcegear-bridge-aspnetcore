// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.Caching
// Microsoft.Extensions.Caching.Distributed
extension Microsoft.Extensions.Caching.Distributed {
// type: Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache
open class MemoryDistributedCache
    :
    dotnet.System.Object,
    Microsoft_Extensions_Caching_Distributed_IDistributedCache
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions})
    public init(optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_ctor_0__1__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Caching_Memory_MemoryDistributedCacheOptions_(&__thrown, (optionsAccessor?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions},Microsoft.Extensions.Logging.ILoggerFactory)
    public init(optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>>, loggerFactory : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_ctor_0__2__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Caching_Memory_MemoryDistributedCacheOptions__ILoggerFactory(&__thrown, (optionsAccessor?.get_handle()), loggerFactory?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] Get(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.Get(System.String)
    open /* method final */ func Get(key : Optional<dotnet.System.String>) throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_u8Array__Get_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Byte[]> GetAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.GetAsync(System.String,System.Threading.CancellationToken)
    open /* method final */ func GetAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System_Arr<Swift.UInt8>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_System_Threading_Tasks_Task_u8Array___GetAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Refresh(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.Refresh(System.String)
    open /* method final */ func Refresh(key : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_void__Refresh_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task RefreshAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.RefreshAsync(System.String,System.Threading.CancellationToken)
    open /* method final */ func RefreshAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_Task__RefreshAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Remove(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.Remove(System.String)
    open /* method final */ func Remove(key : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_void__Remove_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task RemoveAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.RemoveAsync(System.String,System.Threading.CancellationToken)
    open /* method final */ func RemoveAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_Task__RemoveAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Set(System.String, System.Byte[], Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.Set(System.String,System.Byte[],Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
    open /* method final */ func Set(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_void__Set_0__3__String_u8Array_DistributedCacheEntryOptions(&__thrown, self.get_handle(), key?.get_handle() ?? nil, (value?.get_handle()), options?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task SetAsync(System.String, System.Byte[], Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.MemoryDistributedCache.SetAsync(System.String,System.Byte[],Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.Threading.CancellationToken)
    open /* method final */ func SetAsync(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_MemoryDistributedCache_Task__SetAsync_0__4__String_u8Array_DistributedCacheEntryOptions_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, (value?.get_handle()), options?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // MemoryDistributedCache


}

// Microsoft.Extensions.Caching.Memory
extension Microsoft.Extensions.Caching.Memory {
// type: Microsoft.Extensions.Caching.Memory.MemoryCache
    /**
    
            An implementation of  using a dictionary to
            store its entries.
            

    */
open class MemoryCache
    :
    dotnet.System.Object,
    Microsoft_Extensions_Caching_Memory_IMemoryCache,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_MemoryCache_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Caching.Memory.MemoryCacheOptions})
    /**
    
            Creates a new  instance.
            

    - Parameter optionsAccessor: The options of the cache.
    */
    public init(optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_MemoryCache_ctor_0__1__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_(&__thrown, (optionsAccessor?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Caching.Memory.MemoryCacheOptions},Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a new  instance.
            

    - Parameter optionsAccessor: The options of the cache.
    - Parameter loggerFactory: The factory used to create loggers.
    */
    public init(optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>>, loggerFactory : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_MemoryCache_ctor_0__2__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Caching_Memory_MemoryCacheOptions__ILoggerFactory(&__thrown, (optionsAccessor?.get_handle()), loggerFactory?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Compact(System.Double)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact(System.Double)
    /**
    */
    open func Compact(percentage : Swift.Double) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCache_void__Compact_0__1__f64(&__thrown, self.get_handle(), percentage);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry CreateEntry(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.CreateEntry(System.Object)
    /**
    */
    open /* method final */ func CreateEntry(key : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCache_ICacheEntry__CreateEntry_0__1__Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.Dispose
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCache_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove(System.Object)
    /**
    */
    open /* method final */ func Remove(key : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCache_void__Remove_0__1__Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryGetValue(System.Object, ref System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.TryGetValue(System.Object,System.Object@)
    /**
    */
    open /* method final */ func TryGetValue(key : Optional<dotnet.System.Object>, result : inout dotnet.System.Object) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = result.get_handle();
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCache_bool__TryGetValue_0__2__Object_outObject(&__thrown, self.get_handle(), key?.get_handle() ?? nil, &_tmp_out_result);
        let _tmp2_result = dotnet.System.Object(hndl: _tmp_out_result);
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCache.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCache_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    
            Gets the count of the current entries for diagnostic purposes.
            

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
} // MemoryCache


// type: Microsoft.Extensions.Caching.Memory.MemoryCacheOptions
open class MemoryCacheOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Internal.ISystemClock get_Clock()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.get_Clock
    open func get_Clock() throws -> Optional<aspnetcore.Microsoft.Extensions.Internal.ISystemClock> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_ISystemClock__get_Clock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Internal.ISystemClock(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Clock(Microsoft.Extensions.Internal.ISystemClock)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.set_Clock(Microsoft.Extensions.Internal.ISystemClock)
    open func set_Clock(value : Optional<aspnetcore.Microsoft.Extensions.Internal.ISystemClock>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_void__set_Clock_0__1__ISystemClock(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Double get_CompactionPercentage()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.get_CompactionPercentage
    open func get_CompactionPercentage() throws -> Swift.Double {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_f64__get_CompactionPercentage_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_CompactionPercentage(System.Double)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.set_CompactionPercentage(System.Double)
    open func set_CompactionPercentage(value : Swift.Double) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_void__set_CompactionPercentage_0__1__f64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_ExpirationScanFrequency()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.get_ExpirationScanFrequency
    open func get_ExpirationScanFrequency() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_TimeSpan__get_ExpirationScanFrequency_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_ExpirationScanFrequency(System.TimeSpan)
    // [IsSpecialName] System.Nullable<System.Int64> get_SizeLimit()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.get_SizeLimit
    open func get_SizeLimit() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_System_Nullable_i64___get_SizeLimit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_SizeLimit(System.Nullable<System.Int64>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.set_SizeLimit(System.Nullable{System.Int64})
    open func set_SizeLimit(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_void__set_SizeLimit_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    open var Clock : Optional<aspnetcore.Microsoft.Extensions.Internal.ISystemClock> {
        get {
            return try! get_Clock();
        }
        set(v) {
            return try! set_Clock(value: v!);
        }
    }
    /**
    
            Gets or sets the amount to compact the cache by when the maximum size is exceeded.
            

    */
    open var CompactionPercentage : Swift.Double {
        get {
            return try! get_CompactionPercentage();
        }
        set(v) {
            return try! set_CompactionPercentage(value: v);
        }
    }
    /**
    
            Gets or sets the minimum length of time between successive scans for expired items.
            

    */
    open var ExpirationScanFrequency : dotnet.System.TimeSpan {
        get {
            return try! get_ExpirationScanFrequency();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_ExpirationScanFrequency(System.TimeSpan)
    }
    /**
    
            Gets or sets the maximum size of the cache.
            

    */
    open var SizeLimit : Optional<Swift.Int64> {
        get {
            return try! get_SizeLimit();
        }
        set(v) {
            return try! set_SizeLimit(value: v!);
        }
    }
} // MemoryCacheOptions


// type: Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions
open class MemoryDistributedCacheOptions
    :
    aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_MemoryDistributedCacheOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_MemoryDistributedCacheOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // MemoryDistributedCacheOptions


}


// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions
public struct MemoryCacheServiceCollectionExtensions {
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Adds a default implementation of  that stores items in memory
            to the . Frameworks that require a distributed cache to work
            can safely add this dependency as part of their dependency list to ensure that there is at least
            one implementation available.
            

    - Parameter services: The  to add services to.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddDistributedMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_MemoryCacheServiceCollectionExtensions_IServiceCollection__AddDistributedMemoryCache_0__1__IServiceCollection(&__thrown, services?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions})
    /**
    
            Adds a default implementation of  that stores items in memory
            to the . Frameworks that require a distributed cache to work
            can safely add this dependency as part of their dependency list to ensure that there is at least
            one implementation available.
            

    - Parameter services: The  to add services to.
    - Parameter setupAction: 
            The  to configure the provided .
            
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddDistributedMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, setupAction : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_MemoryCacheServiceCollectionExtensions_IServiceCollection__AddDistributedMemoryCache_0__2__IServiceCollection_System_Action_Microsoft_Extensions_Caching_Memory_MemoryDistributedCacheOptions_(&__thrown, services?.get_handle() ?? nil, (setupAction?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddDistributedMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, setupAction : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>(setupAction);
        return try AddDistributedMemoryCache(services: services, setupAction: del_setupAction);
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Adds a non distributed in memory implementation of  to the
            .
            

    - Parameter services: The  to add services to.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_MemoryCacheServiceCollectionExtensions_IServiceCollection__AddMemoryCache_0__1__IServiceCollection(&__thrown, services?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.Extensions.Caching.Memory.MemoryCacheOptions})
    /**
    
            Adds a non distributed in memory implementation of  to the
            .
            

    - Parameter services: The  to add services to.
    - Parameter setupAction: 
            The  to configure the provided .
            
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, setupAction : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_MemoryCacheServiceCollectionExtensions_IServiceCollection__AddMemoryCache_0__2__IServiceCollection_System_Action_Microsoft_Extensions_Caching_Memory_MemoryCacheOptions_(&__thrown, services?.get_handle() ?? nil, (setupAction?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddMemoryCache(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, setupAction : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>(setupAction);
        return try AddMemoryCache(services: services, setupAction: del_setupAction);
    }
} // MemoryCacheServiceCollectionExtensions


}



// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddDistributedMemoryCache() throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddDistributedMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddDistributedMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddDistributedMemoryCache(setupAction : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddDistributedMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: setupAction);
    }
    // delegate closure overload
    public func AddDistributedMemoryCache(setupAction : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryDistributedCacheOptions>(setupAction);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddDistributedMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: del_setupAction);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddMemoryCache() throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddMemoryCache(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddMemoryCache(setupAction : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: setupAction);
    }
    // delegate closure overload
    public func AddMemoryCache(setupAction : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheOptions>(setupAction);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: del_setupAction);
    }
}

