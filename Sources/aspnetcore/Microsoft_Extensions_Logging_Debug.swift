// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.Logging
extension Microsoft.Extensions.Logging {
// type: Microsoft.Extensions.Logging.DebugLoggerFactoryExtensions
public struct DebugLoggerFactoryExtensions {
    // Microsoft.Extensions.Logging.ILoggingBuilder AddDebug(Microsoft.Extensions.Logging.ILoggingBuilder)
// docid: M:Microsoft.Extensions.Logging.DebugLoggerFactoryExtensions.AddDebug(Microsoft.Extensions.Logging.ILoggingBuilder)
    /**
    
            Adds a debug logger named 'Debug' to the factory.
            

    - Parameter builder: The extension method argument.
    */
    public static func AddDebug(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_DebugLoggerFactoryExtensions_ILoggingBuilder__AddDebug_0__1__ILoggingBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DebugLoggerFactoryExtensions


}
// Microsoft.Extensions.Logging.Debug
extension Microsoft.Extensions.Logging.Debug {
// type: Microsoft.Extensions.Logging.Debug.DebugLoggerProvider
    /**
    
            The provider for the .
            

    */
open class DebugLoggerProvider
    :
    dotnet.System.Object,
    Microsoft_Extensions_Logging_ILoggerProvider,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_Debug_DebugLoggerProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Logging.Debug.DebugLoggerProvider.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_Debug_DebugLoggerProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.Logging.ILogger CreateLogger(System.String)
// docid: M:Microsoft.Extensions.Logging.Debug.DebugLoggerProvider.CreateLogger(System.String)
    /**
    */
    open /* method final */ func CreateLogger(name : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_Debug_DebugLoggerProvider_ILogger__CreateLogger_0__1__String(&__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.Logging.Debug.DebugLoggerProvider.Dispose
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_Debug_DebugLoggerProvider_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // DebugLoggerProvider


}




// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddDebug(Microsoft.Extensions.Logging.ILoggingBuilder)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddDebug() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.DebugLoggerFactoryExtensions.AddDebug(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

