// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Http
// Microsoft.AspNetCore.Http.Connections
extension Microsoft.AspNetCore.Http.Connections {
// type: Microsoft.AspNetCore.Http.Connections.AvailableTransport
    /**
    
            Part of the  that represents an individual transport and the trasfer formats the transport supports.
            

    */
open class AvailableTransport
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_AvailableTransport_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_AvailableTransport_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.AvailableTransport.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_AvailableTransport_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Transport()
// docid: M:Microsoft.AspNetCore.Http.Connections.AvailableTransport.get_Transport
    open func get_Transport() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_AvailableTransport_String__get_Transport_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Transport(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.AvailableTransport.set_Transport(System.String)
    open func set_Transport(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_AvailableTransport_void__set_Transport_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<System.String> get_TransferFormats()
// docid: M:Microsoft.AspNetCore.Http.Connections.AvailableTransport.get_TransferFormats
    open func get_TransferFormats() throws -> Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_AvailableTransport_System_Collections_Generic_IList_string___get_TransferFormats_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_TransferFormats(System.Collections.Generic.IList<System.String>)
// docid: M:Microsoft.AspNetCore.Http.Connections.AvailableTransport.set_TransferFormats(System.Collections.Generic.IList{System.String})
    open func set_TransferFormats(value : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_AvailableTransport_void__set_TransferFormats_0__1__System_Collections_Generic_IList_string_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            A list of formats supported by the transport. Examples include "Text" and "Binary".
            

    */
    open var TransferFormats : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        get {
            return try! get_TransferFormats();
        }
        set(v) {
            return try! set_TransferFormats(value: v!);
        }
    }
    /**
    
            A transport available on the server.
            

    */
    open var Transport : Optional<dotnet.System.String> {
        get {
            return try! get_Transport();
        }
        set(v) {
            return try! set_Transport(value: v!);
        }
    }
} // AvailableTransport


// type: Microsoft.AspNetCore.Http.Connections.HttpTransportType
    /**
    
            Specifies transports that the client can use to send HTTP requests.
            

    */
public struct HttpTransportType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_HttpTransportType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Http.Connections.HttpTransportType None
    /**
    
            Specifies that no transport is used.
            

    */
    public static var None : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: Microsoft_AspNetCore_Http_Connections_HttpTransportType_get_None());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Http.Connections.HttpTransportType WebSockets
    /**
    
            Specifies that the web sockets transport is used.
            

    */
    public static var WebSockets : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: Microsoft_AspNetCore_Http_Connections_HttpTransportType_get_WebSockets());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Http.Connections.HttpTransportType ServerSentEvents
    /**
    
            Specifies that the server sent events transport is used.
            

    */
    public static var ServerSentEvents : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: Microsoft_AspNetCore_Http_Connections_HttpTransportType_get_ServerSentEvents());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Http.Connections.HttpTransportType LongPolling
    /**
    
            Specifies that the long polling transport is used.
            

    */
    public static var LongPolling : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: Microsoft_AspNetCore_Http_Connections_HttpTransportType_get_LongPolling());
            return __return;
        }
    }
} // HttpTransportType


// type: Microsoft.AspNetCore.Http.Connections.HttpTransports
public struct HttpTransports {
    // static field: Microsoft.AspNetCore.Http.Connections.HttpTransportType All
    /**
    
            A bitmask combining all available  values.
            

    */
    public static var All : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: Microsoft_AspNetCore_Http_Connections_HttpTransports_get_All());
            return __return;
        }
    }
} // HttpTransports


// type: Microsoft.AspNetCore.Http.Connections.NegotiateProtocol
public struct NegotiateProtocol {
    // void WriteResponse(Microsoft.AspNetCore.Http.Connections.NegotiationResponse, System.Buffers.IBufferWriter<System.Byte>)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiateProtocol.WriteResponse(Microsoft.AspNetCore.Http.Connections.NegotiationResponse,System.Buffers.IBufferWriter{System.Byte})
    /**
    
            Writes the  to the .
            

    - Parameter response: The negotiation response generated in response to a negotiation request.
    - Parameter output: Where the  is written to as Json.
    */
    public static func WriteResponse(response : aspnetcore.Microsoft.AspNetCore.Http.Connections.NegotiationResponse, output : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiateProtocol_void__WriteResponse_0__2__NegotiationResponse_System_Buffers_IBufferWriter_u8_(&__thrown, response.get_handle(), output.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) Microsoft.AspNetCore.Http.Connections.NegotiationResponse ParseResponse(System.ReadOnlySpan<System.Byte>)
} // NegotiateProtocol


// type: Microsoft.AspNetCore.Http.Connections.NegotiationResponse
    /**
    
            A response to a '/negotiate' request.
            

    */
open class NegotiationResponse
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_NegotiationResponse_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Url()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_Url
    open func get_Url() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_String__get_Url_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Url(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_Url(System.String)
    open func set_Url(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_Url_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_AccessToken()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_AccessToken
    open func get_AccessToken() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_String__get_AccessToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AccessToken(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_AccessToken(System.String)
    open func set_AccessToken(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_AccessToken_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ConnectionId()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_ConnectionId
    open func get_ConnectionId() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_String__get_ConnectionId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ConnectionId(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_ConnectionId(System.String)
    open func set_ConnectionId(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_ConnectionId_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ConnectionToken()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_ConnectionToken
    open func get_ConnectionToken() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_String__get_ConnectionToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ConnectionToken(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_ConnectionToken(System.String)
    open func set_ConnectionToken(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_ConnectionToken_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Version()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_Version
    open func get_Version() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_i32__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Version(System.Int32)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_Version(System.Int32)
    open func set_Version(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_Version_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.Http.Connections.AvailableTransport> get_AvailableTransports()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_AvailableTransports
    open func get_AvailableTransports() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.AvailableTransport>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_System_Collections_Generic_IList_Microsoft_AspNetCore_Http_Connections_AvailableTransport___get_AvailableTransports_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AvailableTransports(System.Collections.Generic.IList<Microsoft.AspNetCore.Http.Connections.AvailableTransport>)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_AvailableTransports(System.Collections.Generic.IList{Microsoft.AspNetCore.Http.Connections.AvailableTransport})
    open func set_AvailableTransports(value : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.AvailableTransport>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_AvailableTransports_0__1__System_Collections_Generic_IList_Microsoft_AspNetCore_Http_Connections_AvailableTransport_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Error()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.get_Error
    open func get_Error() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_NegotiationResponse_String__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Error(System.String)
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiationResponse.set_Error(System.String)
    open func set_Error(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_NegotiationResponse_void__set_Error_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            An optional access token to go along with the Url.
            

    */
    open var AccessToken : Optional<dotnet.System.String> {
        get {
            return try! get_AccessToken();
        }
        set(v) {
            return try! set_AccessToken(value: v!);
        }
    }
    /**
    
            A list of transports the server supports.
            

    */
    open var AvailableTransports : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.AvailableTransport>> {
        get {
            return try! get_AvailableTransports();
        }
        set(v) {
            return try! set_AvailableTransports(value: v!);
        }
    }
    /**
    
            The public ID for the connection.
            

    */
    open var ConnectionId : Optional<dotnet.System.String> {
        get {
            return try! get_ConnectionId();
        }
        set(v) {
            return try! set_ConnectionId(value: v!);
        }
    }
    /**
    
            The private ID for the connection.
            

    */
    open var ConnectionToken : Optional<dotnet.System.String> {
        get {
            return try! get_ConnectionToken();
        }
        set(v) {
            return try! set_ConnectionToken(value: v!);
        }
    }
    /**
    
            An optional error during the negotiate. If this is not null the other properties on the response can be ignored.
            

    */
    open var Error : Optional<dotnet.System.String> {
        get {
            return try! get_Error();
        }
        set(v) {
            return try! set_Error(value: v!);
        }
    }
    /**
    
            An optional Url to redirect the client to another endpoint.
            

    */
    open var Url : Optional<dotnet.System.String> {
        get {
            return try! get_Url();
        }
        set(v) {
            return try! set_Url(value: v!);
        }
    }
    /**
    
            The minimum value between the version the client sends and the maximum version the server supports.
            

    */
    open var Version : Swift.Int32 {
        get {
            return try! get_Version();
        }
        set(v) {
            return try! set_Version(value: v);
        }
    }
} // NegotiationResponse


}




