// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Hosting
extension Microsoft.AspNetCore.Hosting {
// type: Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions
public struct KestrelServerOptionsSystemdExtensions {
    // Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions)
// docid: M:Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions.UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions)
    /**
    
            Open file descriptors (starting from SD_LISTEN_FDS_START) initialized by systemd socket-based activation logic if available.
            

    - Returns: 
            The .
            

    */
    public static func UseSystemd(options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_KestrelServerOptionsSystemdExtensions_KestrelServerOptions__UseSystemd_0__1__KestrelServerOptions(&__thrown, options.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions.UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Open file descriptors (starting from SD_LISTEN_FDS_START) initialized by systemd socket-based activation logic if available.
            Specify callback to configure endpoint-specific settings.
            

    - Returns: 
            The .
            

    */
    public static func UseSystemd(options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_KestrelServerOptionsSystemdExtensions_KestrelServerOptions__UseSystemd_0__2__KestrelServerOptions_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, options.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseSystemd(options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try UseSystemd(options: options, configure: del_configure);
    }
} // KestrelServerOptionsSystemdExtensions


// type: Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions
public struct ListenOptionsConnectionLoggingExtensions {
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions.UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
    /**
    
            Emits verbose logs for bytes read from and written to the connection.
            

    - Returns: 
            The .
            

    */
    public static func UseConnectionLogging(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsConnectionLoggingExtensions_ListenOptions__UseConnectionLogging_0__1__ListenOptions(&__thrown, listenOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions.UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.String)
    /**
    
            Emits verbose logs for bytes read from and written to the connection.
            

    - Returns: 
            The .
            

    */
    public static func UseConnectionLogging(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, loggerName : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsConnectionLoggingExtensions_ListenOptions__UseConnectionLogging_0__2__ListenOptions_String(&__thrown, listenOptions.get_handle(), loggerName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
} // ListenOptionsConnectionLoggingExtensions


// type: Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions
public struct ListenOptionsHttpsExtensions {
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
    /**
    
            Configure Kestrel to use HTTPS with the default certificate if available.
            This will throw if no default certificate is configured.
            

    - Parameter listenOptions: The  to configure.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__1__ListenOptions(&__thrown, listenOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.String)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter fileName: The name of a certificate file, relative to the directory that contains the application
            content files.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, fileName : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__2__ListenOptions_String(&__thrown, listenOptions.get_handle(), fileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.String,System.String)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter fileName: The name of a certificate file, relative to the directory that contains the application
            content files.
    - Parameter password: The password required to access the X.509 certificate data.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, fileName : dotnet.System.String, password : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__3__ListenOptions_String_String(&__thrown, listenOptions.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String, System.String, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.String,System.String,System.Action{Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions})
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter fileName: The name of a certificate file, relative to the directory that contains the application content files.
    - Parameter password: The password required to access the X.509 certificate data.
    - Parameter configureOptions: An Action to configure the .
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, fileName : dotnet.System.String, password : Optional<dotnet.System.String>, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__4__ListenOptions_String_String_System_Action_Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_(&__thrown, listenOptions.get_handle(), fileName.get_handle(), password?.get_handle() ?? nil, configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, fileName : dotnet.System.String, password : Optional<dotnet.System.String>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try UseHttps(listenOptions: listenOptions, fileName: fileName, password: password, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.StoreName,System.String)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter storeName: The certificate store to load the certificate from.
    - Parameter subject: The subject name for the certificate to load.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__3__ListenOptions_StoreName_String(&__thrown, listenOptions.get_handle(), storeName.get_value(), subject.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.StoreName,System.String,System.Boolean)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter storeName: The certificate store to load the certificate from.
    - Parameter subject: The subject name for the certificate to load.
    - Parameter allowInvalid: Indicates if invalid certificates should be considered, such as self-signed certificates.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__4__ListenOptions_StoreName_String_bool(&__thrown, listenOptions.get_handle(), storeName.get_value(), subject.get_handle(), Swift.Int32(allowInvalid ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool, System.Security.Cryptography.X509Certificates.StoreLocation)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.StoreName,System.String,System.Boolean,System.Security.Cryptography.X509Certificates.StoreLocation)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter storeName: The certificate store to load the certificate from.
    - Parameter subject: The subject name for the certificate to load.
    - Parameter allowInvalid: Indicates if invalid certificates should be considered, such as self-signed certificates.
    - Parameter location: The store location to load the certificate from.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__5__ListenOptions_StoreName_String_bool_StoreLocation(&__thrown, listenOptions.get_handle(), storeName.get_value(), subject.get_handle(), Swift.Int32(allowInvalid ? 1 : 0), location.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool, System.Security.Cryptography.X509Certificates.StoreLocation, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.StoreName,System.String,System.Boolean,System.Security.Cryptography.X509Certificates.StoreLocation,System.Action{Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions})
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter storeName: The certificate store to load the certificate from.
    - Parameter subject: The subject name for the certificate to load.
    - Parameter allowInvalid: Indicates if invalid certificates should be considered, such as self-signed certificates.
    - Parameter location: The store location to load the certificate from.
    - Parameter configureOptions: An Action to configure the .
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__6__ListenOptions_StoreName_String_bool_StoreLocation_System_Action_Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_(&__thrown, listenOptions.get_handle(), storeName.get_value(), subject.get_handle(), Swift.Int32(allowInvalid ? 1 : 0), location.get_value(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try UseHttps(listenOptions: listenOptions, storeName: storeName, subject: subject, allowInvalid: allowInvalid, location: location, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions:  The  to configure.
    - Parameter serverCertificate: The X.509 certificate.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__2__ListenOptions_X509Certificate2(&__thrown, listenOptions.get_handle(), serverCertificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Action{Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions})
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter serverCertificate: The X.509 certificate.
    - Parameter configureOptions: An Action to configure the .
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__3__ListenOptions_X509Certificate2_System_Action_Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_(&__thrown, listenOptions.get_handle(), serverCertificate.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try UseHttps(listenOptions: listenOptions, serverCertificate: serverCertificate, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Action{Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions})
    /**
    
            Configure Kestrel to use HTTPS.
            

    - Parameter listenOptions: The  to configure.
    - Parameter configureOptions: An action to configure options for HTTPS.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__2__ListenOptions_System_Action_Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_(&__thrown, listenOptions.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try UseHttps(listenOptions: listenOptions, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions)
    /**
    
            Configure Kestrel to use HTTPS. This does not use default certificates or other defaults specified via config or
            .
            

    - Parameter listenOptions: The  to configure.
    - Parameter httpsOptions: Options to configure HTTPS.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, httpsOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__2__ListenOptions_HttpsConnectionAdapterOptions(&__thrown, listenOptions.get_handle(), httpsOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Net.Security.ServerOptionsSelectionCallback, System.Object)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,System.Net.Security.ServerOptionsSelectionCallback,System.Object)
    /**
    
            Configure Kestrel to use HTTPS. This does not use default certificates or other defaults specified via config or
            .
            

    - Parameter listenOptions: The  to configure.
    - Parameter serverOptionsSelectionCallback: Callback to configure HTTPS options.
    - Parameter state: State for the .
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, serverOptionsSelectionCallback : dotnet.System.Net.Security.ServerOptionsSelectionCallback, state : dotnet.System.Object) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__3__ListenOptions_ServerOptionsSelectionCallback_Object(&__thrown, listenOptions.get_handle(), serverOptionsSelectionCallback.get_handle(), state.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, serverOptionsSelectionCallback : @escaping (dotnet.System.Net.Security.SslStream, dotnet.System.Net.Security.SslClientHelloInfo, Optional<dotnet.System.Object>, dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>, state : dotnet.System.Object) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_serverOptionsSelectionCallback = try dotnet.System.Net.Security.ServerOptionsSelectionCallback(serverOptionsSelectionCallback);
        return try UseHttps(listenOptions: listenOptions, serverOptionsSelectionCallback: del_serverOptionsSelectionCallback, state: state);
    }
// TODO COPE (write_all_methods) (span) Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Net.Security.ServerOptionsSelectionCallback, System.Object, System.TimeSpan)
    // Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions)
// docid: M:Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions,Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions)
    /**
    
            Configure Kestrel to use HTTPS. This does not use default certificates or other defaults specified via config or
            .
            

    - Parameter listenOptions: The  to configure.
    - Parameter callbackOptions: Options for a per connection callback.
    - Returns: The .

    */
    public static func UseHttps(listenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, callbackOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_ListenOptionsHttpsExtensions_ListenOptions__UseHttps_0__2__ListenOptions_TlsHandshakeCallbackOptions(&__thrown, listenOptions.get_handle(), callbackOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
} // ListenOptionsHttpsExtensions


}

// Microsoft.AspNetCore.Server
// Microsoft.AspNetCore.Server.Kestrel
extension Microsoft.AspNetCore.Server.Kestrel {
// type: Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration
    /**
    
            The configuration for an endpoint.
            

    */
open class EndpointConfiguration
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] bool get_IsHttps()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration.get_IsHttps
    open func get_IsHttps() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_bool__get_IsHttps_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions get_ListenOptions()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration.get_ListenOptions
    open func get_ListenOptions() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_ListenOptions__get_ListenOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions get_HttpsOptions()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration.get_HttpsOptions
    open func get_HttpsOptions() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_HttpsConnectionAdapterOptions__get_HttpsOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Configuration.IConfigurationSection get_ConfigSection()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration.get_ConfigSection
    open func get_ConfigSection() throws -> aspnetcore.Microsoft.Extensions.Configuration.IConfigurationSection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_IConfigurationSection__get_ConfigSection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Configuration.IConfigurationSection(hndl : __return);
        }
    }
    /**
    
            Gets the  for the endpoint.
            

    */
    open var ConfigSection : aspnetcore.Microsoft.Extensions.Configuration.IConfigurationSection {
        get {
            return try! get_ConfigSection();
        }
    }
    /**
    
            Gets the .
            

    */
    open var HttpsOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions {
        get {
            return try! get_HttpsOptions();
        }
    }
    /**
    
            Gets whether the endpoint uses HTTPS.
            

    */
    open var IsHttps : Bool {
        get {
            return try! get_IsHttps();
        }
    }
    /**
    
            Gets the endpoint .
            

    */
    open var ListenOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        get {
            return try! get_ListenOptions();
        }
    }
} // EndpointConfiguration


// type: Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader
    /**
    
            Configuration loader for Kestrel.
            

    */
open class KestrelConfigurationLoader
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Endpoint(System.String, System.Action<Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Endpoint(System.String,System.Action{Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration})
    /**
    
            Specifies a configuration Action to run when an endpoint with the given name is loaded from configuration.
            

    */
    open func Endpoint(name : dotnet.System.String, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__Endpoint_0__2__String_System_Action_Microsoft_AspNetCore_Server_Kestrel_EndpointConfiguration_(&__thrown, self.get_handle(), name.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func Endpoint(name : dotnet.System.String, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.EndpointConfiguration>(configureOptions);
        return try Endpoint(name: name, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Endpoint(System.Net.IPAddress, System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Endpoint(System.Net.IPAddress,System.Int32)
    /**
    
            Bind to given IP address and port.
            

    */
    open func Endpoint(address : dotnet.System.Net.IPAddress, port : Swift.Int32) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__Endpoint_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Endpoint(System.Net.IPAddress, System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Endpoint(System.Net.IPAddress,System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given IP address and port.
            

    */
    open func Endpoint(address : dotnet.System.Net.IPAddress, port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__Endpoint_0__3__IPAddress_i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), address.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func Endpoint(address : dotnet.System.Net.IPAddress, port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try Endpoint(address: address, port: port, configure: del_configure);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Endpoint(System.Net.IPEndPoint)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Endpoint(System.Net.IPEndPoint)
    /**
    
            Bind to given IP endpoint.
            

    */
    open func Endpoint(endPoint : dotnet.System.Net.IPEndPoint) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__Endpoint_0__1__IPEndPoint(&__thrown, self.get_handle(), endPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Endpoint(System.Net.IPEndPoint, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Endpoint(System.Net.IPEndPoint,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given IP address and port.
            

    */
    open func Endpoint(endPoint : dotnet.System.Net.IPEndPoint, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__Endpoint_0__2__IPEndPoint_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), endPoint.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func Endpoint(endPoint : dotnet.System.Net.IPEndPoint, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try Endpoint(endPoint: endPoint, configure: del_configure);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader LocalhostEndpoint(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.LocalhostEndpoint(System.Int32)
    /**
    
            Listens on ::1 and 127.0.0.1 with the given port. Requesting a dynamic port by specifying 0 is not supported
            for this type of endpoint.
            

    */
    open func LocalhostEndpoint(port : Swift.Int32) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__LocalhostEndpoint_0__1__i32(&__thrown, self.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader LocalhostEndpoint(System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.LocalhostEndpoint(System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Listens on ::1 and 127.0.0.1 with the given port. Requesting a dynamic port by specifying 0 is not supported
            for this type of endpoint.
            

    */
    open func LocalhostEndpoint(port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__LocalhostEndpoint_0__2__i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func LocalhostEndpoint(port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try LocalhostEndpoint(port: port, configure: del_configure);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader AnyIPEndpoint(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.AnyIPEndpoint(System.Int32)
    /**
    
            Listens on all IPs using IPv6 [::], or IPv4 0.0.0.0 if IPv6 is not supported.
            

    */
    open func AnyIPEndpoint(port : Swift.Int32) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__AnyIPEndpoint_0__1__i32(&__thrown, self.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader AnyIPEndpoint(System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.AnyIPEndpoint(System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Listens on all IPs using IPv6 [::], or IPv4 0.0.0.0 if IPv6 is not supported.
            

    */
    open func AnyIPEndpoint(port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__AnyIPEndpoint_0__2__i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func AnyIPEndpoint(port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try AnyIPEndpoint(port: port, configure: del_configure);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader UnixSocketEndpoint(System.String)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.UnixSocketEndpoint(System.String)
    /**
    
            Bind to given Unix domain socket path.
            

    */
    open func UnixSocketEndpoint(socketPath : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__UnixSocketEndpoint_0__1__String(&__thrown, self.get_handle(), socketPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader UnixSocketEndpoint(System.String, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.UnixSocketEndpoint(System.String,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given Unix domain socket path.
            

    */
    open func UnixSocketEndpoint(socketPath : dotnet.System.String, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__UnixSocketEndpoint_0__2__String_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), socketPath.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func UnixSocketEndpoint(socketPath : dotnet.System.String, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try UnixSocketEndpoint(socketPath: socketPath, configure: del_configure);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader HandleEndpoint(System.UInt64)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.HandleEndpoint(System.UInt64)
    /**
    
            Open a socket file descriptor.
            

    */
    open func HandleEndpoint(handle : Swift.UInt64) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__HandleEndpoint_0__1__u64(&__thrown, self.get_handle(), handle);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader HandleEndpoint(System.UInt64, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.HandleEndpoint(System.UInt64,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Open a socket file descriptor.
            

    */
    open func HandleEndpoint(handle : Swift.UInt64, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelConfigurationLoader__HandleEndpoint_0__2__u64_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), handle, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // delegate closure overload
    open func HandleEndpoint(handle : Swift.UInt64, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try HandleEndpoint(handle: handle, configure: del_configure);
    }
    // void Load()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.Load
    /**
    
            Loads the configuration.
            

    */
    open func Load() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_void__Load_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions get_Options()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.get_Options
    open func get_Options() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_KestrelServerOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Configuration.IConfiguration get_Configuration()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.get_Configuration
    open func get_Configuration() throws -> aspnetcore.Microsoft.Extensions.Configuration.IConfiguration {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_IConfiguration__get_Configuration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Configuration.IConfiguration(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Configuration(Microsoft.Extensions.Configuration.IConfiguration)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader.set_Configuration(Microsoft.Extensions.Configuration.IConfiguration)
    open func set_Configuration(value : Optional<aspnetcore.Microsoft.Extensions.Configuration.IConfiguration>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_KestrelConfigurationLoader_void__set_Configuration_0__1__IConfiguration(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets the application .
            

    */
    open var Configuration : aspnetcore.Microsoft.Extensions.Configuration.IConfiguration {
        get {
            return try! get_Configuration();
        }
        set(v) {
            return try! set_Configuration(value: v);
        }
    }
    /**
    
            Gets the .
            

    */
    open var Options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        get {
            return try! get_Options();
        }
    }
} // KestrelConfigurationLoader


}
// Microsoft.AspNetCore.Server.Kestrel.Core
extension Microsoft.AspNetCore.Server.Kestrel.Core {
// type: Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException
    /**
    
            An exception thrown when a malformed http request has been received.
            

    */
public final class BadHttpRequestException
    :
    aspnetcore.Microsoft.AspNetCore.Http.BadHttpRequestException
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_BadHttpRequestException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Int32 get_StatusCode()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.BadHttpRequestException.get_StatusCode
    public override func get_StatusCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_BadHttpRequestException_i32__get_StatusCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    public override var StatusCode : Swift.Int32 {
        get {
            return try! get_StatusCode();
        }
    }
} // BadHttpRequestException


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits
    /**
    
            Limits only applicable to HTTP/2 connections.
            

    */
open class Http2Limits
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxStreamsPerConnection()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_MaxStreamsPerConnection
    open func get_MaxStreamsPerConnection() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_MaxStreamsPerConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxStreamsPerConnection(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_MaxStreamsPerConnection(System.Int32)
    open func set_MaxStreamsPerConnection(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_MaxStreamsPerConnection_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_HeaderTableSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_HeaderTableSize
    open func get_HeaderTableSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_HeaderTableSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_HeaderTableSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_HeaderTableSize(System.Int32)
    open func set_HeaderTableSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_HeaderTableSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxFrameSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_MaxFrameSize
    open func get_MaxFrameSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_MaxFrameSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxFrameSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_MaxFrameSize(System.Int32)
    open func set_MaxFrameSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_MaxFrameSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxRequestHeaderFieldSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_MaxRequestHeaderFieldSize
    open func get_MaxRequestHeaderFieldSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_MaxRequestHeaderFieldSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxRequestHeaderFieldSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_MaxRequestHeaderFieldSize(System.Int32)
    open func set_MaxRequestHeaderFieldSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_MaxRequestHeaderFieldSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_InitialConnectionWindowSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_InitialConnectionWindowSize
    open func get_InitialConnectionWindowSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_InitialConnectionWindowSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_InitialConnectionWindowSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_InitialConnectionWindowSize(System.Int32)
    open func set_InitialConnectionWindowSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_InitialConnectionWindowSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_InitialStreamWindowSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_InitialStreamWindowSize
    open func get_InitialStreamWindowSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_i32__get_InitialStreamWindowSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_InitialStreamWindowSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.set_InitialStreamWindowSize(System.Int32)
    open func set_InitialStreamWindowSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_void__set_InitialStreamWindowSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_KeepAlivePingDelay()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_KeepAlivePingDelay
    open func get_KeepAlivePingDelay() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_TimeSpan__get_KeepAlivePingDelay_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_KeepAlivePingDelay(System.TimeSpan)
    // [IsSpecialName] System.TimeSpan get_KeepAlivePingTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits.get_KeepAlivePingTimeout
    open func get_KeepAlivePingTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http2Limits_TimeSpan__get_KeepAlivePingTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_KeepAlivePingTimeout(System.TimeSpan)
    /**
    
            Limits the size of the header compression tables, in octets, the HPACK encoder and decoder on the server can use.
            
            Value must be greater than or equal to 0, defaults to 4096.
            
            

    */
    open var HeaderTableSize : Swift.Int32 {
        get {
            return try! get_HeaderTableSize();
        }
        set(v) {
            return try! set_HeaderTableSize(value: v);
        }
    }
    /**
    
            Indicates how much request body data the server is willing to receive and buffer at a time aggregated across all
            requests (streams) per connection. Note requests are also limited by 
            
            Value must be greater than or equal to 65,535 and less than 2^31, defaults to 128 kb.
            
            

    */
    open var InitialConnectionWindowSize : Swift.Int32 {
        get {
            return try! get_InitialConnectionWindowSize();
        }
        set(v) {
            return try! set_InitialConnectionWindowSize(value: v);
        }
    }
    /**
    
            Indicates how much request body data the server is willing to receive and buffer at a time per stream.
            Note connections are also limited by 
            
            Value must be greater than or equal to 65,535 and less than 2^31, defaults to 96 kb.
            
            

    */
    open var InitialStreamWindowSize : Swift.Int32 {
        get {
            return try! get_InitialStreamWindowSize();
        }
        set(v) {
            return try! set_InitialStreamWindowSize(value: v);
        }
    }
    /**
    
            Gets or sets the keep alive ping delay. The server will send a keep alive ping to the client if it
            doesn't receive any frames on a connection for this period of time. This property is used together with
             to close broken connections.
            
            Delay value must be greater than or equal to 1 second. Set to  to
            disable the keep alive ping.
            Defaults to .
            
            

    */
    open var KeepAlivePingDelay : dotnet.System.TimeSpan {
        get {
            return try! get_KeepAlivePingDelay();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_KeepAlivePingDelay(System.TimeSpan)
    }
    /**
    
            Gets or sets the keep alive ping timeout. Keep alive pings are sent when a period of inactivity exceeds
            the configured  value. The server will close the connection if it
            doesn't receive any frames within the timeout.
            
            Timeout must be greater than or equal to 1 second. Set to  to
            disable the keep alive ping timeout.
            Defaults to 20 seconds.
            
            

    */
    open var KeepAlivePingTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_KeepAlivePingTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_KeepAlivePingTimeout(System.TimeSpan)
    }
    /**
    
            Indicates the size of the largest frame payload that is allowed to be received, in octets. The size must be between 2^14 and 2^24-1.
            
            Value must be between 2^14 and 2^24, defaults to 2^14 (16,384).
            
            

    */
    open var MaxFrameSize : Swift.Int32 {
        get {
            return try! get_MaxFrameSize();
        }
        set(v) {
            return try! set_MaxFrameSize(value: v);
        }
    }
    /**
    
            Indicates the size of the maximum allowed size of a request header field sequence. This limit applies to both name and value sequences in their compressed and uncompressed representations.
            
            Value must be greater than 0, defaults to 2^14 (16,384).
            
            

    */
    open var MaxRequestHeaderFieldSize : Swift.Int32 {
        get {
            return try! get_MaxRequestHeaderFieldSize();
        }
        set(v) {
            return try! set_MaxRequestHeaderFieldSize(value: v);
        }
    }
    /**
    
            Limits the number of concurrent request streams per HTTP/2 connection. Excess streams will be refused.
            
            Value must be greater than 0, defaults to 100.
            
            

    */
    open var MaxStreamsPerConnection : Swift.Int32 {
        get {
            return try! get_MaxStreamsPerConnection();
        }
        set(v) {
            return try! set_MaxStreamsPerConnection(value: v);
        }
    }
} // Http2Limits


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits
    /**
    
            Limits only applicable to HTTP/3 connections.
            

    */
open class Http3Limits
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Http3Limits_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Http3Limits_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxRequestHeaderFieldSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits.get_MaxRequestHeaderFieldSize
    open func get_MaxRequestHeaderFieldSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Http3Limits_i32__get_MaxRequestHeaderFieldSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxRequestHeaderFieldSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits.set_MaxRequestHeaderFieldSize(System.Int32)
    open func set_MaxRequestHeaderFieldSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Http3Limits_void__set_MaxRequestHeaderFieldSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Indicates the size of the maximum allowed size of a request header field sequence. This limit applies to both name and value sequences in their compressed and uncompressed representations.
            
            Value must be greater than 0, defaults to 2^14 (16,384).
            
            

    */
    open var MaxRequestHeaderFieldSize : Swift.Int32 {
        get {
            return try! get_MaxRequestHeaderFieldSize();
        }
        set(v) {
            return try! set_MaxRequestHeaderFieldSize(value: v);
        }
    }
} // Http3Limits


// type: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols
    /**
    
            HTTP protocol versions
            

    */
public struct HttpProtocols : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols None
    public static var None : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_None());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols Http1
    public static var Http1 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_Http1());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols Http2
    public static var Http2 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_Http2());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols Http1AndHttp2
    public static var Http1AndHttp2 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_Http1AndHttp2());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols Http3
    public static var Http3 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_Http3());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols Http1AndHttp2AndHttp3
    public static var Http1AndHttp2AndHttp3 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: Microsoft_AspNetCore_Server_Kestrel_Core_HttpProtocols_get_Http1AndHttp2AndHttp3());
            return __return;
        }
    }
} // HttpProtocols


// type: Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer
    /**
    
            Kestrel server.
            

    */
open class KestrelServer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Hosting_Server_IServer,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions>, Microsoft.AspNetCore.Connections.IConnectionListenerFactory, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions},Microsoft.AspNetCore.Connections.IConnectionListenerFactory,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Initializes a new instance of .
            

    - Parameter options: The Kestrel .
    - Parameter transportFactory: The .
    - Parameter loggerFactory: The .
    */
    public init(options : aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions>, transportFactory : aspnetcore.Microsoft.AspNetCore.Connections.IConnectionListenerFactory, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_ctor_0__3__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions__IConnectionListenerFactory_ILoggerFactory(&__thrown, options.get_handle(), transportFactory.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task StartAsync<TContext>(Microsoft.AspNetCore.Hosting.Server.IHttpApplication<TContext>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.StartAsync``1(Microsoft.AspNetCore.Hosting.Server.IHttpApplication{``0},System.Threading.CancellationToken)
    /**
    */
    open /* method final */ func StartAsync<UTContext : SGBridgeGenericValue>(application : aspnetcore.Microsoft.AspNetCore.Hosting.Server.IHttpApplication_1<UTContext>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_Task__StartAsync_1__2__Microsoft_AspNetCore_Hosting_Server_IHttpApplication_UTContext__CancellationToken(UTContext.get_type_handle(), &__thrown, self.get_handle(), application.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task StopAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.StopAsync(System.Threading.CancellationToken)
    /**
    */
    open /* method final */ func StopAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_Task__StopAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.Dispose
    /**
    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Features.IFeatureCollection get_Features()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.get_Features
    open /* method final */ func get_Features() throws -> aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_IFeatureCollection__get_Features_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions get_Options()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer.get_Options
    open func get_Options() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServer_KestrelServerOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions(hndl : __return);
        }
    }
    /**
    */
    public var Features : aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        get {
            return try! get_Features();
        }
    }
    /**
    
            Gets the .
            

    */
    open var Options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        get {
            return try! get_Options();
        }
    }
} // KestrelServer


// type: Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits
    /**
    
            Limits for .
            

    */
open class KestrelServerLimits
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxResponseBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxResponseBufferSize
    open func get_MaxResponseBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_System_Nullable_i64___get_MaxResponseBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxResponseBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxResponseBufferSize(System.Nullable{System.Int64})
    open func set_MaxResponseBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxResponseBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxRequestBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxRequestBufferSize
    open func get_MaxRequestBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_System_Nullable_i64___get_MaxRequestBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxRequestBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxRequestBufferSize(System.Nullable{System.Int64})
    open func set_MaxRequestBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxRequestBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxRequestLineSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxRequestLineSize
    open func get_MaxRequestLineSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_i32__get_MaxRequestLineSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxRequestLineSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxRequestLineSize(System.Int32)
    open func set_MaxRequestLineSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxRequestLineSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxRequestHeadersTotalSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxRequestHeadersTotalSize
    open func get_MaxRequestHeadersTotalSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_i32__get_MaxRequestHeadersTotalSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxRequestHeadersTotalSize(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxRequestHeadersTotalSize(System.Int32)
    open func set_MaxRequestHeadersTotalSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxRequestHeadersTotalSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxRequestHeaderCount()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxRequestHeaderCount
    open func get_MaxRequestHeaderCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_i32__get_MaxRequestHeaderCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxRequestHeaderCount(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxRequestHeaderCount(System.Int32)
    open func set_MaxRequestHeaderCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxRequestHeaderCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxRequestBodySize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxRequestBodySize
    open func get_MaxRequestBodySize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_System_Nullable_i64___get_MaxRequestBodySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxRequestBodySize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxRequestBodySize(System.Nullable{System.Int64})
    open func set_MaxRequestBodySize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxRequestBodySize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_KeepAliveTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_KeepAliveTimeout
    open func get_KeepAliveTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_TimeSpan__get_KeepAliveTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_KeepAliveTimeout(System.TimeSpan)
    // [IsSpecialName] System.TimeSpan get_RequestHeadersTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_RequestHeadersTimeout
    open func get_RequestHeadersTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_TimeSpan__get_RequestHeadersTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_RequestHeadersTimeout(System.TimeSpan)
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxConcurrentConnections()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxConcurrentConnections
    open func get_MaxConcurrentConnections() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_System_Nullable_i64___get_MaxConcurrentConnections_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxConcurrentConnections(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxConcurrentConnections(System.Nullable{System.Int64})
    open func set_MaxConcurrentConnections(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxConcurrentConnections_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxConcurrentUpgradedConnections()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MaxConcurrentUpgradedConnections
    open func get_MaxConcurrentUpgradedConnections() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_System_Nullable_i64___get_MaxConcurrentUpgradedConnections_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxConcurrentUpgradedConnections(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MaxConcurrentUpgradedConnections(System.Nullable{System.Int64})
    open func set_MaxConcurrentUpgradedConnections(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MaxConcurrentUpgradedConnections_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits get_Http2()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_Http2
    open func get_Http2() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_Http2Limits__get_Http2_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits get_Http3()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_Http3
    open func get_Http3() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_Http3Limits__get_Http3_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate get_MinRequestBodyDataRate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MinRequestBodyDataRate
    open func get_MinRequestBodyDataRate() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_MinDataRate__get_MinRequestBodyDataRate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_MinRequestBodyDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MinRequestBodyDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
    open func set_MinRequestBodyDataRate(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MinRequestBodyDataRate_0__1__MinDataRate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate get_MinResponseDataRate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.get_MinResponseDataRate
    open func get_MinResponseDataRate() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_MinDataRate__get_MinResponseDataRate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_MinResponseDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits.set_MinResponseDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
    open func set_MinResponseDataRate(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerLimits_void__set_MinResponseDataRate_0__1__MinDataRate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Limits only applicable to HTTP/2 connections.
            

    */
    open var Http2 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http2Limits {
        get {
            return try! get_Http2();
        }
    }
    /**
    
            Limits only applicable to HTTP/3 connections.
            

    */
    open var Http3 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Http3Limits {
        get {
            return try! get_Http3();
        }
    }
    /**
    
            Gets or sets the keep-alive timeout.
            Defaults to 130 seconds.
            

    */
    open var KeepAliveTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_KeepAliveTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_KeepAliveTimeout(System.TimeSpan)
    }
    /**
    
            Gets or sets the maximum number of open connections. When set to null, the number of connections is unlimited.
            
            Defaults to null.
            
            

    */
    open var MaxConcurrentConnections : Optional<Swift.Int64> {
        get {
            return try! get_MaxConcurrentConnections();
        }
        set(v) {
            return try! set_MaxConcurrentConnections(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum number of open, upgraded connections. When set to null, the number of upgraded connections is unlimited.
            An upgraded connection is one that has been switched from HTTP to another protocol, such as WebSockets.
            
            Defaults to null.
            
            

    */
    open var MaxConcurrentUpgradedConnections : Optional<Swift.Int64> {
        get {
            return try! get_MaxConcurrentUpgradedConnections();
        }
        set(v) {
            return try! set_MaxConcurrentUpgradedConnections(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum allowed size of any request body in bytes.
            When set to null, the maximum request body size is unlimited.
            This limit has no effect on upgraded connections which are always unlimited.
            This can be overridden per-request via .
            Defaults to 30,000,000 bytes, which is approximately 28.6MB.
            

    */
    open var MaxRequestBodySize : Optional<Swift.Int64> {
        get {
            return try! get_MaxRequestBodySize();
        }
        set(v) {
            return try! set_MaxRequestBodySize(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum size of the request buffer.
            Defaults to 1,048,576 bytes (1 MB).
            

    */
    open var MaxRequestBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxRequestBufferSize();
        }
        set(v) {
            return try! set_MaxRequestBufferSize(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum allowed number of headers per HTTP request.
            Defaults to 100.
            

    */
    open var MaxRequestHeaderCount : Swift.Int32 {
        get {
            return try! get_MaxRequestHeaderCount();
        }
        set(v) {
            return try! set_MaxRequestHeaderCount(value: v);
        }
    }
    /**
    
            Gets or sets the maximum allowed size for the HTTP request headers.
            Defaults to 32,768 bytes (32 KB).
            

    */
    open var MaxRequestHeadersTotalSize : Swift.Int32 {
        get {
            return try! get_MaxRequestHeadersTotalSize();
        }
        set(v) {
            return try! set_MaxRequestHeadersTotalSize(value: v);
        }
    }
    /**
    
            Gets or sets the maximum allowed size for the HTTP request line.
            Defaults to 8,192 bytes (8 KB).
            

    */
    open var MaxRequestLineSize : Swift.Int32 {
        get {
            return try! get_MaxRequestLineSize();
        }
        set(v) {
            return try! set_MaxRequestLineSize(value: v);
        }
    }
    /**
    
            Gets or sets the maximum size of the response buffer before write
            calls begin to block or return tasks that don't complete until the
            buffer size drops below the configured limit.
            Defaults to 65,536 bytes (64 KB).
            

    */
    open var MaxResponseBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxResponseBufferSize();
        }
        set(v) {
            return try! set_MaxResponseBufferSize(value: v!);
        }
    }
    /**
    
            Gets or sets the request body minimum data rate in bytes/second.
            Setting this property to null indicates no minimum data rate should be enforced.
            This limit has no effect on upgraded connections which are always unlimited.
            This can be overridden per-request via .
            Defaults to 240 bytes/second with a 5 second grace period.
            

    */
    open var MinRequestBodyDataRate : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        get {
            return try! get_MinRequestBodyDataRate();
        }
        set(v) {
            return try! set_MinRequestBodyDataRate(value: v!);
        }
    }
    /**
    
            Gets or sets the response minimum data rate in bytes/second.
            Setting this property to null indicates no minimum data rate should be enforced.
            This limit has no effect on upgraded connections which are always unlimited.
            This can be overridden per-request via .
            
            Defaults to 240 bytes/second with a 5 second grace period.
            
            

    */
    open var MinResponseDataRate : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        get {
            return try! get_MinResponseDataRate();
        }
        set(v) {
            return try! set_MinResponseDataRate(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum amount of time the server will spend receiving request headers.
            Defaults to 30 seconds.
            

    */
    open var RequestHeadersTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_RequestHeadersTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_RequestHeadersTimeout(System.TimeSpan)
    }
} // KestrelServerLimits


// type: Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions
    /**
    
            Provides programmatic configuration of Kestrel-specific features.
            

    */
open class KestrelServerOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void ConfigureEndpointDefaults(System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ConfigureEndpointDefaults(System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Specifies a configuration Action to run for each newly created endpoint. Calling this again will replace
            the prior action.
            

    */
    open func ConfigureEndpointDefaults(configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ConfigureEndpointDefaults_0__1__System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ConfigureEndpointDefaults(configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configureOptions);
        return try ConfigureEndpointDefaults(configureOptions: del_configureOptions);
    }
    // void ConfigureHttpsDefaults(System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ConfigureHttpsDefaults(System.Action{Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions})
    /**
    
            Specifies a configuration Action to run for each newly created https endpoint. Calling this again will replace
            the prior action.
            

    */
    open func ConfigureHttpsDefaults(configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ConfigureHttpsDefaults_0__1__System_Action_Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_(&__thrown, self.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ConfigureHttpsDefaults(configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try ConfigureHttpsDefaults(configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Configure()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Configure
    /**
    
            Creates a configuration loader for setting up Kestrel.
            

    - Returns: A  for configuring endpoints.

    */
    open func Configure() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_KestrelConfigurationLoader__Configure_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Configure(Microsoft.Extensions.Configuration.IConfiguration)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Configure(Microsoft.Extensions.Configuration.IConfiguration)
    /**
    
            Creates a configuration loader for setting up Kestrel that takes an  as input.
            This configuration must be scoped to the configuration section for Kestrel.
            Call  to enable dynamic endpoint binding updates.
            

    - Parameter config: The configuration section for Kestrel.
    - Returns: A  for further endpoint configuration.

    */
    open func Configure(config : aspnetcore.Microsoft.Extensions.Configuration.IConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_KestrelConfigurationLoader__Configure_0__1__IConfiguration(&__thrown, self.get_handle(), config.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader Configure(Microsoft.Extensions.Configuration.IConfiguration, bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Configure(Microsoft.Extensions.Configuration.IConfiguration,System.Boolean)
    /**
    
            Creates a configuration loader for setting up Kestrel that takes an  as input.
            This configuration must be scoped to the configuration section for Kestrel.
            

    - Parameter config: The configuration section for Kestrel.
    - Parameter reloadOnChange: 
            If , Kestrel will dynamically update endpoint bindings when configuration changes.
            This will only reload endpoints defined in the "Endpoints" section of your . Endpoints defined in code will not be reloaded.
            
    - Returns: A  for further endpoint configuration.

    */
    open func Configure(config : aspnetcore.Microsoft.Extensions.Configuration.IConfiguration, reloadOnChange : Bool) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_KestrelConfigurationLoader__Configure_0__2__IConfiguration_bool(&__thrown, self.get_handle(), config.get_handle(), Swift.Int32(reloadOnChange ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __return);
        }
    }
    // void Listen(System.Net.IPAddress, System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.IPAddress,System.Int32)
    /**
    
            Bind to given IP address and port.
            

    */
    open func Listen(address : dotnet.System.Net.IPAddress, port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__2__IPAddress_i32(&__thrown, self.get_handle(), address.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Listen(System.Net.IPAddress, System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.IPAddress,System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given IP address and port.
            The callback configures endpoint-specific settings.
            

    */
    open func Listen(address : dotnet.System.Net.IPAddress, port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__3__IPAddress_i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), address.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Listen(address : dotnet.System.Net.IPAddress, port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try Listen(address: address, port: port, configure: del_configure);
    }
    // void Listen(System.Net.IPEndPoint)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.IPEndPoint)
    /**
    
            Bind to the given IP endpoint.
            

    */
    open func Listen(endPoint : dotnet.System.Net.IPEndPoint) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__1__IPEndPoint(&__thrown, self.get_handle(), endPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Listen(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.EndPoint)
    /**
    
            Bind to the given endpoint.
            

    - Parameter endPoint: 
    */
    open func Listen(endPoint : dotnet.System.Net.EndPoint) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__1__EndPoint(&__thrown, self.get_handle(), endPoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Listen(System.Net.IPEndPoint, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.IPEndPoint,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given IP address and port.
            The callback configures endpoint-specific settings.
            

    */
    open func Listen(endPoint : dotnet.System.Net.IPEndPoint, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__2__IPEndPoint_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), endPoint.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Listen(endPoint : dotnet.System.Net.IPEndPoint, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try Listen(endPoint: endPoint, configure: del_configure);
    }
    // void Listen(System.Net.EndPoint, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.Listen(System.Net.EndPoint,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to the given endpoint.
            The callback configures endpoint-specific settings.
            

    */
    open func Listen(endPoint : dotnet.System.Net.EndPoint, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__Listen_0__2__EndPoint_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), endPoint.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Listen(endPoint : dotnet.System.Net.EndPoint, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try Listen(endPoint: endPoint, configure: del_configure);
    }
    // void ListenLocalhost(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenLocalhost(System.Int32)
    /**
    
            Listens on ::1 and 127.0.0.1 with the given port. Requesting a dynamic port by specifying 0 is not supported
            for this type of endpoint.
            

    */
    open func ListenLocalhost(port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenLocalhost_0__1__i32(&__thrown, self.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ListenLocalhost(System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenLocalhost(System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Listens on ::1 and 127.0.0.1 with the given port. Requesting a dynamic port by specifying 0 is not supported
            for this type of endpoint.
            

    */
    open func ListenLocalhost(port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenLocalhost_0__2__i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ListenLocalhost(port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try ListenLocalhost(port: port, configure: del_configure);
    }
    // void ListenAnyIP(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenAnyIP(System.Int32)
    /**
    
            Listens on all IPs using IPv6 [::], or IPv4 0.0.0.0 if IPv6 is not supported.
            

    */
    open func ListenAnyIP(port : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenAnyIP_0__1__i32(&__thrown, self.get_handle(), port);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ListenAnyIP(System.Int32, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenAnyIP(System.Int32,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Listens on all IPs using IPv6 [::], or IPv4 0.0.0.0 if IPv6 is not supported.
            

    */
    open func ListenAnyIP(port : Swift.Int32, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenAnyIP_0__2__i32_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), port, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ListenAnyIP(port : Swift.Int32, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try ListenAnyIP(port: port, configure: del_configure);
    }
    // void ListenUnixSocket(System.String)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenUnixSocket(System.String)
    /**
    
            Bind to given Unix domain socket path.
            

    */
    open func ListenUnixSocket(socketPath : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenUnixSocket_0__1__String(&__thrown, self.get_handle(), socketPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ListenUnixSocket(System.String, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenUnixSocket(System.String,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Bind to given Unix domain socket path.
            Specify callback to configure endpoint-specific settings.
            

    */
    open func ListenUnixSocket(socketPath : dotnet.System.String, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenUnixSocket_0__2__String_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), socketPath.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ListenUnixSocket(socketPath : dotnet.System.String, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try ListenUnixSocket(socketPath: socketPath, configure: del_configure);
    }
    // void ListenHandle(System.UInt64)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenHandle(System.UInt64)
    /**
    
            Open a socket file descriptor.
            

    */
    open func ListenHandle(handle : Swift.UInt64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenHandle_0__1__u64(&__thrown, self.get_handle(), handle);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ListenHandle(System.UInt64, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.ListenHandle(System.UInt64,System.Action{Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions})
    /**
    
            Open a socket file descriptor.
            The callback configures endpoint-specific settings.
            

    */
    open func ListenHandle(handle : Swift.UInt64, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__ListenHandle_0__2__u64_System_Action_Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_(&__thrown, self.get_handle(), handle, configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func ListenHandle(handle : Swift.UInt64, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try ListenHandle(handle: handle, configure: del_configure);
    }
    // [IsSpecialName] bool get_AddServerHeader()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_AddServerHeader
    open func get_AddServerHeader() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_bool__get_AddServerHeader_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AddServerHeader(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_AddServerHeader(System.Boolean)
    open func set_AddServerHeader(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_AddServerHeader_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowResponseHeaderCompression()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_AllowResponseHeaderCompression
    open func get_AllowResponseHeaderCompression() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_bool__get_AllowResponseHeaderCompression_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowResponseHeaderCompression(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_AllowResponseHeaderCompression(System.Boolean)
    open func set_AllowResponseHeaderCompression(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_AllowResponseHeaderCompression_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowSynchronousIO()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_AllowSynchronousIO
    open func get_AllowSynchronousIO() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_bool__get_AllowSynchronousIO_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowSynchronousIO(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_AllowSynchronousIO(System.Boolean)
    open func set_AllowSynchronousIO(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_AllowSynchronousIO_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowAlternateSchemes()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_AllowAlternateSchemes
    open func get_AllowAlternateSchemes() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_bool__get_AllowAlternateSchemes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowAlternateSchemes(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_AllowAlternateSchemes(System.Boolean)
    open func set_AllowAlternateSchemes(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_AllowAlternateSchemes_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_DisableStringReuse()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_DisableStringReuse
    open func get_DisableStringReuse() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_bool__get_DisableStringReuse_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DisableStringReuse(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_DisableStringReuse(System.Boolean)
    open func set_DisableStringReuse(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_DisableStringReuse_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Func<System.String,System.Text.Encoding> get_RequestHeaderEncodingSelector()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_RequestHeaderEncodingSelector
    open func get_RequestHeaderEncodingSelector() throws -> dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_System_Func_string_System_Text_Encoding___get_RequestHeaderEncodingSelector_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Func_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_RequestHeaderEncodingSelector(System.Func<System.String,System.Text.Encoding>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_RequestHeaderEncodingSelector(System.Func{System.String,System.Text.Encoding})
    open func set_RequestHeaderEncodingSelector(value : dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_RequestHeaderEncodingSelector_0__1__System_Func_string_System_Text_Encoding_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_RequestHeaderEncodingSelector(value : @escaping (Optional<dotnet.System.String>) throws -> dotnet.System.Text.Encoding) throws {
        let del_value = try dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding>(value);
        return try set_RequestHeaderEncodingSelector(value: del_value);
    }
    // [IsSpecialName] System.Func<System.String,System.Text.Encoding> get_ResponseHeaderEncodingSelector()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_ResponseHeaderEncodingSelector
    open func get_ResponseHeaderEncodingSelector() throws -> dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_System_Func_string_System_Text_Encoding___get_ResponseHeaderEncodingSelector_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Func_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ResponseHeaderEncodingSelector(System.Func<System.String,System.Text.Encoding>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_ResponseHeaderEncodingSelector(System.Func{System.String,System.Text.Encoding})
    open func set_ResponseHeaderEncodingSelector(value : dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_ResponseHeaderEncodingSelector_0__1__System_Func_string_System_Text_Encoding_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_ResponseHeaderEncodingSelector(value : @escaping (Optional<dotnet.System.String>) throws -> dotnet.System.Text.Encoding) throws {
        let del_value = try dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding>(value);
        return try set_ResponseHeaderEncodingSelector(value: del_value);
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_ApplicationServices
    open func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ApplicationServices(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_ApplicationServices(System.IServiceProvider)
    open func set_ApplicationServices(value : dotnet.System.IServiceProvider) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_ApplicationServices_0__1__IServiceProvider(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits get_Limits()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_Limits
    open func get_Limits() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_KestrelServerLimits__get_Limits_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader get_ConfigurationLoader()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.get_ConfigurationLoader
    open func get_ConfigurationLoader() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_KestrelConfigurationLoader__get_ConfigurationLoader_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ConfigurationLoader(Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.set_ConfigurationLoader(Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader)
    open func set_ConfigurationLoader(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_KestrelServerOptions_void__set_ConfigurationLoader_0__1__KestrelConfigurationLoader(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets whether the Server header should be included in each response.
            

    */
    open var AddServerHeader : Bool {
        get {
            return try! get_AddServerHeader();
        }
        set(v) {
            return try! set_AddServerHeader(value: v);
        }
    }
    /**
    
            Gets or sets a value that controls how the `:scheme` field for HTTP/2 and HTTP/3 requests is validated.
            
            If false then the `:scheme` field for HTTP/2 and HTTP/3 requests must exactly match the transport (e.g. https for TLS
            connections, http for non-TLS). If true then the `:scheme` field for HTTP/2 and HTTP/3 requests can be set to alternate values
            and this will be reflected by `HttpRequest.Scheme`. The Scheme must still be valid according to
            https://datatracker.ietf.org/doc/html/rfc3986/#section-3.1. Only enable this when working with a trusted proxy. This can be used in
            scenarios such as proxies converting from alternate protocols. See https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3.
            Applications that enable this should validate an expected scheme is provided before using it.
            
            

    */
    open var AllowAlternateSchemes : Bool {
        get {
            return try! get_AllowAlternateSchemes();
        }
        set(v) {
            return try! set_AllowAlternateSchemes(value: v);
        }
    }
    /**
    
            Gets or sets a value that controls whether dynamic compression of response headers is allowed.
            For more information about the security considerations of HPack dynamic header compression, visit
            https://tools.ietf.org/html/rfc7541#section-7.
            

    */
    open var AllowResponseHeaderCompression : Bool {
        get {
            return try! get_AllowResponseHeaderCompression();
        }
        set(v) {
            return try! set_AllowResponseHeaderCompression(value: v);
        }
    }
    /**
    
            Gets or sets a value that controls whether synchronous IO is allowed for the  and 
            

    */
    open var AllowSynchronousIO : Bool {
        get {
            return try! get_AllowSynchronousIO();
        }
        set(v) {
            return try! set_AllowSynchronousIO(value: v);
        }
    }
    /**
    
            Enables the Listen options callback to resolve and use services registered by the application during startup.
            Typically initialized by UseKestrel().
            

    */
    open var ApplicationServices : dotnet.System.IServiceProvider {
        get {
            return try! get_ApplicationServices();
        }
        set(v) {
            return try! set_ApplicationServices(value: v);
        }
    }
    /**
    
            Provides a configuration source where endpoints will be loaded from on server start.
            The default is .
            

    */
    open var ConfigurationLoader : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.KestrelConfigurationLoader> {
        get {
            return try! get_ConfigurationLoader();
        }
        set(v) {
            return try! set_ConfigurationLoader(value: v!);
        }
    }
    /**
    
            Gets or sets a value that controls whether the string values materialized
            will be reused across requests; if they match, or if the strings will always be reallocated.
            

    */
    open var DisableStringReuse : Bool {
        get {
            return try! get_DisableStringReuse();
        }
        set(v) {
            return try! set_DisableStringReuse(value: v);
        }
    }
    /**
    
            Provides access to request limit options.
            

    */
    open var Limits : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerLimits {
        get {
            return try! get_Limits();
        }
    }
    /**
    
            Gets or sets a callback that returns the  to decode the value for the specified request header name,
            or  to use the default .
            

    */
    open var RequestHeaderEncodingSelector : dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding> {
        get {
            return try! get_RequestHeaderEncodingSelector();
        }
        set(v) {
            return try! set_RequestHeaderEncodingSelector(value: v);
        }
    }
    /**
    
            Gets or sets a callback that returns the  to encode the value for the specified response header
            or trailer name, or  to use the default .
            

    */
    open var ResponseHeaderEncodingSelector : dotnet.System.Func_2<dotnet.System.String,dotnet.System.Text.Encoding> {
        get {
            return try! get_ResponseHeaderEncodingSelector();
        }
        set(v) {
            return try! set_ResponseHeaderEncodingSelector(value: v);
        }
    }
} // KestrelServerOptions


// type: Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions
    /**
    
            Describes either an , Unix domain socket path, or a file descriptor for an already open
            socket that Kestrel should bind to or open.
            

    */
open class ListenOptions
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Connections_IConnectionBuilder,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.ToString
    /**
    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Connections.IConnectionBuilder Use(System.Func<Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Use(System.Func{Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate})
    /**
    
            Adds a middleware delegate to the connection pipeline.
            Configured by the UseHttps() and 
            extension methods.
            

    - Parameter middleware: The middleware delegate.
    - Returns: The .

    */
    open /* method final */ func Use(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_IConnectionBuilder__Use_0__1__System_Func_Microsoft_AspNetCore_Connections_ConnectionDelegate_Microsoft_AspNetCore_Connections_ConnectionDelegate_(&__thrown, self.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    open /* method final */ func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>(middleware);
        return try Use(middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.ConnectionDelegate Build()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.Build
    /**
    
            Builds the .
            

    - Returns: The .

    */
    open /* method final */ func Build() throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_ConnectionDelegate__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_EndPoint()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_EndPoint
    open func get_EndPoint() throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_EndPoint__get_EndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
    // [IsSpecialName] void set_EndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.set_EndPoint(System.Net.EndPoint)
    open func set_EndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_void__set_EndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.IPEndPoint get_IPEndPoint()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_IPEndPoint
    open func get_IPEndPoint() throws -> Optional<dotnet.System.Net.IPEndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_IPEndPoint__get_IPEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.IPEndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_SocketPath()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_SocketPath
    open func get_SocketPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_String__get_SocketPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.UInt64 get_FileHandle()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_FileHandle
    open func get_FileHandle() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_u64__get_FileHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions get_KestrelServerOptions()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_KestrelServerOptions
    open func get_KestrelServerOptions() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_KestrelServerOptions__get_KestrelServerOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions(hndl : __return);
        }
    }
    // [IsSpecialName] void set_KestrelServerOptions(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.set_KestrelServerOptions(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions)
    open func set_KestrelServerOptions(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_void__set_KestrelServerOptions_0__1__KestrelServerOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols get_Protocols()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_Protocols
    open func get_Protocols() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_HttpProtocols__get_Protocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols(val: __return);
        }
    }
    // [IsSpecialName] void set_Protocols(Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.set_Protocols(Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols)
    open func set_Protocols(value : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_void__set_Protocols_0__1__HttpProtocols(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_DisableAltSvcHeader()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_DisableAltSvcHeader
    open func get_DisableAltSvcHeader() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_bool__get_DisableAltSvcHeader_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DisableAltSvcHeader(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.set_DisableAltSvcHeader(System.Boolean)
    open func set_DisableAltSvcHeader(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_void__set_DisableAltSvcHeader_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions.get_ApplicationServices
    open /* method final */ func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_ListenOptions_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
    /**
    
            Gets the application .
            

    */
    public var ApplicationServices : dotnet.System.IServiceProvider {
        get {
            return try! get_ApplicationServices();
        }
    }
    /**
    
            Gets or sets a value that controls whether the "Alt-Svc" header is included with response headers.
            The "Alt-Svc" header is used by clients to upgrade HTTP/1.1 and HTTP/2 connections to HTTP/3.
            
            The "Alt-Svc" header is automatically included with a response if  has either
            HTTP/1.1 or HTTP/2 enabled, and HTTP/3 is enabled. If an "Alt-Svc" header value has already been set
            by the app then it isn't changed.
            
            

    */
    open var DisableAltSvcHeader : Bool {
        get {
            return try! get_DisableAltSvcHeader();
        }
        set(v) {
            return try! set_DisableAltSvcHeader(value: v);
        }
    }
    /**
    
            Gets the .
            

    */
    open var EndPoint : dotnet.System.Net.EndPoint {
        get {
            return try! get_EndPoint();
        }
        set(v) {
            return try! set_EndPoint(value: v);
        }
    }
    /**
    
            A file descriptor for the socket to open.
            Only set if the   is .
            

    */
    open var FileHandle : Swift.UInt64 {
        get {
            return try! get_FileHandle();
        }
    }
    /**
    
            The  to bind to.
            Only set if the   is .
            

    */
    open var IPEndPoint : Optional<dotnet.System.Net.IPEndPoint> {
        get {
            return try! get_IPEndPoint();
        }
    }
    /**
    
            Enables connection middleware to resolve and use services registered by the application during startup.
            Only set if accessed from the callback of a  Listen(ASTERISK) method.
            

    */
    open var KestrelServerOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        get {
            return try! get_KestrelServerOptions();
        }
        set(v) {
            return try! set_KestrelServerOptions(value: v);
        }
    }
    /**
    
            The protocols enabled on this endpoint.
            

    */
    open var Protocols : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols {
        get {
            return try! get_Protocols();
        }
        set(v) {
            return try! set_Protocols(value: v);
        }
    }
    /**
    
            The absolute path to a Unix domain socket to bind to.
            Only set if the   is .
            

    */
    open var SocketPath : Optional<dotnet.System.String> {
        get {
            return try! get_SocketPath();
        }
    }
} // ListenOptions


// type: Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate
    /**
    
            The minimum data rate for incoming connections.
            

    */
open class MinDataRate
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_MinDataRate_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
// TODO COPE ctor (span) .ctor(System.Double, System.TimeSpan)
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate.ToString
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_MinDataRate_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Double get_BytesPerSecond()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate.get_BytesPerSecond
    open func get_BytesPerSecond() throws -> Swift.Double {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_MinDataRate_f64__get_BytesPerSecond_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_GracePeriod()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate.get_GracePeriod
    open func get_GracePeriod() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_MinDataRate_TimeSpan__get_GracePeriod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    /**
    
            The minimum rate in bytes/second at which data should be processed.
            

    */
    open var BytesPerSecond : Swift.Double {
        get {
            return try! get_BytesPerSecond();
        }
    }
    /**
    
            The amount of time to delay enforcement of ,
            starting at the time data is first read or written.
            

    */
    open var GracePeriod : dotnet.System.TimeSpan {
        get {
            return try! get_GracePeriod();
        }
    }
} // MinDataRate


}
// Microsoft.AspNetCore.Server.Kestrel.Core.Features
extension Microsoft.AspNetCore.Server.Kestrel.Core.Features {
// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature
    /**
    
            Feature for efficiently handling connection timeouts.
            

    */
open class IConnectionTimeoutFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_IConnectionTimeoutFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_IConnectionTimeoutFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

// TODO COPE (write_all_methods) (span) void SetTimeout(System.TimeSpan)
// TODO COPE (write_all_methods) (span) void ResetTimeout(System.TimeSpan)
    // void CancelTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IConnectionTimeoutFeature.CancelTimeout
    /**
    
            Prevent the connection from closing after a timeout specified by 
            or .
            

    */
    open func CancelTimeout() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Features_IConnectionTimeoutFeature_void__CancelTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionTimeoutFeature


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.IDecrementConcurrentConnectionCountFeature
    /**
    
            A connection feature allowing middleware to stop counting connections towards .
            This is used by Kestrel internally to stop counting upgraded connections towards this limit.
            

    */
open class IDecrementConcurrentConnectionCountFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_IDecrementConcurrentConnectionCountFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_IDecrementConcurrentConnectionCountFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void ReleaseConnection()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IDecrementConcurrentConnectionCountFeature.ReleaseConnection
    /**
    
            Idempotent method to stop counting a connection towards .
            

    */
    open func ReleaseConnection() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Features_IDecrementConcurrentConnectionCountFeature_void__ReleaseConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IDecrementConcurrentConnectionCountFeature


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature
    /**
    
            The stream id for a given stream in an HTTP/2 connection.
            

    */
open class IHttp2StreamIdFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttp2StreamIdFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttp2StreamIdFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Int32 get_StreamId()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttp2StreamIdFeature.get_StreamId
    open func get_StreamId() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttp2StreamIdFeature_i32__get_StreamId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // IHttp2StreamIdFeature


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature
    /**
    
            Feature to set the minimum data rate at which the the request body must be sent by the client.
            This feature is not supported for HTTP/2 requests except to disable it entirely by setting  to 
            Instead, use  for server-wide configuration which applies to both HTTP/2 and HTTP/1.x.
            

    */
open class IHttpMinRequestBodyDataRateFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinRequestBodyDataRateFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinRequestBodyDataRateFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate get_MinDataRate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.get_MinDataRate
    open func get_MinDataRate() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinRequestBodyDataRateFeature_MinDataRate__get_MinDataRate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_MinDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinRequestBodyDataRateFeature.set_MinDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
    open func set_MinDataRate(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinRequestBodyDataRateFeature_void__set_MinDataRate_0__1__MinDataRate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IHttpMinRequestBodyDataRateFeature


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature
    /**
    
            Feature to set the minimum data rate at which the response must be received by the client.
            This feature is not available for HTTP/2 requests. Instead, use 
            for server-wide configuration which applies to both HTTP/2 and HTTP/1.x.
            

    */
open class IHttpMinResponseDataRateFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinResponseDataRateFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinResponseDataRateFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate get_MinDataRate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.get_MinDataRate
    open func get_MinDataRate() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinResponseDataRateFeature_MinDataRate__get_MinDataRate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_MinDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.IHttpMinResponseDataRateFeature.set_MinDataRate(Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate)
    open func set_MinDataRate(value : Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.MinDataRate>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinResponseDataRateFeature_void__set_MinDataRate_0__1__MinDataRate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IHttpMinResponseDataRateFeature


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Features.ITlsApplicationProtocolFeature
    /**
    
            Feature to set access the TLS application protocol
            

    */
open class ITlsApplicationProtocolFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Features_ITlsApplicationProtocolFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Features_ITlsApplicationProtocolFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.ReadOnlyMemory<System.Byte> get_ApplicationProtocol()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Features.ITlsApplicationProtocolFeature.get_ApplicationProtocol
    open func get_ApplicationProtocol() throws -> dotnet.System.ReadOnlyMemory_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Features_ITlsApplicationProtocolFeature_System_ReadOnlyMemory_u8___get_ApplicationProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
} // ITlsApplicationProtocolFeature


}

// Microsoft.AspNetCore.Server.Kestrel.Core.Internal
// Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http
extension Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http {
// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod
public struct HttpMethod : SGBridgeGenericValue {
    let v : Swift.UInt8;
    public init(val: Swift.UInt8) { self.v = val; }
    public func get_value() -> Swift.UInt8 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.UInt8(gval); }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Get
    public static var Get : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Get());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Put
    public static var Put : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Put());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Delete
    public static var Delete : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Delete());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Post
    public static var Post : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Post());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Head
    public static var Head : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Head());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Trace
    public static var Trace : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Trace());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Patch
    public static var Patch : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Patch());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Connect
    public static var Connect : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Connect());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Options
    public static var Options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Options());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod Custom
    public static var Custom : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_Custom());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod None
    public static var None : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpMethod_get_None());
            return __return;
        }
    }
} // HttpMethod


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpParser`1
open class HttpParser_1<TRequestHandler : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpParser_1_get_type_handle(TRequestHandler.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpParser`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpParser_1_ctor_0__0(TRequestHandler.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpParser`1.#ctor(System.Boolean)
    public init(showErrorDetails : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpParser_1_ctor_0__1__bool(TRequestHandler.get_type_handle(), &__thrown, Swift.Int32(showErrorDetails ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // HttpParser_1


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme
public struct HttpScheme : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpScheme_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme Unknown
    public static var Unknown : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpScheme_get_Unknown());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme Http
    public static var Http : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpScheme_get_Http());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme Https
    public static var Https : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpScheme(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpScheme_get_Https());
            return __return;
        }
    }
} // HttpScheme


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion
public struct HttpVersion : SGBridgeGenericValue {
    let v : Swift.Int8;
    public init(val: Swift.Int8) { self.v = val; }
    public func get_value() -> Swift.Int8 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int8(gval); }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion Unknown
    public static var Unknown : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_Unknown());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion Http10
    public static var Http10 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_Http10());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion Http11
    public static var Http11 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_Http11());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion Http2
    public static var Http2 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_Http2());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion Http3
    public static var Http3 : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersion_get_Http3());
            return __return;
        }
    }
} // HttpVersion


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod
// boxed value type
public final class HttpVersionAndMethod
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public var Method : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        get {
            return try! get_Method();
        }
    }
    public var MethodEnd : Swift.Int32 {
        get {
            return try! get_MethodEnd();
        }
    }
    public var Version : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        get {
            return try! get_Version();
        }
        set(v) {
            return try! set_Version(value: v);
        }
    }
    // .ctor(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod, System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod.#ctor(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod,System.Int32)
    public init(method : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod, methodEnd : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_ctor_0__2__HttpMethod_i32(&__thrown, method.get_value(), methodEnd);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion get_Version()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod.get_Version
    public func get_Version() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_HttpVersion__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion(val: __return);
        }
    }
    // [IsSpecialName] void set_Version(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod.set_Version(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion)
    public func set_Version(value : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersion) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_void__set_Version_0__1__HttpVersion(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod get_Method()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod.get_Method
    public func get_Method() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_HttpMethod__get_Method_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpMethod(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_MethodEnd()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod.get_MethodEnd
    public func get_MethodEnd() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_HttpVersionAndMethod_i32__get_MethodEnd_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // HttpVersionAndMethod


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpHeadersHandler
open class IHttpHeadersHandler
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpHeadersHandler
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpHeadersHandler_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void OnStaticIndexedHeader(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpHeadersHandler.OnStaticIndexedHeader(System.Int32)
    open func OnStaticIndexedHeader(index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpHeadersHandler_void__OnStaticIndexedHeader_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void OnStaticIndexedHeader(System.Int32, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void OnHeader(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // void OnHeadersComplete(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpHeadersHandler.OnHeadersComplete(System.Boolean)
    open func OnHeadersComplete(endStream : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpHeadersHandler_void__OnHeadersComplete_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(endStream ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IHttpHeadersHandler


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.IHttpRequestLineHandler
open class IHttpRequestLineHandler
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpRequestLineHandler
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpRequestLineHandler_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

// TODO COPE (write_all_methods) (span) void OnStartLine(Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpVersionAndMethod, Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength, System.Span<System.Byte>)
} // IHttpRequestLineHandler


// type: Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength
// boxed value type
public final class TargetOffsetPathLength
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public var IsEncoded : Bool {
        get {
            return try! get_IsEncoded();
        }
    }
    public var Length : Swift.Int32 {
        get {
            return try! get_Length();
        }
    }
    public var Offset : Swift.Int32 {
        get {
            return try! get_Offset();
        }
    }
    // .ctor(System.Int32, System.Int32, bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength.#ctor(System.Int32,System.Int32,System.Boolean)
    public init(offset : Swift.Int32, length : Swift.Int32, isEncoded : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_ctor_0__3__i32_i32_bool(&__thrown, offset, length, Swift.Int32(isEncoded ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.Int32 get_Offset()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength.get_Offset
    public func get_Offset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_i32__get_Offset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_Length()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength.get_Length
    public func get_Length() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_i32__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsEncoded()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.TargetOffsetPathLength.get_IsEncoded
    public func get_IsEncoded() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_TargetOffsetPathLength_bool__get_IsEncoded_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // TargetOffsetPathLength


}



// Microsoft.AspNetCore.Server.Kestrel.Https
extension Microsoft.AspNetCore.Server.Kestrel.Https {
// type: Microsoft.AspNetCore.Server.Kestrel.Https.CertificateLoader
public struct CertificateLoader {
    // System.Security.Cryptography.X509Certificates.X509Certificate2 LoadFromStoreCert(System.String, System.String, System.Security.Cryptography.X509Certificates.StoreLocation, bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.CertificateLoader.LoadFromStoreCert(System.String,System.String,System.Security.Cryptography.X509Certificates.StoreLocation,System.Boolean)
    /**
    
            Loads a certificate from the certificate store.
            

    - Parameter subject: The certificate subject.
    - Parameter storeName: The certificate store name.
    - Parameter storeLocation: The certificate store location.
    - Parameter allowInvalid: Whether or not to load certificates that are considered invalid.
    - Returns: The loaded certificate.

    */
    public static func LoadFromStoreCert(subject : dotnet.System.String, storeName : dotnet.System.String, storeLocation : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, allowInvalid : Bool) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_CertificateLoader_X509Certificate2__LoadFromStoreCert_0__4__String_String_StoreLocation_bool(&__thrown, subject.get_handle(), storeName.get_handle(), storeLocation.get_value(), Swift.Int32(allowInvalid ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __return);
        }
    }
} // CertificateLoader


// type: Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode
    /**
    
            Describes the client certificate requirements for a HTTPS connection.
            

    */
public struct ClientCertificateMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode NoCertificate
    /**
    
            A client certificate is not required and will not be requested from clients.
            

    */
    public static var NoCertificate : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode(val: Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_get_NoCertificate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode AllowCertificate
    /**
    
            A client certificate will be requested; however, authentication will not fail if a certificate is not provided by the client.
            

    */
    public static var AllowCertificate : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode(val: Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_get_AllowCertificate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode RequireCertificate
    /**
    
            A client certificate will be requested, and the client must provide a valid certificate for authentication to succeed.
            

    */
    public static var RequireCertificate : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode(val: Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_get_RequireCertificate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode DelayCertificate
    /**
    
            A client certificate is not required and will not be requested from clients at the start of the connection.
            It may be requested by the application later.
            

    */
    public static var DelayCertificate : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode(val: Microsoft_AspNetCore_Server_Kestrel_Https_ClientCertificateMode_get_DelayCertificate());
            return __return;
        }
    }
} // ClientCertificateMode


// type: Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions
    /**
    
            Settings for how Kestrel should handle HTTPS connections.
            

    */
open class HttpsConnectionAdapterOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AllowAnyClientCertificate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.AllowAnyClientCertificate
    /**
    
            Overrides the current  callback and allows any client certificate.
            

    */
    open func AllowAnyClientCertificate() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__AllowAnyClientCertificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate2 get_ServerCertificate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_ServerCertificate
    open func get_ServerCertificate() throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_X509Certificate2__get_ServerCertificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ServerCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_ServerCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2)
    open func set_ServerCertificate(value : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_ServerCertificate_0__1__X509Certificate2(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.String,System.Security.Cryptography.X509Certificates.X509Certificate2> get_ServerCertificateSelector()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_ServerCertificateSelector
    open func get_ServerCertificateSelector() throws -> Optional<dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.String,dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_System_Func_Microsoft_AspNetCore_Connections_ConnectionContext_string_System_Security_Cryptography_X509Certificates_X509Certificate2___get_ServerCertificateSelector_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_3(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ServerCertificateSelector(System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.String,System.Security.Cryptography.X509Certificates.X509Certificate2>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_ServerCertificateSelector(System.Func{Microsoft.AspNetCore.Connections.ConnectionContext,System.String,System.Security.Cryptography.X509Certificates.X509Certificate2})
    open func set_ServerCertificateSelector(value : Optional<dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.String,dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_ServerCertificateSelector_0__1__System_Func_Microsoft_AspNetCore_Connections_ConnectionContext_string_System_Security_Cryptography_X509Certificates_X509Certificate2_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_ServerCertificateSelector(value : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>, Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws {
        let del_value = try dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.String,dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>(value);
        return try set_ServerCertificateSelector(value: del_value);
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode get_ClientCertificateMode()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_ClientCertificateMode
    open func get_ClientCertificateMode() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_ClientCertificateMode__get_ClientCertificateMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode(val: __return);
        }
    }
    // [IsSpecialName] void set_ClientCertificateMode(Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_ClientCertificateMode(Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode)
    open func set_ClientCertificateMode(value : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_ClientCertificateMode_0__1__ClientCertificateMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Func<System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool> get_ClientCertificateValidation()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_ClientCertificateValidation
    open func get_ClientCertificateValidation() throws -> Optional<dotnet.System.Func_4<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2,dotnet.System.Security.Cryptography.X509Certificates.X509Chain,dotnet.System.Net.Security.SslPolicyErrors,Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_System_Func_System_Security_Cryptography_X509Certificates_X509Certificate2_System_Security_Cryptography_X509Certificates_X509Chain_System_Net_Security_SslPolicyErrors_bool___get_ClientCertificateValidation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_4(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClientCertificateValidation(System.Func<System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_ClientCertificateValidation(System.Func{System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean})
    open func set_ClientCertificateValidation(value : Optional<dotnet.System.Func_4<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2,dotnet.System.Security.Cryptography.X509Certificates.X509Chain,dotnet.System.Net.Security.SslPolicyErrors,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_ClientCertificateValidation_0__1__System_Func_System_Security_Cryptography_X509Certificates_X509Certificate2_System_Security_Cryptography_X509Certificates_X509Chain_System_Net_Security_SslPolicyErrors_bool_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_ClientCertificateValidation(value : @escaping (Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool) throws {
        let del_value = try dotnet.System.Func_4<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2,dotnet.System.Security.Cryptography.X509Certificates.X509Chain,dotnet.System.Net.Security.SslPolicyErrors,Swift.Bool>(value);
        return try set_ClientCertificateValidation(value: del_value);
    }
    // [IsSpecialName] System.Security.Authentication.SslProtocols get_SslProtocols()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_SslProtocols
    open func get_SslProtocols() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_SslProtocols__get_SslProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
    // [IsSpecialName] void set_SslProtocols(System.Security.Authentication.SslProtocols)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_SslProtocols(System.Security.Authentication.SslProtocols)
    open func set_SslProtocols(value : dotnet.System.Security.Authentication.SslProtocols) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_SslProtocols_0__1__SslProtocols(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CheckCertificateRevocation()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_CheckCertificateRevocation
    open func get_CheckCertificateRevocation() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_bool__get_CheckCertificateRevocation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_CheckCertificateRevocation(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_CheckCertificateRevocation(System.Boolean)
    open func set_CheckCertificateRevocation(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_CheckCertificateRevocation_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Action<Microsoft.AspNetCore.Connections.ConnectionContext,System.Net.Security.SslServerAuthenticationOptions> get_OnAuthenticate()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_OnAuthenticate
    open func get_OnAuthenticate() throws -> Optional<dotnet.System.Action_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Net.Security.SslServerAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_System_Action_Microsoft_AspNetCore_Connections_ConnectionContext_System_Net_Security_SslServerAuthenticationOptions___get_OnAuthenticate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Action_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_OnAuthenticate(System.Action<Microsoft.AspNetCore.Connections.ConnectionContext,System.Net.Security.SslServerAuthenticationOptions>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.set_OnAuthenticate(System.Action{Microsoft.AspNetCore.Connections.ConnectionContext,System.Net.Security.SslServerAuthenticationOptions})
    open func set_OnAuthenticate(value : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Net.Security.SslServerAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_void__set_OnAuthenticate_0__1__System_Action_Microsoft_AspNetCore_Connections_ConnectionContext_System_Net_Security_SslServerAuthenticationOptions_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_OnAuthenticate(value : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>, Optional<dotnet.System.Net.Security.SslServerAuthenticationOptions>) throws -> Void) throws {
        let del_value = try dotnet.System.Action_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Net.Security.SslServerAuthenticationOptions>(value);
        return try set_OnAuthenticate(value: del_value);
    }
    // [IsSpecialName] System.TimeSpan get_HandshakeTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions.get_HandshakeTimeout
    open func get_HandshakeTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_HttpsConnectionAdapterOptions_TimeSpan__get_HandshakeTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_HandshakeTimeout(System.TimeSpan)
    /**
    
            Specifies whether the certificate revocation list is checked during authentication.
            

    */
    open var CheckCertificateRevocation : Bool {
        get {
            return try! get_CheckCertificateRevocation();
        }
        set(v) {
            return try! set_CheckCertificateRevocation(value: v);
        }
    }
    /**
    
            Specifies the client certificate requirements for a HTTPS connection. Defaults to .
            

    */
    open var ClientCertificateMode : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.ClientCertificateMode {
        get {
            return try! get_ClientCertificateMode();
        }
        set(v) {
            return try! set_ClientCertificateMode(value: v);
        }
    }
    /**
    
            Specifies a callback for additional client certificate validation that will be invoked during authentication. This will be ignored
            if  is called after this callback is set.
            

    */
    open var ClientCertificateValidation : Optional<dotnet.System.Func_4<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2,dotnet.System.Security.Cryptography.X509Certificates.X509Chain,dotnet.System.Net.Security.SslPolicyErrors,Bool>> {
        get {
            return try! get_ClientCertificateValidation();
        }
        set(v) {
            return try! set_ClientCertificateValidation(value: v!);
        }
    }
    /**
    
            Specifies the maximum amount of time allowed for the TLS/SSL handshake. This must be positive
            or . Defaults to 10 seconds.
            

    */
    open var HandshakeTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_HandshakeTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_HandshakeTimeout(System.TimeSpan)
    }
    /**
    
            Provides direct configuration of the  on a per-connection basis.
            This is called after all of the other settings have already been applied.
            

    */
    open var OnAuthenticate : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Net.Security.SslServerAuthenticationOptions>> {
        get {
            return try! get_OnAuthenticate();
        }
        set(v) {
            return try! set_OnAuthenticate(value: v!);
        }
    }
    /**
    
            
            Specifies the server certificate used to authenticate HTTPS connections. This is ignored if ServerCertificateSelector is set.
            
            
            If the server certificate has an Extended Key Usage extension, the usages must include Server Authentication (OID 1.3.6.1.5.5.7.3.1).
            
            

    */
    open var ServerCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2> {
        get {
            return try! get_ServerCertificate();
        }
        set(v) {
            return try! set_ServerCertificate(value: v!);
        }
    }
    /**
    
            
            A callback that will be invoked to dynamically select a server certificate. This is higher priority than ServerCertificate.
            If SNI is not available then the name parameter will be null. The  will be null for HTTP/3 connections.
            
            
            If the server certificate has an Extended Key Usage extension, the usages must include Server Authentication (OID 1.3.6.1.5.5.7.3.1).
            
            

    */
    open var ServerCertificateSelector : Optional<dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.String,dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>> {
        get {
            return try! get_ServerCertificateSelector();
        }
        set(v) {
            return try! set_ServerCertificateSelector(value: v!);
        }
    }
    /**
    
            Specifies allowable SSL protocols. Defaults to  which allows the operating system to choose the best protocol to use,
            and to block protocols that are not secure. Unless your app has a specific reason not to, you should use this default.
            

    */
    open var SslProtocols : dotnet.System.Security.Authentication.SslProtocols {
        get {
            return try! get_SslProtocols();
        }
        set(v) {
            return try! set_SslProtocols(value: v);
        }
    }
} // HttpsConnectionAdapterOptions


// type: Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext
    /**
    
            Per connection state used to determine the TLS options.
            

    */
open class TlsHandshakeCallbackContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Net.Security.SslStream get_SslStream()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_SslStream
    open func get_SslStream() throws -> dotnet.System.Net.Security.SslStream {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_SslStream__get_SslStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslStream(hndl : __return);
        }
    }
    // [IsSpecialName] void set_SslStream(System.Net.Security.SslStream)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_SslStream(System.Net.Security.SslStream)
    open func set_SslStream(value : Optional<dotnet.System.Net.Security.SslStream>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_SslStream_0__1__SslStream(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.SslClientHelloInfo get_ClientHelloInfo()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_ClientHelloInfo
    open func get_ClientHelloInfo() throws -> dotnet.System.Net.Security.SslClientHelloInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_SslClientHelloInfo__get_ClientHelloInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslClientHelloInfo(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ClientHelloInfo(System.Net.Security.SslClientHelloInfo)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_ClientHelloInfo(System.Net.Security.SslClientHelloInfo)
    open func set_ClientHelloInfo(value : Optional<dotnet.System.Net.Security.SslClientHelloInfo>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_ClientHelloInfo_0__1__SslClientHelloInfo(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Object get_State()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_State
    open func get_State() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_Object__get_State_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_State(System.Object)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_State(System.Object)
    open func set_State(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_State_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_CancellationToken()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_CancellationToken
    open func get_CancellationToken() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_CancellationToken__get_CancellationToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] void set_CancellationToken(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_CancellationToken(System.Threading.CancellationToken)
    open func set_CancellationToken(value : Optional<dotnet.System.Threading.CancellationToken>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_CancellationToken_0__1__CancellationToken(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Connections.ConnectionContext get_Connection()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_Connection
    open func get_Connection() throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_ConnectionContext__get_Connection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Connection(Microsoft.AspNetCore.Connections.ConnectionContext)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_Connection(Microsoft.AspNetCore.Connections.ConnectionContext)
    open func set_Connection(value : Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_Connection_0__1__ConnectionContext(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowDelayedClientCertificateNegotation()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.get_AllowDelayedClientCertificateNegotation
    open func get_AllowDelayedClientCertificateNegotation() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_bool__get_AllowDelayedClientCertificateNegotation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowDelayedClientCertificateNegotation(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext.set_AllowDelayedClientCertificateNegotation(System.Boolean)
    open func set_AllowDelayedClientCertificateNegotation(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_void__set_AllowDelayedClientCertificateNegotation_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Indicates if the application is allowed to request a client certificate after the handshake has completed.
            The default is false. See 
            

    */
    open var AllowDelayedClientCertificateNegotation : Bool {
        get {
            return try! get_AllowDelayedClientCertificateNegotation();
        }
        set(v) {
            return try! set_AllowDelayedClientCertificateNegotation(value: v);
        }
    }
    /**
    
            The token to monitor for cancellation requests.
            

    */
    open var CancellationToken : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_CancellationToken();
        }
        set(v) {
            return try! set_CancellationToken(value: v);
        }
    }
    /**
    
            Information from the Client Hello message.
            

    */
    open var ClientHelloInfo : dotnet.System.Net.Security.SslClientHelloInfo {
        get {
            return try! get_ClientHelloInfo();
        }
        set(v) {
            return try! set_ClientHelloInfo(value: v);
        }
    }
    /**
    
            Information about an individual connection.
            

    */
    open var Connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext {
        get {
            return try! get_Connection();
        }
        set(v) {
            return try! set_Connection(value: v);
        }
    }
    /**
    
            The TLS stream on which the authentication happens.
            

    */
    open var SslStream : dotnet.System.Net.Security.SslStream {
        get {
            return try! get_SslStream();
        }
        set(v) {
            return try! set_SslStream(value: v);
        }
    }
    /**
    
            The information that was passed when registering the callback.
            

    */
    open var State : Optional<dotnet.System.Object> {
        get {
            return try! get_State();
        }
        set(v) {
            return try! set_State(value: v!);
        }
    }
} // TlsHandshakeCallbackContext


// type: Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions
    /**
    
            Options used to configure a per connection callback for TLS configuration.
            

    */
open class TlsHandshakeCallbackOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Func<Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions>> get_OnConnection()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.get_OnConnection
    open func get_OnConnection() throws -> dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_System_Func_Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_System_Threading_Tasks_System_Threading_Tasks_ValueTask_System_Net_Security_SslServerAuthenticationOptions____get_OnConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Func_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_OnConnection(System.Func<Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions>>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.set_OnConnection(System.Func{Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,System.Threading.Tasks.ValueTask{System.Net.Security.SslServerAuthenticationOptions}})
    open func set_OnConnection(value : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_void__set_OnConnection_0__1__System_Func_Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackContext_System_Threading_Tasks_System_Threading_Tasks_ValueTask_System_Net_Security_SslServerAuthenticationOptions__(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_OnConnection(value : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext>) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>) throws {
        let del_value = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>>(value);
        return try set_OnConnection(value: del_value);
    }
    // [IsSpecialName] System.Object get_OnConnectionState()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.get_OnConnectionState
    open func get_OnConnectionState() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_Object__get_OnConnectionState_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_OnConnectionState(System.Object)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.set_OnConnectionState(System.Object)
    open func set_OnConnectionState(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_void__set_OnConnectionState_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_HandshakeTimeout()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions.get_HandshakeTimeout
    open func get_HandshakeTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Https_TlsHandshakeCallbackOptions_TimeSpan__get_HandshakeTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_HandshakeTimeout(System.TimeSpan)
    /**
    
            Specifies the maximum amount of time allowed for the TLS/SSL handshake. This must be positive
            or . Defaults to 10 seconds.
            

    */
    open var HandshakeTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_HandshakeTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_HandshakeTimeout(System.TimeSpan)
    }
    /**
    
            The callback to invoke per connection. This property is required.
            

    */
    open var OnConnection : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackContext,dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>> {
        get {
            return try! get_OnConnection();
        }
        set(v) {
            return try! set_OnConnection(value: v);
        }
    }
    /**
    
            Optional application state to flow to the  callback.
            

    */
    open var OnConnectionState : Optional<dotnet.System.Object> {
        get {
            return try! get_OnConnectionState();
        }
        set(v) {
            return try! set_OnConnectionState(value: v!);
        }
    }
} // TlsHandshakeCallbackOptions


}





public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_IConnectionTimeoutFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_IDecrementConcurrentConnectionCountFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttp2StreamIdFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinRequestBodyDataRateFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_IHttpMinResponseDataRateFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Features_ITlsApplicationProtocolFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpHeadersHandler
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_Kestrel_Core_Internal_Http_IHttpRequestLineHandler
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
    public func UseSystemd() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions.UseSystemd(options: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions UseSystemd(Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions, System.Action<Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
    public func UseSystemd(configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions.UseSystemd(options: self, configure: configure);
    }
    // delegate closure overload
    public func UseSystemd(configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>(configure);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.KestrelServerOptionsSystemdExtensions.UseSystemd(options: self, configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseConnectionLogging() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions.UseConnectionLogging(listenOptions: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseConnectionLogging(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseConnectionLogging(loggerName : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsConnectionLoggingExtensions.UseConnectionLogging(listenOptions: self, loggerName: loggerName);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps() throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(fileName : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, fileName: fileName);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String, System.String)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(fileName : dotnet.System.String, password : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, fileName: fileName, password: password);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.String, System.String, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, fileName: fileName, password: password, configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseHttps(fileName : dotnet.System.String, password : Optional<dotnet.System.String>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, fileName: fileName, password: password, configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, storeName: storeName, subject: subject);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, storeName: storeName, subject: subject, allowInvalid: allowInvalid);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool, System.Security.Cryptography.X509Certificates.StoreLocation)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, storeName: storeName, subject: subject, allowInvalid: allowInvalid, location: location);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.StoreName, System.String, bool, System.Security.Cryptography.X509Certificates.StoreLocation, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, storeName: storeName, subject: subject, allowInvalid: allowInvalid, location: location, configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseHttps(storeName : dotnet.System.Security.Cryptography.X509Certificates.StoreName, subject : dotnet.System.String, allowInvalid : Bool, location : dotnet.System.Security.Cryptography.X509Certificates.StoreLocation, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, storeName: storeName, subject: subject, allowInvalid: allowInvalid, location: location, configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.X509Certificate2)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, serverCertificate: serverCertificate);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, serverCertificate: serverCertificate, configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseHttps(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, serverCertificate: serverCertificate, configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Action<Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseHttps(configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(httpsOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.HttpsConnectionAdapterOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, httpsOptions: httpsOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Net.Security.ServerOptionsSelectionCallback, System.Object)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(serverOptionsSelectionCallback : dotnet.System.Net.Security.ServerOptionsSelectionCallback, state : dotnet.System.Object) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, serverOptionsSelectionCallback: serverOptionsSelectionCallback, state: state);
    }
    // delegate closure overload
    public func UseHttps(serverOptionsSelectionCallback : @escaping (dotnet.System.Net.Security.SslStream, dotnet.System.Net.Security.SslClientHelloInfo, Optional<dotnet.System.Object>, dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>, state : dotnet.System.Object) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        let del_serverOptionsSelectionCallback = try dotnet.System.Net.Security.ServerOptionsSelectionCallback(serverOptionsSelectionCallback);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, serverOptionsSelectionCallback: del_serverOptionsSelectionCallback, state: state);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Net.Security.ServerOptionsSelectionCallback, System.Object, System.TimeSpan)
// TODO COPE extension method (span) Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, System.Net.Security.ServerOptionsSelectionCallback, System.Object, System.TimeSpan)

// EXTENSION METHOD Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions UseHttps(Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions, Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions)
extension aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
    public func UseHttps(callbackOptions : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Https.TlsHandshakeCallbackOptions) throws -> aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(listenOptions: self, callbackOptions: callbackOptions);
    }
}

