// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Identity
extension Microsoft.AspNetCore.Identity {
// type: Microsoft.AspNetCore.Identity.AuthenticatorTokenProvider`1
    /**
    
            Used for authenticator code verification.
            

    */
open class AuthenticatorTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_AuthenticatorTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.AuthenticatorTokenProvider`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_AuthenticatorTokenProvider_1_ctor_0__0(TUser.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.AuthenticatorTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Checks if a two-factor authentication token can be generated for the specified .
            

    - Parameter manager: The  to retrieve the  from.
    - Parameter user: The  to check for the possibility of generating a two-factor authentication token.
    - Returns: True if the user has an authenticator key set, otherwise false.

    */
    open func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_AuthenticatorTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.AuthenticatorTokenProvider`1.GenerateAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns an empty string since no authenticator codes are sent.
            

    - Parameter purpose: Ignored.
    - Parameter manager: The  to retrieve the  from.
    - Parameter user: The .
    - Returns: string.Empty.

    */
    open func GenerateAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_AuthenticatorTokenProvider_1_System_Threading_Tasks_Task_string___GenerateAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> ValidateAsync(System.String, System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.AuthenticatorTokenProvider`1.ValidateAsync(System.String,System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            
             

    - Parameter purpose: 
    - Parameter token: 
    - Parameter manager: 
    - Parameter user: 
    - Returns: 

    */
    open func ValidateAsync(purpose : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_AuthenticatorTokenProvider_1_System_Threading_Tasks_Task_bool___ValidateAsync_0__4__String_String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, token?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // AuthenticatorTokenProvider_1


// type: Microsoft.AspNetCore.Identity.ClaimsIdentityOptions
    /**
    
            Options used to configure the claim types used for well known claims.
            

    */
open class ClaimsIdentityOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_RoleClaimType()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.get_RoleClaimType
    open func get_RoleClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_String__get_RoleClaimType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RoleClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.set_RoleClaimType(System.String)
    open func set_RoleClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_void__set_RoleClaimType_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_UserNameClaimType()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.get_UserNameClaimType
    open func get_UserNameClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_String__get_UserNameClaimType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UserNameClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.set_UserNameClaimType(System.String)
    open func set_UserNameClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_void__set_UserNameClaimType_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_UserIdClaimType()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.get_UserIdClaimType
    open func get_UserIdClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_String__get_UserIdClaimType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UserIdClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.set_UserIdClaimType(System.String)
    open func set_UserIdClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_void__set_UserIdClaimType_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_EmailClaimType()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.get_EmailClaimType
    open func get_EmailClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_String__get_EmailClaimType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EmailClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.set_EmailClaimType(System.String)
    open func set_EmailClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_void__set_EmailClaimType_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_SecurityStampClaimType()
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.get_SecurityStampClaimType
    open func get_SecurityStampClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_String__get_SecurityStampClaimType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SecurityStampClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ClaimsIdentityOptions.set_SecurityStampClaimType(System.String)
    open func set_SecurityStampClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ClaimsIdentityOptions_void__set_SecurityStampClaimType_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the ClaimType used for the user email claim. Defaults to .
            

    */
    open var EmailClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_EmailClaimType();
        }
        set(v) {
            return try! set_EmailClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the ClaimType used for a Role claim. Defaults to .
            

    */
    open var RoleClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_RoleClaimType();
        }
        set(v) {
            return try! set_RoleClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the ClaimType used for the security stamp claim. Defaults to "AspNet.Identity.SecurityStamp".
            

    */
    open var SecurityStampClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_SecurityStampClaimType();
        }
        set(v) {
            return try! set_SecurityStampClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the ClaimType used for the user identifier claim. Defaults to .
            

    */
    open var UserIdClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_UserIdClaimType();
        }
        set(v) {
            return try! set_UserIdClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the ClaimType used for the user name claim. Defaults to .
            

    */
    open var UserNameClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_UserNameClaimType();
        }
        set(v) {
            return try! set_UserNameClaimType(value: v!);
        }
    }
} // ClaimsIdentityOptions


// type: Microsoft.AspNetCore.Identity.DefaultPersonalDataProtector
    /**
    
            Default implementation of  that uses 
            and  to protect data with a payload format of {keyId}:{protectedData}
            

    */
open class DefaultPersonalDataProtector
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Identity_IPersonalDataProtector
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_DefaultPersonalDataProtector_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing, Microsoft.AspNetCore.Identity.ILookupProtector)
// docid: M:Microsoft.AspNetCore.Identity.DefaultPersonalDataProtector.#ctor(Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing,Microsoft.AspNetCore.Identity.ILookupProtector)
    /**
    
            Constructor.
            

    - Parameter keyRing: 
    - Parameter protector: 
    */
    public init(keyRing : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing>, protector : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupProtector>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_DefaultPersonalDataProtector_ctor_0__2__ILookupProtectorKeyRing_ILookupProtector(&__thrown, keyRing?.get_handle() ?? nil, protector?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String Unprotect(System.String)
// docid: M:Microsoft.AspNetCore.Identity.DefaultPersonalDataProtector.Unprotect(System.String)
    /**
    
            Unprotect the data.
            

    - Parameter data: The data to unprotect.
    - Returns: The unprotected data.

    */
    open func Unprotect(data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DefaultPersonalDataProtector_String__Unprotect_0__1__String(&__thrown, self.get_handle(), data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String Protect(System.String)
// docid: M:Microsoft.AspNetCore.Identity.DefaultPersonalDataProtector.Protect(System.String)
    /**
    
            Protect the data.
            

    - Parameter data: The data to protect.
    - Returns: The protected data.

    */
    open func Protect(data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DefaultPersonalDataProtector_String__Protect_0__1__String(&__thrown, self.get_handle(), data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DefaultPersonalDataProtector


// type: Microsoft.AspNetCore.Identity.DefaultUserConfirmation`1
    /**
    
            Default implementation of .
            

    */
open class DefaultUserConfirmation_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_DefaultUserConfirmation_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.DefaultUserConfirmation`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_DefaultUserConfirmation_1_ctor_0__0(TUser.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<bool> IsConfirmedAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.DefaultUserConfirmation`1.IsConfirmedAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Determines whether the specified  is confirmed.
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user.
    - Returns: The  that represents the asynchronous operation, containing the  of the confirmation operation.

    */
    open func IsConfirmedAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DefaultUserConfirmation_1_System_Threading_Tasks_Task_bool___IsConfirmedAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DefaultUserConfirmation_1


// type: Microsoft.AspNetCore.Identity.EmailTokenProvider`1
    /**
    
            TokenProvider that generates tokens from the user's security stamp and notifies a user via email.
            

    */
open class EmailTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider_1<TUser>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_EmailTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.EmailTokenProvider`1.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_EmailTokenProvider_1_ctor_0__0(TUser.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.EmailTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Checks if a two-factor authentication token can be generated for the specified .
            

    - Parameter manager: The  to retrieve the  from.
    - Parameter user: The  to check for the possibility of generating a two-factor authentication token.
    - Returns: True if the user has an email address set, otherwise false.

    */
    open override func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_EmailTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserModifierAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.EmailTokenProvider`1.GetUserModifierAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns the a value for the user used as entropy in the generated token.
            

    - Parameter purpose: The purpose of the two-factor authentication token.
    - Parameter manager: The  to retrieve the  from.
    - Parameter user: The  to check for the possibility of generating a two-factor authentication token.
    - Returns: A string suitable for use as entropy in token generation.

    */
    open override func GetUserModifierAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_EmailTokenProvider_1_System_Threading_Tasks_Task_string___GetUserModifierAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // EmailTokenProvider_1


// type: Microsoft.AspNetCore.Identity.ILookupNormalizer
    /**
    
            Provides an abstraction for normalizing keys (emails/names) for lookup purposes.
            

    */
open class ILookupNormalizer
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_ILookupNormalizer
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ILookupNormalizer_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.String NormalizeName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ILookupNormalizer.NormalizeName(System.String)
    /**
    
            Returns a normalized representation of the specified .
            

    - Parameter name: The key to normalize.
    - Returns: A normalized representation of the specified .

    */
    open func NormalizeName(name : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupNormalizer_String__NormalizeName_0__1__String(&__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String NormalizeEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ILookupNormalizer.NormalizeEmail(System.String)
    /**
    
            Returns a normalized representation of the specified .
            

    - Parameter email: The email to normalize.
    - Returns: A normalized representation of the specified .

    */
    open func NormalizeEmail(email : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupNormalizer_String__NormalizeEmail_0__1__String(&__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ILookupNormalizer


// type: Microsoft.AspNetCore.Identity.ILookupProtector
    /**
    
            Used to protect/unprotect lookups with a specific key.
            

    */
open class ILookupProtector
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_ILookupProtector
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ILookupProtector_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.String Protect(System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.ILookupProtector.Protect(System.String,System.String)
    /**
    
            Protect the data using the specified key.
            

    - Parameter keyId: The key to use.
    - Parameter data: The data to protect.
    - Returns: The protected data.

    */
    open func Protect(keyId : Optional<dotnet.System.String>, data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupProtector_String__Protect_0__2__String_String(&__thrown, self.get_handle(), keyId?.get_handle() ?? nil, data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String Unprotect(System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.ILookupProtector.Unprotect(System.String,System.String)
    /**
    
            Unprotect the data using the specified key.
            

    - Parameter keyId: The key to use.
    - Parameter data: The data to unprotect.
    - Returns: The original data.

    */
    open func Unprotect(keyId : Optional<dotnet.System.String>, data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupProtector_String__Unprotect_0__2__String_String(&__thrown, self.get_handle(), keyId?.get_handle() ?? nil, data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ILookupProtector


// type: Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing
    /**
    
            Abstraction used to manage named keys used to protect lookups.
            

    */
open class ILookupProtectorKeyRing
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Collections.Generic.IEnumerable<System.String> GetAllKeyIds()
// docid: M:Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing.GetAllKeyIds
    /**
    
            Return all of the key ids.
            

    - Returns: All of the key ids.

    */
    open func GetAllKeyIds() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing_System_Collections_Generic_IEnumerable_string___GetAllKeyIds_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_CurrentKeyId()
// docid: M:Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing.get_CurrentKeyId
    open func get_CurrentKeyId() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing_String__get_CurrentKeyId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Item(System.String)
// docid: M:Microsoft.AspNetCore.Identity.ILookupProtectorKeyRing.get_Item(System.String)
//BEGIN method_is_override
//matches_1
//matches :
    open func get_Item(keyId : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing_String__get_Item_0__1__String(&__thrown, self.get_handle(), keyId?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ILookupProtectorKeyRing


// type: Microsoft.AspNetCore.Identity.IPasswordHasher`1
    /**
    
            Provides an abstraction for hashing passwords.
            

    */
open class IPasswordHasher_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IPasswordHasher_1
{
    public typealias TUser_IPasswordHasher_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IPasswordHasher_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.String HashPassword(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.IPasswordHasher`1.HashPassword(`0,System.String)
    /**
    
            Returns a hashed representation of the supplied  for the specified .
            

    - Parameter user: The user whose password is to be hashed.
    - Parameter password: The password to hash.
    - Returns: A hashed representation of the supplied  for the specified .

    */
    open func HashPassword(user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IPasswordHasher_1_String__HashPassword_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.PasswordVerificationResult VerifyHashedPassword(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.IPasswordHasher`1.VerifyHashedPassword(`0,System.String,System.String)
    /**
    
            Returns a  indicating the result of a password hash comparison.
            

    - Parameter user: The user whose password should be verified.
    - Parameter hashedPassword: The hash value for a user's stored password.
    - Parameter providedPassword: The password supplied for comparison.
    - Returns: A  indicating the result of a password hash comparison.

    */
    open func VerifyHashedPassword(user : TUser, hashedPassword : Optional<dotnet.System.String>, providedPassword : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IPasswordHasher_1_PasswordVerificationResult__VerifyHashedPassword_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), hashedPassword?.get_handle() ?? nil, providedPassword?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult(val: __return);
        }
    }
} // IPasswordHasher_1


// type: Microsoft.AspNetCore.Identity.IPasswordValidator`1
    /**
    
            Provides an abstraction for validating passwords.
            

    */
open class IPasswordValidator_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IPasswordValidator_1
{
    public typealias TUser_IPasswordValidator_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IPasswordValidator_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.IPasswordValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0,System.String)
    /**
    
            Validates a password as an asynchronous operation.
            

    - Parameter manager: The  to retrieve the  properties from.
    - Parameter user: The user whose password should be validated.
    - Parameter password: The password supplied for validation
    - Returns: The task object representing the asynchronous operation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IPasswordValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__3__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IPasswordValidator_1


// type: Microsoft.AspNetCore.Identity.IPersonalDataProtector
    /**
    
            Provides an abstraction used for personal data encryption.
            

    */
open class IPersonalDataProtector
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IPersonalDataProtector
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IPersonalDataProtector_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.String Protect(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IPersonalDataProtector.Protect(System.String)
    /**
    
            Protect the data.
            

    - Parameter data: The data to protect.
    - Returns: The protected data.

    */
    open func Protect(data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IPersonalDataProtector_String__Protect_0__1__String(&__thrown, self.get_handle(), data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String Unprotect(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IPersonalDataProtector.Unprotect(System.String)
    /**
    
            Unprotect the data.
            

    - Parameter data: 
    - Returns: The unprotected data.

    */
    open func Unprotect(data : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IPersonalDataProtector_String__Unprotect_0__1__String(&__thrown, self.get_handle(), data?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IPersonalDataProtector


// type: Microsoft.AspNetCore.Identity.IProtectedUserStore`1
    /**
    
            Marker interface used to signal that the store supports the  flag.
            

    */
open class IProtectedUserStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IProtectedUserStore_1
{
    public typealias TUser_IProtectedUserStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IProtectedUserStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

} // IProtectedUserStore_1


// type: Microsoft.AspNetCore.Identity.IQueryableRoleStore`1
    /**
    
            Provides an abstraction for querying roles in a Role store.
            

    */
open class IQueryableRoleStore_1<TRole : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IQueryableRoleStore_1
{
    public typealias TRole_IQueryableRoleStore_1 = TRole;
    public typealias TRole_IRoleStore_1 = TRole;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IQueryableRoleStore_1_get_type_handle(TRole.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Linq.IQueryable<TRole> get_Roles()
// docid: M:Microsoft.AspNetCore.Identity.IQueryableRoleStore`1.get_Roles
    open func get_Roles() throws -> Optional<dotnet.System.Linq.IQueryable_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IQueryableRoleStore_1_System_Linq_IQueryable_TRole___get_Roles_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IQueryableRoleStore_1


// type: Microsoft.AspNetCore.Identity.IQueryableUserStore`1
    /**
    
            Provides an abstraction for querying users in a User store.
            

    */
open class IQueryableUserStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IQueryableUserStore_1
{
    public typealias TUser_IQueryableUserStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IQueryableUserStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Linq.IQueryable<TUser> get_Users()
// docid: M:Microsoft.AspNetCore.Identity.IQueryableUserStore`1.get_Users
    open func get_Users() throws -> Optional<dotnet.System.Linq.IQueryable_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IQueryableUserStore_1_System_Linq_IQueryable_TUser___get_Users_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IQueryableUserStore_1


// type: Microsoft.AspNetCore.Identity.IRoleClaimStore`1
    /**
    
            Provides an abstraction for a store of role specific claims.
            

    */
open class IRoleClaimStore_1<TRole : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IRoleClaimStore_1
{
    public typealias TRole_IRoleClaimStore_1 = TRole;
    public typealias TRole_IRoleStore_1 = TRole;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IRoleClaimStore_1_get_type_handle(TRole.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleClaimStore`1.GetClaimsAsync(`0,System.Threading.CancellationToken)
    /**
    
             Gets a list of s to be belonging to the specified  as an asynchronous operation.
            

    - Parameter role: The role whose claims to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of s.
            

    */
    open func GetClaimsAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleClaimStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddClaimAsync(TRole, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleClaimStore`1.AddClaimAsync(`0,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Add a new claim to a role as an asynchronous operation.
            

    - Parameter role: The role to add a claim to.
    - Parameter claim: The  to add.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AddClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleClaimStore_1_Task__AddClaimAsync_0__3__TRole_Claim_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveClaimAsync(TRole, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleClaimStore`1.RemoveClaimAsync(`0,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Remove a claim from a role as an asynchronous operation.
            

    - Parameter role: The role to remove the claim from.
    - Parameter claim: The  to remove.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func RemoveClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleClaimStore_1_Task__RemoveClaimAsync_0__3__TRole_Claim_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IRoleClaimStore_1


// type: Microsoft.AspNetCore.Identity.IRoleStore`1
    /**
    
            Provides an abstraction for a storage and management of roles.
            

    */
open class IRoleStore_1<TRole : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IRoleStore_1,
    System_IDisposable
{
    public typealias TRole_IRoleStore_1 = TRole;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IRoleStore_1_get_type_handle(TRole.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.CreateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Creates a new role in a store as an asynchronous operation.
            

    - Parameter role: The role to create in the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func CreateAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.UpdateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Updates a role in a store as an asynchronous operation.
            

    - Parameter role: The role to update in the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func UpdateAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.DeleteAsync(`0,System.Threading.CancellationToken)
    /**
    
            Deletes a role from the store as an asynchronous operation.
            

    - Parameter role: The role to delete from the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func DeleteAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleIdAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.GetRoleIdAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the ID for a role from the store as an asynchronous operation.
            

    - Parameter role: The role whose ID should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the ID of the role.

    */
    open func GetRoleIdAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_string___GetRoleIdAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleNameAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.GetRoleNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the name of a role from the store as an asynchronous operation.
            

    - Parameter role: The role whose name should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the name of the role.

    */
    open func GetRoleNameAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_string___GetRoleNameAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetRoleNameAsync(TRole, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.SetRoleNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the name of a role in the store as an asynchronous operation.
            

    - Parameter role: The role whose name should be set.
    - Parameter roleName: The name of the role.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetRoleNameAsync(role : TRole, roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_Task__SetRoleNameAsync_0__3__TRole_String_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedRoleNameAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.GetNormalizedRoleNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get a role's normalized name as an asynchronous operation.
            

    - Parameter role: The role whose normalized name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the name of the role.

    */
    open func GetNormalizedRoleNameAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_string___GetNormalizedRoleNameAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedRoleNameAsync(TRole, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.SetNormalizedRoleNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Set a role's normalized name as an asynchronous operation.
            

    - Parameter role: The role whose normalized name should be set.
    - Parameter normalizedName: The normalized name to set
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetNormalizedRoleNameAsync(role : TRole, normalizedName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_Task__SetNormalizedRoleNameAsync_0__3__TRole_String_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), normalizedName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByIdAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.FindByIdAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds the role who has the specified ID as an asynchronous operation.
            

    - Parameter roleId: The role ID to look for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that result of the look up.

    */
    open func FindByIdAsync(roleId : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_TRole___FindByIdAsync_0__2__String_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), roleId?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByNameAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IRoleStore`1.FindByNameAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds the role who has the specified normalized name as an asynchronous operation.
            

    - Parameter normalizedRoleName: The normalized role name to look for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that result of the look up.

    */
    open func FindByNameAsync(normalizedRoleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleStore_1_System_Threading_Tasks_Task_TRole___FindByNameAsync_0__2__String_CancellationToken(TRole.get_type_handle(), &__thrown, self.get_handle(), normalizedRoleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IRoleStore_1


// type: Microsoft.AspNetCore.Identity.IRoleValidator`1
    /**
    
            Provides an abstraction for a validating a role.
            

    */
open class IRoleValidator_1<TRole : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IRoleValidator_1
{
    public typealias TRole_IRoleValidator_1 = TRole;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IRoleValidator_1_get_type_handle(TRole.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.RoleManager<TRole>, TRole)
// docid: M:Microsoft.AspNetCore.Identity.IRoleValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.RoleManager{`0},`0)
    /**
    
            Validates a role as an asynchronous operation.
            

    - Parameter manager: The  managing the role store.
    - Parameter role: The role to validate.
    - Returns: A  that represents the  of the asynchronous validation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>, role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IRoleValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__2__Microsoft_AspNetCore_Identity_RoleManager_TRole__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), nil, role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IRoleValidator_1


// type: Microsoft.AspNetCore.Identity.IUserAuthenticationTokenStore`1
    /**
    
            Provides an abstraction to store a user's authentication tokens.
            

    */
open class IUserAuthenticationTokenStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1
{
    public typealias TUser_IUserAuthenticationTokenStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetTokenAsync(TUser, System.String, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserAuthenticationTokenStore`1.SetTokenAsync(`0,System.String,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the token value for a particular user.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter value: The value of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1_Task__SetTokenAsync_0__5__TUser_String_String_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, value?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveTokenAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserAuthenticationTokenStore`1.RemoveTokenAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Deletes a token for a user.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1_Task__RemoveTokenAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetTokenAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserAuthenticationTokenStore`1.GetTokenAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Returns the token value.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func GetTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1_System_Threading_Tasks_Task_string___GetTokenAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserAuthenticationTokenStore_1


// type: Microsoft.AspNetCore.Identity.IUserAuthenticatorKeyStore`1
    /**
    
            Provides an abstraction for a store which stores info about user's authenticator.
            

    */
open class IUserAuthenticatorKeyStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserAuthenticatorKeyStore_1
{
    public typealias TUser_IUserAuthenticatorKeyStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserAuthenticatorKeyStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetAuthenticatorKeyAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserAuthenticatorKeyStore`1.SetAuthenticatorKeyAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the authenticator key for the specified .
            

    - Parameter user: The user whose authenticator key should be set.
    - Parameter key: The authenticator key to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetAuthenticatorKeyAsync(user : TUser, key : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserAuthenticatorKeyStore_1_Task__SetAuthenticatorKeyAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), key?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetAuthenticatorKeyAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserAuthenticatorKeyStore`1.GetAuthenticatorKeyAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the authenticator key for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the security stamp for the specified .

    */
    open func GetAuthenticatorKeyAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserAuthenticatorKeyStore_1_System_Threading_Tasks_Task_string___GetAuthenticatorKeyAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserAuthenticatorKeyStore_1


// type: Microsoft.AspNetCore.Identity.IUserClaimStore`1
    /**
    
            Provides an abstraction for a store of claims for a user.
            

    */
open class IUserClaimStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserClaimStore_1
{
    public typealias TUser_IUserClaimStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserClaimStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimStore`1.GetClaimsAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a list of s to be belonging to the specified  as an asynchronous operation.
            

    - Parameter user: The role whose claims to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of s.
            

    */
    open func GetClaimsAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimStore`1.AddClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim},System.Threading.CancellationToken)
    /**
    
            Add claims to a user as an asynchronous operation.
            

    - Parameter user: The user to add the claim to.
    - Parameter claims: The collection of s to add.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AddClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimStore_1_Task__AddClaimsAsync_0__3__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim__CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ReplaceClaimAsync(TUser, System.Security.Claims.Claim, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimStore`1.ReplaceClaimAsync(`0,System.Security.Claims.Claim,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Replaces the given  on the specified  with the 
            

    - Parameter user: The user to replace the claim on.
    - Parameter claim: The claim to replace.
    - Parameter newClaim: The new claim to replace the existing  with.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func ReplaceClaimAsync(user : TUser, claim : Optional<dotnet.System.Security.Claims.Claim>, newClaim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimStore_1_Task__ReplaceClaimAsync_0__4__TUser_Claim_Claim_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), claim?.get_handle() ?? nil, newClaim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimStore`1.RemoveClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim},System.Threading.CancellationToken)
    /**
    
            Removes the specified  from the given .
            

    - Parameter user: The user to remove the specified  from.
    - Parameter claims: A collection of s to remove.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func RemoveClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimStore_1_Task__RemoveClaimsAsync_0__3__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim__CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersForClaimAsync(System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimStore`1.GetUsersForClaimAsync(System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Returns a list of users who contain the specified .
            

    - Parameter claim: The claim to look for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of  who
            contain the specified claim.
            

    */
    open func GetUsersForClaimAsync(claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersForClaimAsync_0__2__Claim_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserClaimStore_1


// type: Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory`1
    /**
    
            Provides an abstraction for a factory to create a  from a user.
            

    */
open class IUserClaimsPrincipalFactory_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_1
{
    public typealias TUser_IUserClaimsPrincipalFactory_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<System.Security.Claims.ClaimsPrincipal> CreateAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory`1.CreateAsync(`0)
    /**
    
            Creates a  from an user asynchronously.
            

    - Parameter user: The user to create a  from.
    - Returns: The  that represents the asynchronous creation operation, containing the created .

    */
    open func CreateAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Security.Claims.ClaimsPrincipal>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_1_System_Threading_Tasks_Task_System_Security_Claims_ClaimsPrincipal___CreateAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserClaimsPrincipalFactory_1


// type: Microsoft.AspNetCore.Identity.IUserConfirmation`1
    /**
    
            Provides an abstraction for confirmation of user accounts.
            

    */
open class IUserConfirmation_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserConfirmation_1
{
    public typealias TUser_IUserConfirmation_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserConfirmation_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<bool> IsConfirmedAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserConfirmation`1.IsConfirmedAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Determines whether the specified  is confirmed.
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user.
    - Returns: Whether the user is confirmed.

    */
    open func IsConfirmedAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserConfirmation_1_System_Threading_Tasks_Task_bool___IsConfirmedAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserConfirmation_1


// type: Microsoft.AspNetCore.Identity.IUserEmailStore`1
    /**
    
            Provides an abstraction for the storage and management of user email addresses.
            

    */
open class IUserEmailStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserEmailStore_1
{
    public typealias TUser_IUserEmailStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserEmailStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetEmailAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.SetEmailAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the  address for a .
            

    - Parameter user: The user whose email should be set.
    - Parameter email: The email to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetEmailAsync(user : TUser, email : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_Task__SetEmailAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), email?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetEmailAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.GetEmailAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the email address for the specified .
            

    - Parameter user: The user whose email should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object containing the results of the asynchronous operation, the email address for the specified .

    */
    open func GetEmailAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_System_Threading_Tasks_Task_string___GetEmailAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetEmailConfirmedAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.GetEmailConfirmedAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a flag indicating whether the email address for the specified  has been verified, true if the email address is verified otherwise
            false.
            

    - Parameter user: The user whose email confirmation status should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous operation, a flag indicating whether the email address for the specified 
            has been confirmed or not.
            

    */
    open func GetEmailConfirmedAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_System_Threading_Tasks_Task_bool___GetEmailConfirmedAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetEmailConfirmedAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.SetEmailConfirmedAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets the flag indicating whether the specified 's email address has been confirmed or not.
            

    - Parameter user: The user whose email confirmation status should be set.
    - Parameter confirmed: A flag indicating if the email address has been confirmed, true if the address is confirmed otherwise false.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetEmailConfirmedAsync(user : TUser, confirmed : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_Task__SetEmailConfirmedAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(confirmed ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByEmailAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.FindByEmailAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Gets the user, if any, associated with the specified, normalized email address.
            

    - Parameter normalizedEmail: The normalized email address to return the user for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
            

    */
    open func FindByEmailAsync(normalizedEmail : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_System_Threading_Tasks_Task_TUser___FindByEmailAsync_0__2__String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), normalizedEmail?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedEmailAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.GetNormalizedEmailAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns the normalized email for the specified .
            

    - Parameter user: The user whose email address to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous lookup operation, the normalized email address if any associated with the specified user.
            

    */
    open func GetNormalizedEmailAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_System_Threading_Tasks_Task_string___GetNormalizedEmailAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedEmailAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserEmailStore`1.SetNormalizedEmailAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the normalized email for the specified .
            

    - Parameter user: The user whose email address to set.
    - Parameter normalizedEmail: The normalized email to set for the specified .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetNormalizedEmailAsync(user : TUser, normalizedEmail : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserEmailStore_1_Task__SetNormalizedEmailAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedEmail?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserEmailStore_1


// type: Microsoft.AspNetCore.Identity.IUserLockoutStore`1
    /**
    
            Provides an abstraction for a storing information which can be used to implement account lockout,
            including access failures and lockout status
            

    */
open class IUserLockoutStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserLockoutStore_1
{
    public typealias TUser_IUserLockoutStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserLockoutStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetLockoutEndDateAsync(TUser, System.Nullable<System.DateTimeOffset>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.SetLockoutEndDateAsync(`0,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)
    /**
    
            Locks out a user until the specified end date has passed. Setting a end date in the past immediately unlocks a user.
            

    - Parameter user: The user whose lockout date should be set.
    - Parameter lockoutEnd: The  after which the 's lockout should end.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetLockoutEndDateAsync(user : TUser, lockoutEnd : Optional<dotnet.System.DateTimeOffset>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_Task__SetLockoutEndDateAsync_0__3__TUser_System_Nullable_System_DateTimeOffset__CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (lockoutEnd != nil) ? lockoutEnd!.get_handle() : nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> IncrementAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.IncrementAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Records that a failed access has occurred, incrementing the failed access count.
            

    - Parameter user: The user whose cancellation count should be incremented.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the incremented failed access count.

    */
    open func IncrementAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_System_Threading_Tasks_Task_i32___IncrementAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ResetAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.ResetAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Resets a user's failed access count.
            

    - Parameter user: The user whose failed access count should be reset.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func ResetAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_Task__ResetAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> GetAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.GetAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves the current failed access count for the specified .
            

    - Parameter user: The user whose failed access count should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the failed access count.

    */
    open func GetAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_System_Threading_Tasks_Task_i32___GetAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetLockoutEnabledAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.GetLockoutEnabledAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves a flag indicating whether user lockout can enabled for the specified user.
            

    - Parameter user: The user whose ability to be locked out should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, true if a user can be locked out, otherwise false.
            

    */
    open func GetLockoutEnabledAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_System_Threading_Tasks_Task_bool___GetLockoutEnabledAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetLockoutEnabledAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLockoutStore`1.SetLockoutEnabledAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Set the flag indicating if the specified  can be locked out.
            

    - Parameter user: The user whose ability to be locked out should be set.
    - Parameter enabled: A flag indicating if lock out can be enabled for the specified .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetLockoutEnabledAsync(user : TUser, enabled : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLockoutStore_1_Task__SetLockoutEnabledAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserLockoutStore_1


// type: Microsoft.AspNetCore.Identity.IUserLoginStore`1
    /**
    
            Provides an abstraction for storing information that maps external login information provided
            by Microsoft Account, Facebook etc. to a user account.
            

    */
open class IUserLoginStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserLoginStore_1
{
    public typealias TUser_IUserLoginStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserLoginStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task AddLoginAsync(TUser, Microsoft.AspNetCore.Identity.UserLoginInfo, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLoginStore`1.AddLoginAsync(`0,Microsoft.AspNetCore.Identity.UserLoginInfo,System.Threading.CancellationToken)
    /**
    
            Adds an external  to the specified .
            

    - Parameter user: The user to add the login to.
    - Parameter login: The external  to add to the specified .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddLoginAsync(user : TUser, login : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLoginStore_1_Task__AddLoginAsync_0__3__TUser_UserLoginInfo_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), login?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveLoginAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLoginStore`1.RemoveLoginAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Attempts to remove the provided login information from the specified .
            and returns a flag indicating whether the removal succeed or not.
            

    - Parameter user: The user to remove the login information from.
    - Parameter loginProvider: The login provide whose information should be removed.
    - Parameter providerKey: The key given by the external login provider for the specified user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveLoginAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLoginStore_1_Task__RemoveLoginAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.UserLoginInfo>> GetLoginsAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLoginStore`1.GetLoginsAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves the associated logins for the specified .
            

    - Parameter user: The user whose associated logins to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  for the asynchronous operation, containing a list of  for the specified , if any.
            

    */
    open func GetLoginsAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLoginStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_UserLoginInfo____GetLoginsAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByLoginAsync(System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserLoginStore`1.FindByLoginAsync(System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Retrieves the user associated with the specified login provider and login provider key.
            

    - Parameter loginProvider: The login provider who provided the .
    - Parameter providerKey: The key provided by the  to identify a user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
            

    */
    open func FindByLoginAsync(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserLoginStore_1_System_Threading_Tasks_Task_TUser___FindByLoginAsync_0__3__String_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserLoginStore_1


// type: Microsoft.AspNetCore.Identity.IUserPasswordStore`1
    /**
    
            Provides an abstraction for a store containing users' password hashes.
            

    */
open class IUserPasswordStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserPasswordStore_1
{
    public typealias TUser_IUserPasswordStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserPasswordStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetPasswordHashAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPasswordStore`1.SetPasswordHashAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the password hash for the specified .
            

    - Parameter user: The user whose password hash to set.
    - Parameter passwordHash: The password hash to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPasswordHashAsync(user : TUser, passwordHash : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPasswordStore_1_Task__SetPasswordHashAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), passwordHash?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetPasswordHashAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPasswordStore`1.GetPasswordHashAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the password hash for the specified .
            

    - Parameter user: The user whose password hash to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, returning the password hash for the specified .

    */
    open func GetPasswordHashAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPasswordStore_1_System_Threading_Tasks_Task_string___GetPasswordHashAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> HasPasswordAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPasswordStore`1.HasPasswordAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a flag indicating whether the specified  has a password.
            

    - Parameter user: The user to return a flag for, indicating whether they have a password or not.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the specified  has a password
            otherwise false.
            

    */
    open func HasPasswordAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPasswordStore_1_System_Threading_Tasks_Task_bool___HasPasswordAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserPasswordStore_1


// type: Microsoft.AspNetCore.Identity.IUserPhoneNumberStore`1
    /**
    
            Provides an abstraction for a store containing users' telephone numbers.
            

    */
open class IUserPhoneNumberStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1
{
    public typealias TUser_IUserPhoneNumberStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetPhoneNumberAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPhoneNumberStore`1.SetPhoneNumberAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the telephone number for the specified .
            

    - Parameter user: The user whose telephone number should be set.
    - Parameter phoneNumber: The telephone number to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPhoneNumberAsync(user : TUser, phoneNumber : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1_Task__SetPhoneNumberAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), phoneNumber?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetPhoneNumberAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPhoneNumberStore`1.GetPhoneNumberAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the telephone number, if any, for the specified .
            

    - Parameter user: The user whose telephone number should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the user's telephone number, if any.

    */
    open func GetPhoneNumberAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1_System_Threading_Tasks_Task_string___GetPhoneNumberAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetPhoneNumberConfirmedAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPhoneNumberStore`1.GetPhoneNumberConfirmedAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a flag indicating whether the specified 's telephone number has been confirmed.
            

    - Parameter user: The user to return a flag for, indicating whether their telephone number is confirmed.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the specified  has a confirmed
            telephone number otherwise false.
            

    */
    open func GetPhoneNumberConfirmedAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1_System_Threading_Tasks_Task_bool___GetPhoneNumberConfirmedAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetPhoneNumberConfirmedAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserPhoneNumberStore`1.SetPhoneNumberConfirmedAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets a flag indicating if the specified 's phone number has been confirmed.
            

    - Parameter user: The user whose telephone number confirmation status should be set.
    - Parameter confirmed: A flag indicating whether the user's telephone number has been confirmed.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPhoneNumberConfirmedAsync(user : TUser, confirmed : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1_Task__SetPhoneNumberConfirmedAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(confirmed ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserPhoneNumberStore_1


// type: Microsoft.AspNetCore.Identity.IUserRoleStore`1
    /**
    
            Provides an abstraction for a store which maps users to roles.
            

    */
open class IUserRoleStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserRoleStore_1
{
    public typealias TUser_IUserRoleStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserRoleStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task AddToRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserRoleStore`1.AddToRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Add the specified  to the named role.
            

    - Parameter user: The user to add to the named role.
    - Parameter roleName: The name of the role to add the user to.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddToRoleAsync(user : TUser, roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserRoleStore_1_Task__AddToRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveFromRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserRoleStore`1.RemoveFromRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Remove the specified  from the named role.
            

    - Parameter user: The user to remove the named role from.
    - Parameter roleName: The name of the role to remove.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveFromRoleAsync(user : TUser, roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserRoleStore_1_Task__RemoveFromRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.String>> GetRolesAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserRoleStore`1.GetRolesAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a list of role names the specified  belongs to.
            

    - Parameter user: The user whose role names to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing a list of role names.

    */
    open func GetRolesAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserRoleStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_string____GetRolesAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsInRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserRoleStore`1.IsInRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Returns a flag indicating whether the specified  is a member of the given named role.
            

    - Parameter user: The user whose role membership should be checked.
    - Parameter roleName: The name of the role to be checked.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing a flag indicating whether the specified  is
            a member of the named role.
            

    */
    open func IsInRoleAsync(user : TUser, roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserRoleStore_1_System_Threading_Tasks_Task_bool___IsInRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersInRoleAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserRoleStore`1.GetUsersInRoleAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Returns a list of Users who are members of the named role.
            

    - Parameter roleName: The name of the role whose membership should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing a list of users who are in the named role.
            

    */
    open func GetUsersInRoleAsync(roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserRoleStore_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersInRoleAsync_0__2__String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserRoleStore_1


// type: Microsoft.AspNetCore.Identity.IUserSecurityStampStore`1
    /**
    
            Provides an abstraction for a store which stores a user's security stamp.
            

    */
open class IUserSecurityStampStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserSecurityStampStore_1
{
    public typealias TUser_IUserSecurityStampStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserSecurityStampStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetSecurityStampAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserSecurityStampStore`1.SetSecurityStampAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the provided security  for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter stamp: The security stamp to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetSecurityStampAsync(user : TUser, stamp : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserSecurityStampStore_1_Task__SetSecurityStampAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), stamp?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetSecurityStampAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserSecurityStampStore`1.GetSecurityStampAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the security stamp for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the security stamp for the specified .

    */
    open func GetSecurityStampAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserSecurityStampStore_1_System_Threading_Tasks_Task_string___GetSecurityStampAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserSecurityStampStore_1


// type: Microsoft.AspNetCore.Identity.IUserStore`1
    /**
    
            Provides an abstraction for a store which manages user accounts.
            

    */
open class IUserStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserStore_1,
    System_IDisposable
{
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<System.String> GetUserIdAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.GetUserIdAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the user identifier for the specified .
            

    - Parameter user: The user whose identifier should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the identifier for the specified .

    */
    open func GetUserIdAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_string___GetUserIdAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserNameAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.GetUserNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the user name for the specified .
            

    - Parameter user: The user whose name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the name for the specified .

    */
    open func GetUserNameAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_string___GetUserNameAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetUserNameAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.SetUserNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the given  for the specified .
            

    - Parameter user: The user whose name should be set.
    - Parameter userName: The user name to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetUserNameAsync(user : TUser, userName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_Task__SetUserNameAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), userName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedUserNameAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.GetNormalizedUserNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the normalized user name for the specified .
            

    - Parameter user: The user whose normalized name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the normalized user name for the specified .

    */
    open func GetNormalizedUserNameAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_string___GetNormalizedUserNameAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedUserNameAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.SetNormalizedUserNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the given normalized name for the specified .
            

    - Parameter user: The user whose name should be set.
    - Parameter normalizedName: The normalized name to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetNormalizedUserNameAsync(user : TUser, normalizedName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_Task__SetNormalizedUserNameAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.CreateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Creates the specified  in the user store.
            

    - Parameter user: The user to create.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the creation operation.

    */
    open func CreateAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.UpdateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Updates the specified  in the user store.
            

    - Parameter user: The user to update.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the update operation.

    */
    open func UpdateAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.DeleteAsync(`0,System.Threading.CancellationToken)
    /**
    
            Deletes the specified  from the user store.
            

    - Parameter user: The user to delete.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the delete operation.

    */
    open func DeleteAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByIdAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.FindByIdAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds and returns a user, if any, who has the specified .
            

    - Parameter userId: The user ID to search for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByIdAsync(userId : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_TUser___FindByIdAsync_0__2__String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), userId?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByNameAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserStore`1.FindByNameAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds and returns a user, if any, who has the specified normalized user name.
            

    - Parameter normalizedUserName: The normalized user name to search for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByNameAsync(normalizedUserName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserStore_1_System_Threading_Tasks_Task_TUser___FindByNameAsync_0__2__String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), normalizedUserName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserStore_1


// type: Microsoft.AspNetCore.Identity.IUserTwoFactorRecoveryCodeStore`1
    /**
    
            Provides an abstraction for a store which stores a user's recovery codes.
            

    */
open class IUserTwoFactorRecoveryCodeStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1
{
    public typealias TUser_IUserTwoFactorRecoveryCodeStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task ReplaceCodesAsync(TUser, System.Collections.Generic.IEnumerable<System.String>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorRecoveryCodeStore`1.ReplaceCodesAsync(`0,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)
    /**
    
            Updates the recovery codes for the user while invalidating any previous recovery codes.
            

    - Parameter user: The user to store new recovery codes for.
    - Parameter recoveryCodes: The new recovery codes for the user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The new recovery codes for the user.

    */
    open func ReplaceCodesAsync(user : TUser, recoveryCodes : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1_Task__ReplaceCodesAsync_0__3__TUser_System_Collections_Generic_IEnumerable_string__CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (recoveryCodes?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> RedeemCodeAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorRecoveryCodeStore`1.RedeemCodeAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Returns whether a recovery code is valid for a user. Note: recovery codes are only valid
            once, and will be invalid after use.
            

    - Parameter user: The user who owns the recovery code.
    - Parameter code: The recovery code to use.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: True if the recovery code was found for the user.

    */
    open func RedeemCodeAsync(user : TUser, code : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1_System_Threading_Tasks_Task_bool___RedeemCodeAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), code?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> CountCodesAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorRecoveryCodeStore`1.CountCodesAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns how many recovery code are still valid for a user.
            

    - Parameter user: The user who owns the recovery code.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The number of valid recovery codes for the user..

    */
    open func CountCodesAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1_System_Threading_Tasks_Task_i32___CountCodesAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserTwoFactorRecoveryCodeStore_1


// type: Microsoft.AspNetCore.Identity.IUserTwoFactorStore`1
    /**
    
            Provides an abstraction to store a flag indicating whether a user has two factor authentication enabled.
            

    */
open class IUserTwoFactorStore_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserTwoFactorStore_1
{
    public typealias TUser_IUserTwoFactorStore_1 = TUser;
    public typealias TUser_IUserStore_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserTwoFactorStore_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task SetTwoFactorEnabledAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorStore`1.SetTwoFactorEnabledAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be set.
    - Parameter enabled: A flag indicating whether the specified  has two factor authentication enabled.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetTwoFactorEnabledAsync(user : TUser, enabled : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorStore_1_Task__SetTwoFactorEnabledAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetTwoFactorEnabledAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorStore`1.GetTwoFactorEnabledAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing a flag indicating whether the specified
             has two factor authentication enabled or not.
            

    */
    open func GetTwoFactorEnabledAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorStore_1_System_Threading_Tasks_Task_bool___GetTwoFactorEnabledAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserTwoFactorStore_1


// type: Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider`1
    /**
    
            Provides an abstraction for two-factor token generators.
            

    */
open class IUserTwoFactorTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1
{
    public typealias TUser_IUserTwoFactorTokenProvider_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<System.String> GenerateAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider`1.GenerateAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
             Generates a token for the specified  and .
             

    - Parameter purpose: The purpose the token will be used for.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be generated for.
    - Returns: 
             The  that represents the asynchronous operation, containing the token for the specified
              and .
             

    */
    open func GenerateAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1_System_Threading_Tasks_Task_string___GenerateAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> ValidateAsync(System.String, System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider`1.ValidateAsync(System.String,System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a flag indicating whether the specified  is valid for the given
             and .
            

    - Parameter purpose: The purpose the token will be used for.
    - Parameter token: The token to validate.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be validated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the a flag indicating the result
            of validating the  for the specified  and .
            The task will return true if the token is valid, otherwise false.
            

    */
    open func ValidateAsync(purpose : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1_System_Threading_Tasks_Task_bool___ValidateAsync_0__4__String_String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, token?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a flag indicating whether the token provider can generate a token suitable for two-factor authentication token for
            the specified .
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token could be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the a flag indicating if a two
            factor token could be generated by this provider for the specified .
            The task will return true if a two-factor authentication token could be generated, otherwise false.
            

    */
    open func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserTwoFactorTokenProvider_1


// type: Microsoft.AspNetCore.Identity.IUserValidator`1
    /**
    
            Provides an abstraction for user validation.
            

    */
open class IUserValidator_1<TUser : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_IUserValidator_1
{
    public typealias TUser_IUserValidator_1 = TUser;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IUserValidator_1_get_type_handle(TUser.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.IUserValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Validates the specified  as an asynchronous operation.
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user to validate.
    - Returns: The  that represents the asynchronous operation, containing the  of the validation operation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IUserValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IUserValidator_1


// type: Microsoft.AspNetCore.Identity.IdentityBuilder
    /**
    
            Helper functions for configuring identity services.
            

    */
open class IdentityBuilder
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Type, Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.#ctor(System.Type,Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Creates a new instance of .
            

    - Parameter user: The  to use for the users.
    - Parameter services: The  to attach to.
    */
    public init(user : Optional<dotnet.System.Type_>, services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityBuilder_ctor_0__2__Type_IServiceCollection(&__thrown, user?.get_handle() ?? nil, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Type, System.Type, Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.#ctor(System.Type,System.Type,Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Creates a new instance of .
            

    - Parameter user: The  to use for the users.
    - Parameter role: The  to use for the roles.
    - Parameter services: The  to attach to.
    */
    public init(user : Optional<dotnet.System.Type_>, role : Optional<dotnet.System.Type_>, services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityBuilder_ctor_0__3__Type_Type_IServiceCollection(&__thrown, user?.get_handle() ?? nil, role?.get_handle() ?? nil, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddUserValidator<TValidator>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddClaimsPrincipalFactory<TFactory>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddErrorDescriber<TDescriber>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddPasswordValidator<TValidator>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddUserStore<TStore>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddTokenProvider<TProvider>(System.String)
    // Microsoft.AspNetCore.Identity.IdentityBuilder AddTokenProvider(System.String, System.Type)
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.AddTokenProvider(System.String,System.Type)
    /**
    
            Adds a token provider for the .
            

    - Parameter providerName: The name of the provider to add.
    - Parameter provider: The type of the  to add.
    - Returns: The current  instance.

    */
    open func AddTokenProvider(providerName : Optional<dotnet.System.String>, provider : Optional<dotnet.System.Type_>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilder_IdentityBuilder__AddTokenProvider_0__2__String_Type(&__thrown, self.get_handle(), providerName?.get_handle() ?? nil, provider?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddUserManager<TUserManager>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddRoles<TRole>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddRoleValidator<TRole>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddPersonalDataProtection<TProtector, TKeyRing>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddRoleStore<TStore>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddRoleManager<TRoleManager>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddUserConfirmation<TUserConfirmation>()
    // [IsSpecialName] System.Type get_UserType()
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.get_UserType
    open func get_UserType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilder_Type__get_UserType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Type get_RoleType()
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.get_RoleType
    open func get_RoleType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilder_Type__get_RoleType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.IServiceCollection get_Services()
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilder.get_Services
    open func get_Services() throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilder_IServiceCollection__get_Services_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  used for roles.
            

    */
    open var RoleType : Optional<dotnet.System.Type_> {
        get {
            return try! get_RoleType();
        }
    }
    /**
    
            Gets the  services are attached to.
            

    */
    open var Services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        get {
            return try! get_Services();
        }
    }
    /**
    
            Gets the  used for users.
            

    */
    open var UserType : Optional<dotnet.System.Type_> {
        get {
            return try! get_UserType();
        }
    }
} // IdentityBuilder


// type: Microsoft.AspNetCore.Identity.IdentityError
    /**
    
            Encapsulates an error from the identity subsystem.
            

    */
open class IdentityError
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityError_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityError.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityError_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Code()
// docid: M:Microsoft.AspNetCore.Identity.IdentityError.get_Code
    open func get_Code() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityError_String__get_Code_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Code(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityError.set_Code(System.String)
    open func set_Code(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityError_void__set_Code_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Description()
// docid: M:Microsoft.AspNetCore.Identity.IdentityError.get_Description
    open func get_Description() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityError_String__get_Description_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Description(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityError.set_Description(System.String)
    open func set_Description(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityError_void__set_Description_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the code for this error.
            

    */
    open var Code : Optional<dotnet.System.String> {
        get {
            return try! get_Code();
        }
        set(v) {
            return try! set_Code(value: v!);
        }
    }
    /**
    
            Gets or sets the description for this error.
            

    */
    open var Description : Optional<dotnet.System.String> {
        get {
            return try! get_Description();
        }
        set(v) {
            return try! set_Description(value: v!);
        }
    }
} // IdentityError


// type: Microsoft.AspNetCore.Identity.IdentityErrorDescriber
    /**
    
            Service to enable localization for application facing identity errors.
            

    */
open class IdentityErrorDescriber
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityErrorDescriber_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError DefaultError()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.DefaultError
    /**
    
            Returns the default .
            

    - Returns: The default .

    */
    open func DefaultError() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__DefaultError_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError ConcurrencyFailure()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.ConcurrencyFailure
    /**
    
            Returns an  indicating a concurrency failure.
            

    - Returns: An  indicating a concurrency failure.

    */
    open func ConcurrencyFailure() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__ConcurrencyFailure_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordMismatch()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordMismatch
    /**
    
            Returns an  indicating a password mismatch.
            

    - Returns: An  indicating a password mismatch.

    */
    open func PasswordMismatch() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordMismatch_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError InvalidToken()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.InvalidToken
    /**
    
            Returns an  indicating an invalid token.
            

    - Returns: An  indicating an invalid token.

    */
    open func InvalidToken() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__InvalidToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError RecoveryCodeRedemptionFailed()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.RecoveryCodeRedemptionFailed
    /**
    
            Returns an  indicating a recovery code was not redeemed.
            

    - Returns: An  indicating a recovery code was not redeemed.

    */
    open func RecoveryCodeRedemptionFailed() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__RecoveryCodeRedemptionFailed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError LoginAlreadyAssociated()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.LoginAlreadyAssociated
    /**
    
            Returns an  indicating an external login is already associated with an account.
            

    - Returns: An  indicating an external login is already associated with an account.

    */
    open func LoginAlreadyAssociated() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__LoginAlreadyAssociated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError InvalidUserName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.InvalidUserName(System.String)
    /**
    
            Returns an  indicating the specified user  is invalid.
            

    - Parameter userName: The user name that is invalid.
    - Returns: An  indicating the specified user  is invalid.

    */
    open func InvalidUserName(userName : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__InvalidUserName_0__1__String(&__thrown, self.get_handle(), userName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError InvalidEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.InvalidEmail(System.String)
    /**
    
            Returns an  indicating the specified  is invalid.
            

    - Parameter email: The email that is invalid.
    - Returns: An  indicating the specified  is invalid.

    */
    open func InvalidEmail(email : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__InvalidEmail_0__1__String(&__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError DuplicateUserName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.DuplicateUserName(System.String)
    /**
    
            Returns an  indicating the specified  already exists.
            

    - Parameter userName: The user name that already exists.
    - Returns: An  indicating the specified  already exists.

    */
    open func DuplicateUserName(userName : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__DuplicateUserName_0__1__String(&__thrown, self.get_handle(), userName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError DuplicateEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.DuplicateEmail(System.String)
    /**
    
            Returns an  indicating the specified  is already associated with an account.
            

    - Parameter email: The email that is already associated with an account.
    - Returns: An  indicating the specified  is already associated with an account.

    */
    open func DuplicateEmail(email : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__DuplicateEmail_0__1__String(&__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError InvalidRoleName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.InvalidRoleName(System.String)
    /**
    
            Returns an  indicating the specified  name is invalid.
            

    - Parameter role: The invalid role.
    - Returns: An  indicating the specific role  name is invalid.

    */
    open func InvalidRoleName(role : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__InvalidRoleName_0__1__String(&__thrown, self.get_handle(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError DuplicateRoleName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.DuplicateRoleName(System.String)
    /**
    
            Returns an  indicating the specified  name already exists.
            

    - Parameter role: The duplicate role.
    - Returns: An  indicating the specific role  name already exists.

    */
    open func DuplicateRoleName(role : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__DuplicateRoleName_0__1__String(&__thrown, self.get_handle(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError UserAlreadyHasPassword()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.UserAlreadyHasPassword
    /**
    
            Returns an  indicating a user already has a password.
            

    - Returns: An  indicating a user already has a password.

    */
    open func UserAlreadyHasPassword() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__UserAlreadyHasPassword_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError UserLockoutNotEnabled()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.UserLockoutNotEnabled
    /**
    
            Returns an  indicating user lockout is not enabled.
            

    - Returns: An  indicating user lockout is not enabled.

    */
    open func UserLockoutNotEnabled() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__UserLockoutNotEnabled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError UserAlreadyInRole(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.UserAlreadyInRole(System.String)
    /**
    
            Returns an  indicating a user is already in the specified .
            

    - Parameter role: The duplicate role.
    - Returns: An  indicating a user is already in the specified .

    */
    open func UserAlreadyInRole(role : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__UserAlreadyInRole_0__1__String(&__thrown, self.get_handle(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError UserNotInRole(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.UserNotInRole(System.String)
    /**
    
            Returns an  indicating a user is not in the specified .
            

    - Parameter role: The duplicate role.
    - Returns: An  indicating a user is not in the specified .

    */
    open func UserNotInRole(role : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__UserNotInRole_0__1__String(&__thrown, self.get_handle(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordTooShort(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordTooShort(System.Int32)
    /**
    
            Returns an  indicating a password of the specified  does not meet the minimum length requirements.
            

    - Parameter length: The length that is not long enough.
    - Returns: An  indicating a password of the specified  does not meet the minimum length requirements.

    */
    open func PasswordTooShort(length : Swift.Int32) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordTooShort_0__1__i32(&__thrown, self.get_handle(), length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordRequiresUniqueChars(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordRequiresUniqueChars(System.Int32)
    /**
    
            Returns an  indicating a password does not meet the minimum number  of unique chars.
            

    - Parameter uniqueChars: The number of different chars that must be used.
    - Returns: An  indicating a password does not meet the minimum number  of unique chars.

    */
    open func PasswordRequiresUniqueChars(uniqueChars : Swift.Int32) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordRequiresUniqueChars_0__1__i32(&__thrown, self.get_handle(), uniqueChars);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordRequiresNonAlphanumeric()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordRequiresNonAlphanumeric
    /**
    
            Returns an  indicating a password entered does not contain a non-alphanumeric character, which is required by the password policy.
            

    - Returns: An  indicating a password entered does not contain a non-alphanumeric character.

    */
    open func PasswordRequiresNonAlphanumeric() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordRequiresNonAlphanumeric_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordRequiresDigit()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordRequiresDigit
    /**
    
            Returns an  indicating a password entered does not contain a numeric character, which is required by the password policy.
            

    - Returns: An  indicating a password entered does not contain a numeric character.

    */
    open func PasswordRequiresDigit() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordRequiresDigit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordRequiresLower()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordRequiresLower
    /**
    
            Returns an  indicating a password entered does not contain a lower case letter, which is required by the password policy.
            

    - Returns: An  indicating a password entered does not contain a lower case letter.

    */
    open func PasswordRequiresLower() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordRequiresLower_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityError PasswordRequiresUpper()
// docid: M:Microsoft.AspNetCore.Identity.IdentityErrorDescriber.PasswordRequiresUpper
    /**
    
            Returns an  indicating a password entered does not contain an upper case letter, which is required by the password policy.
            

    - Returns: An  indicating a password entered does not contain an upper case letter.

    */
    open func PasswordRequiresUpper() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityErrorDescriber_IdentityError__PasswordRequiresUpper_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityError(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IdentityErrorDescriber


// type: Microsoft.AspNetCore.Identity.IdentityOptions
    /**
    
            Represents all the options you can use to configure the identity system.
            

    */
open class IdentityOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.ClaimsIdentityOptions get_ClaimsIdentity()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_ClaimsIdentity
    open func get_ClaimsIdentity() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.ClaimsIdentityOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_ClaimsIdentityOptions__get_ClaimsIdentity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.ClaimsIdentityOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimsIdentity(Microsoft.AspNetCore.Identity.ClaimsIdentityOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_ClaimsIdentity(Microsoft.AspNetCore.Identity.ClaimsIdentityOptions)
    open func set_ClaimsIdentity(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ClaimsIdentityOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_ClaimsIdentity_0__1__ClaimsIdentityOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.UserOptions get_User()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_User
    open func get_User() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_UserOptions__get_User_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.UserOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_User(Microsoft.AspNetCore.Identity.UserOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_User(Microsoft.AspNetCore.Identity.UserOptions)
    open func set_User(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_User_0__1__UserOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.PasswordOptions get_Password()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_Password
    open func get_Password() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.PasswordOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_PasswordOptions__get_Password_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.PasswordOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Password(Microsoft.AspNetCore.Identity.PasswordOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_Password(Microsoft.AspNetCore.Identity.PasswordOptions)
    open func set_Password(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.PasswordOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_Password_0__1__PasswordOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.LockoutOptions get_Lockout()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_Lockout
    open func get_Lockout() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.LockoutOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_LockoutOptions__get_Lockout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.LockoutOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Lockout(Microsoft.AspNetCore.Identity.LockoutOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_Lockout(Microsoft.AspNetCore.Identity.LockoutOptions)
    open func set_Lockout(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.LockoutOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_Lockout_0__1__LockoutOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInOptions get_SignIn()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_SignIn
    open func get_SignIn() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_SignInOptions__get_SignIn_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SignIn(Microsoft.AspNetCore.Identity.SignInOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_SignIn(Microsoft.AspNetCore.Identity.SignInOptions)
    open func set_SignIn(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_SignIn_0__1__SignInOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.TokenOptions get_Tokens()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_Tokens
    open func get_Tokens() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.TokenOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_TokenOptions__get_Tokens_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.TokenOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Tokens(Microsoft.AspNetCore.Identity.TokenOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_Tokens(Microsoft.AspNetCore.Identity.TokenOptions)
    open func set_Tokens(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.TokenOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_Tokens_0__1__TokenOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.StoreOptions get_Stores()
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.get_Stores
    open func get_Stores() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.StoreOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityOptions_StoreOptions__get_Stores_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.StoreOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Stores(Microsoft.AspNetCore.Identity.StoreOptions)
// docid: M:Microsoft.AspNetCore.Identity.IdentityOptions.set_Stores(Microsoft.AspNetCore.Identity.StoreOptions)
    open func set_Stores(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.StoreOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityOptions_void__set_Stores_0__1__StoreOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var ClaimsIdentity : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ClaimsIdentityOptions> {
        get {
            return try! get_ClaimsIdentity();
        }
        set(v) {
            return try! set_ClaimsIdentity(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var Lockout : Optional<aspnetcore.Microsoft.AspNetCore.Identity.LockoutOptions> {
        get {
            return try! get_Lockout();
        }
        set(v) {
            return try! set_Lockout(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var Password : Optional<aspnetcore.Microsoft.AspNetCore.Identity.PasswordOptions> {
        get {
            return try! get_Password();
        }
        set(v) {
            return try! set_Password(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var SignIn : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInOptions> {
        get {
            return try! get_SignIn();
        }
        set(v) {
            return try! set_SignIn(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var Stores : Optional<aspnetcore.Microsoft.AspNetCore.Identity.StoreOptions> {
        get {
            return try! get_Stores();
        }
        set(v) {
            return try! set_Stores(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var Tokens : Optional<aspnetcore.Microsoft.AspNetCore.Identity.TokenOptions> {
        get {
            return try! get_Tokens();
        }
        set(v) {
            return try! set_Tokens(value: v!);
        }
    }
    /**
    
            Gets or sets the  for the identity system.
            

    */
    open var User : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserOptions> {
        get {
            return try! get_User();
        }
        set(v) {
            return try! set_User(value: v!);
        }
    }
} // IdentityOptions


// type: Microsoft.AspNetCore.Identity.IdentityResult
    /**
    
            Represents the result of an identity operation.
            

    */
open class IdentityResult
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityResult_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityResult_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityResult Failed(Microsoft.AspNetCore.Identity.IdentityError[])
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.Failed(Microsoft.AspNetCore.Identity.IdentityError[])
    /**
    
            Creates an  indicating a failed identity operation, with a list of  if applicable.
            

    - Parameter errors: An optional array of s which caused the operation to fail.
    - Returns: An  indicating a failed identity operation, with a list of  if applicable.

    */
    open class func Failed(errors : Optional<dotnet.System_Arr<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError>>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityResult_IdentityResult__Failed_0__1__IdentityErrorArray(&__thrown, (errors?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.ToString
    /**
    
            Converts the value of the current  object to its equivalent string representation.
            

    - Returns: A string representation of the current  object.

    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityResult_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Succeeded()
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.get_Succeeded
    open func get_Succeeded() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityResult_bool__get_Succeeded_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Succeeded(bool)
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.set_Succeeded(System.Boolean)
    open func set_Succeeded(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityResult_void__set_Succeeded_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IdentityError> get_Errors()
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.get_Errors
    open func get_Errors() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityResult_System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_IdentityError___get_Errors_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityResult get_Success()
// docid: M:Microsoft.AspNetCore.Identity.IdentityResult.get_Success
    open class func get_Success() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityResult_IdentityResult__get_Success_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            An  of  instances containing errors
            that occurred during the identity operation.
            

    */
    open var Errors : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityError>> {
        get {
            return try! get_Errors();
        }
    }
    /**
    
            Flag indicating whether if the operation succeeded or not.
            

    */
    open var Succeeded : Bool {
        get {
            return try! get_Succeeded();
        }
        set(v) {
            return try! set_Succeeded(value: v);
        }
    }
    /**
    
            Returns an  indicating a successful identity operation.
            

    */
    public static var Success : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult> {
        get {
            return try! get_Success();
        }
    }
} // IdentityResult


// type: Microsoft.AspNetCore.Identity.LockoutOptions
    /**
    
            Options for configuring user lockout.
            

    */
open class LockoutOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_LockoutOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_LockoutOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_AllowedForNewUsers()
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.get_AllowedForNewUsers
    open func get_AllowedForNewUsers() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_LockoutOptions_bool__get_AllowedForNewUsers_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowedForNewUsers(bool)
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.set_AllowedForNewUsers(System.Boolean)
    open func set_AllowedForNewUsers(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_LockoutOptions_void__set_AllowedForNewUsers_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxFailedAccessAttempts()
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.get_MaxFailedAccessAttempts
    open func get_MaxFailedAccessAttempts() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_LockoutOptions_i32__get_MaxFailedAccessAttempts_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxFailedAccessAttempts(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.set_MaxFailedAccessAttempts(System.Int32)
    open func set_MaxFailedAccessAttempts(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_LockoutOptions_void__set_MaxFailedAccessAttempts_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_DefaultLockoutTimeSpan()
// docid: M:Microsoft.AspNetCore.Identity.LockoutOptions.get_DefaultLockoutTimeSpan
    open func get_DefaultLockoutTimeSpan() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_LockoutOptions_TimeSpan__get_DefaultLockoutTimeSpan_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_DefaultLockoutTimeSpan(System.TimeSpan)
    /**
    
            Gets or sets a flag indicating whether a new user can be locked out. Defaults to true.
            

    */
    open var AllowedForNewUsers : Bool {
        get {
            return try! get_AllowedForNewUsers();
        }
        set(v) {
            return try! set_AllowedForNewUsers(value: v);
        }
    }
    /**
    
            Gets or sets the  a user is locked out for when a lockout occurs. Defaults to 5 minutes.
            

    */
    open var DefaultLockoutTimeSpan : dotnet.System.TimeSpan {
        get {
            return try! get_DefaultLockoutTimeSpan();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_DefaultLockoutTimeSpan(System.TimeSpan)
    }
    /**
    
            Gets or sets the number of failed access attempts allowed before a user is locked out,
            assuming lock out is enabled. Defaults to 5.
            

    */
    open var MaxFailedAccessAttempts : Swift.Int32 {
        get {
            return try! get_MaxFailedAccessAttempts();
        }
        set(v) {
            return try! set_MaxFailedAccessAttempts(value: v);
        }
    }
} // LockoutOptions


// type: Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode
    /**
    
            Specifies the format used for hashing passwords.
            

    */
public struct PasswordHasherCompatibilityMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordHasherCompatibilityMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode IdentityV2
    /**
    
            Indicates hashing passwords in a way that is compatible with ASP.NET Identity versions 1 and 2.
            

    */
    public static var IdentityV2 : aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode(val: Microsoft_AspNetCore_Identity_PasswordHasherCompatibilityMode_get_IdentityV2());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode IdentityV3
    /**
    
            Indicates hashing passwords in a way that is compatible with ASP.NET Identity version 3.
            

    */
    public static var IdentityV3 : aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode(val: Microsoft_AspNetCore_Identity_PasswordHasherCompatibilityMode_get_IdentityV3());
            return __return;
        }
    }
} // PasswordHasherCompatibilityMode


// type: Microsoft.AspNetCore.Identity.PasswordHasherOptions
    /**
    
            Specifies options for password hashing.
            

    */
open class PasswordHasherOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordHasherOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasherOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PasswordHasherOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode get_CompatibilityMode()
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasherOptions.get_CompatibilityMode
    open func get_CompatibilityMode() throws -> aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordHasherOptions_PasswordHasherCompatibilityMode__get_CompatibilityMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode(val: __return);
        }
    }
    // [IsSpecialName] void set_CompatibilityMode(Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode)
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasherOptions.set_CompatibilityMode(Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode)
    open func set_CompatibilityMode(value : aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordHasherOptions_void__set_CompatibilityMode_0__1__PasswordHasherCompatibilityMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_IterationCount()
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasherOptions.get_IterationCount
    open func get_IterationCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordHasherOptions_i32__get_IterationCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_IterationCount(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasherOptions.set_IterationCount(System.Int32)
    open func set_IterationCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordHasherOptions_void__set_IterationCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the compatibility mode used when hashing passwords. Defaults to 'ASP.NET Identity version 3'.
            

    */
    open var CompatibilityMode : aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherCompatibilityMode {
        get {
            return try! get_CompatibilityMode();
        }
        set(v) {
            return try! set_CompatibilityMode(value: v);
        }
    }
    /**
    
            Gets or sets the number of iterations used when hashing passwords using PBKDF2. Default is 10,000.
            

    */
    open var IterationCount : Swift.Int32 {
        get {
            return try! get_IterationCount();
        }
        set(v) {
            return try! set_IterationCount(value: v);
        }
    }
} // PasswordHasherOptions


// type: Microsoft.AspNetCore.Identity.PasswordHasher`1
    /**
    
            Implements the standard Identity password hashing.
            

    */
open class PasswordHasher_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordHasher_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.PasswordHasherOptions>)
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasher`1.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.PasswordHasherOptions})
    /**
    
            Creates a new instance of .
            

    - Parameter optionsAccessor: The options for this instance.
    */
    public init(optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.PasswordHasherOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PasswordHasher_1_ctor_0__1__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_PasswordHasherOptions_(TUser.get_type_handle(), &__thrown, (optionsAccessor?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String HashPassword(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasher`1.HashPassword(`0,System.String)
    /**
    
            Returns a hashed representation of the supplied  for the specified .
            

    - Parameter user: The user whose password is to be hashed.
    - Parameter password: The password to hash.
    - Returns: A hashed representation of the supplied  for the specified .

    */
    open func HashPassword(user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordHasher_1_String__HashPassword_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.PasswordVerificationResult VerifyHashedPassword(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.PasswordHasher`1.VerifyHashedPassword(`0,System.String,System.String)
    /**
    
            Returns a  indicating the result of a password hash comparison.
            

    - Parameter user: The user whose password should be verified.
    - Parameter hashedPassword: The hash value for a user's stored password.
    - Parameter providedPassword: The password supplied for comparison.
    - Returns: A  indicating the result of a password hash comparison.

    */
    open func VerifyHashedPassword(user : TUser, hashedPassword : Optional<dotnet.System.String>, providedPassword : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordHasher_1_PasswordVerificationResult__VerifyHashedPassword_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), hashedPassword?.get_handle() ?? nil, providedPassword?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult(val: __return);
        }
    }
} // PasswordHasher_1


// type: Microsoft.AspNetCore.Identity.PasswordOptions
    /**
    
            Specifies options for password requirements.
            

    */
open class PasswordOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PasswordOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_RequiredLength()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequiredLength
    open func get_RequiredLength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_i32__get_RequiredLength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_RequiredLength(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequiredLength(System.Int32)
    open func set_RequiredLength(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequiredLength_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_RequiredUniqueChars()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequiredUniqueChars
    open func get_RequiredUniqueChars() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_i32__get_RequiredUniqueChars_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_RequiredUniqueChars(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequiredUniqueChars(System.Int32)
    open func set_RequiredUniqueChars(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequiredUniqueChars_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireNonAlphanumeric()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequireNonAlphanumeric
    open func get_RequireNonAlphanumeric() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_bool__get_RequireNonAlphanumeric_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireNonAlphanumeric(bool)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequireNonAlphanumeric(System.Boolean)
    open func set_RequireNonAlphanumeric(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequireNonAlphanumeric_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireLowercase()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequireLowercase
    open func get_RequireLowercase() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_bool__get_RequireLowercase_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireLowercase(bool)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequireLowercase(System.Boolean)
    open func set_RequireLowercase(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequireLowercase_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireUppercase()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequireUppercase
    open func get_RequireUppercase() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_bool__get_RequireUppercase_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireUppercase(bool)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequireUppercase(System.Boolean)
    open func set_RequireUppercase(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequireUppercase_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireDigit()
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.get_RequireDigit
    open func get_RequireDigit() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordOptions_bool__get_RequireDigit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireDigit(bool)
// docid: M:Microsoft.AspNetCore.Identity.PasswordOptions.set_RequireDigit(System.Boolean)
    open func set_RequireDigit(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_PasswordOptions_void__set_RequireDigit_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets a flag indicating if passwords must contain a digit. Defaults to true.
            

    */
    open var RequireDigit : Bool {
        get {
            return try! get_RequireDigit();
        }
        set(v) {
            return try! set_RequireDigit(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating if passwords must contain a lower case ASCII character. Defaults to true.
            

    */
    open var RequireLowercase : Bool {
        get {
            return try! get_RequireLowercase();
        }
        set(v) {
            return try! set_RequireLowercase(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating if passwords must contain a non-alphanumeric character. Defaults to true.
            

    */
    open var RequireNonAlphanumeric : Bool {
        get {
            return try! get_RequireNonAlphanumeric();
        }
        set(v) {
            return try! set_RequireNonAlphanumeric(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating if passwords must contain a upper case ASCII character. Defaults to true.
            

    */
    open var RequireUppercase : Bool {
        get {
            return try! get_RequireUppercase();
        }
        set(v) {
            return try! set_RequireUppercase(value: v);
        }
    }
    /**
    
            Gets or sets the minimum length a password must be. Defaults to 6.
            

    */
    open var RequiredLength : Swift.Int32 {
        get {
            return try! get_RequiredLength();
        }
        set(v) {
            return try! set_RequiredLength(value: v);
        }
    }
    /**
    
            Gets or sets the minimum number of unique characters which a password must contain. Defaults to 1.
            

    */
    open var RequiredUniqueChars : Swift.Int32 {
        get {
            return try! get_RequiredUniqueChars();
        }
        set(v) {
            return try! set_RequiredUniqueChars(value: v);
        }
    }
} // PasswordOptions


// type: Microsoft.AspNetCore.Identity.PasswordValidator`1
    /**
    
            Provides the default password policy for Identity.
            

    */
open class PasswordValidator_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordValidator_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Constructions a new instance of .
            

    - Parameter errors: The  to retrieve error text from.
    */
    public init(errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PasswordValidator_1_ctor_0__1__IdentityErrorDescriber(TUser.get_type_handle(), &__thrown, errors?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0,System.String)
    /**
    
            Validates a password as an asynchronous operation.
            

    - Parameter manager: The  to retrieve the  properties from.
    - Parameter user: The user whose password should be validated.
    - Parameter password: The password supplied for validation
    - Returns: The task object representing the asynchronous operation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__3__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsDigit(System.Char)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.IsDigit(System.Char)
    /**
    
            Returns a flag indicating whether the supplied character is a digit.
            

    - Parameter c: The character to check if it is a digit.
    - Returns: True if the character is a digit, otherwise false.

    */
    open func IsDigit(c : dotnet.System.Char) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_bool__IsDigit_0__1__Char(TUser.get_type_handle(), &__thrown, self.get_handle(), c.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsLower(System.Char)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.IsLower(System.Char)
    /**
    
            Returns a flag indicating whether the supplied character is a lower case ASCII letter.
            

    - Parameter c: The character to check if it is a lower case ASCII letter.
    - Returns: True if the character is a lower case ASCII letter, otherwise false.

    */
    open func IsLower(c : dotnet.System.Char) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_bool__IsLower_0__1__Char(TUser.get_type_handle(), &__thrown, self.get_handle(), c.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsUpper(System.Char)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.IsUpper(System.Char)
    /**
    
            Returns a flag indicating whether the supplied character is an upper case ASCII letter.
            

    - Parameter c: The character to check if it is an upper case ASCII letter.
    - Returns: True if the character is an upper case ASCII letter, otherwise false.

    */
    open func IsUpper(c : dotnet.System.Char) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_bool__IsUpper_0__1__Char(TUser.get_type_handle(), &__thrown, self.get_handle(), c.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsLetterOrDigit(System.Char)
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.IsLetterOrDigit(System.Char)
    /**
    
            Returns a flag indicating whether the supplied character is an ASCII letter or digit.
            

    - Parameter c: The character to check if it is an ASCII letter or digit.
    - Returns: True if the character is an ASCII letter or digit, otherwise false.

    */
    open func IsLetterOrDigit(c : dotnet.System.Char) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_bool__IsLetterOrDigit_0__1__Char(TUser.get_type_handle(), &__thrown, self.get_handle(), c.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_Describer()
// docid: M:Microsoft.AspNetCore.Identity.PasswordValidator`1.get_Describer
    open func get_Describer() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PasswordValidator_1_IdentityErrorDescriber__get_Describer_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  used to supply error text.
            

    */
    open var Describer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_Describer();
        }
    }
} // PasswordValidator_1


// type: Microsoft.AspNetCore.Identity.PasswordVerificationResult
    /**
    
            Specifies the results for password verification.
            

    */
public struct PasswordVerificationResult : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PasswordVerificationResult_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Identity.PasswordVerificationResult Failed
    /**
    
            Indicates password verification failed.
            

    */
    public static var Failed : aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult(val: Microsoft_AspNetCore_Identity_PasswordVerificationResult_get_Failed());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Identity.PasswordVerificationResult Success
    /**
    
            Indicates password verification was successful.
            

    */
    public static var Success : aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult(val: Microsoft_AspNetCore_Identity_PasswordVerificationResult_get_Success());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Identity.PasswordVerificationResult SuccessRehashNeeded
    /**
    
            Indicates password verification was successful however the password was encoded using a deprecated algorithm
            and should be rehashed and updated.
            

    */
    public static var SuccessRehashNeeded : aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Identity.PasswordVerificationResult(val: Microsoft_AspNetCore_Identity_PasswordVerificationResult_get_SuccessRehashNeeded());
            return __return;
        }
    }
} // PasswordVerificationResult


// type: Microsoft.AspNetCore.Identity.PersonalDataAttribute
    /**
    
            Used to indicate that a something is considered personal data.
            

    */
open class PersonalDataAttribute
    :
    dotnet.System.Attribute
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PersonalDataAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.PersonalDataAttribute.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PersonalDataAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // PersonalDataAttribute


// type: Microsoft.AspNetCore.Identity.PhoneNumberTokenProvider`1
    /**
    
            Represents a token provider that generates tokens from a user's security stamp and
            sends them to the user via their phone number.
            

    */
open class PhoneNumberTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider_1<TUser>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_PhoneNumberTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.PhoneNumberTokenProvider`1.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_PhoneNumberTokenProvider_1_ctor_0__0(TUser.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.PhoneNumberTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a flag indicating whether the token provider can generate a token suitable for two-factor authentication token for
            the specified .
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token could be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the a flag indicating if a two
            factor token could be generated by this provider for the specified .
            The task will return true if a two-factor authentication token could be generated as the user has
            a telephone number, otherwise false.
            

    */
    open override func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PhoneNumberTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserModifierAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.PhoneNumberTokenProvider`1.GetUserModifierAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a constant, provider and user unique modifier used for entropy in generated tokens from user information.
            

    - Parameter purpose: The purpose the token will be generated for.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing a constant modifier for the specified
             and .
            

    */
    open override func GetUserModifierAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_PhoneNumberTokenProvider_1_System_Threading_Tasks_Task_string___GetUserModifierAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // PhoneNumberTokenProvider_1


// type: Microsoft.AspNetCore.Identity.ProtectedPersonalDataAttribute
    /**
    
            Used to indicate that a something is considered personal data and should be protected.
            

    */
open class ProtectedPersonalDataAttribute
    :
    aspnetcore.Microsoft.AspNetCore.Identity.PersonalDataAttribute
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ProtectedPersonalDataAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.ProtectedPersonalDataAttribute.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_ProtectedPersonalDataAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ProtectedPersonalDataAttribute


// type: Microsoft.AspNetCore.Identity.RoleManager`1
    /**
    
            Provides the APIs for managing roles in a persistence store.
            

    */
open class RoleManager_1<TRole : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_RoleManager_1_get_type_handle(TRole.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IRoleStore<TRole>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IRoleValidator<TRole>>, Microsoft.AspNetCore.Identity.ILookupNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.RoleManager<TRole>>)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.#ctor(Microsoft.AspNetCore.Identity.IRoleStore{`0},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IRoleValidator{`0}},Microsoft.AspNetCore.Identity.ILookupNormalizer,Microsoft.AspNetCore.Identity.IdentityErrorDescriber,Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.RoleManager{`0}})
    /**
    
            Constructs a new instance of .
            

    - Parameter store: The persistence store the manager will operate over.
    - Parameter roleValidators: A collection of validators for roles.
    - Parameter keyNormalizer: The normalizer to use when normalizing role names to keys.
    - Parameter errors: The  used to provider error messages.
    - Parameter logger: The logger used to log messages, warnings and errors.
    */
    public init(store : aspnetcore.Microsoft.AspNetCore.Identity.IRoleStore_1<TRole>, roleValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IRoleValidator_1<TRole>>>, keyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>, errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_RoleManager_1_ctor_0__5__Microsoft_AspNetCore_Identity_IRoleStore_TRole__System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IRoleValidator_TRole___ILookupNormalizer_IdentityErrorDescriber_Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_RoleManager_TRole__(TRole.get_type_handle(), &__thrown, nil, (roleValidators?.get_handle()), keyNormalizer?.get_handle() ?? nil, errors?.get_handle() ?? nil, (logger?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.CreateAsync(`0)
    /**
    
            Creates the specified  in the persistence store.
            

    - Parameter role: The role to create.
    - Returns: 
            The  that represents the asynchronous operation.
            

    */
    open func CreateAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task UpdateNormalizedRoleNameAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.UpdateNormalizedRoleNameAsync(`0)
    /**
    
            Updates the normalized name for the specified .
            

    - Parameter role: The role whose normalized name needs to be updated.
    - Returns: 
            The  that represents the asynchronous operation.
            

    */
    open func UpdateNormalizedRoleNameAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_Task__UpdateNormalizedRoleNameAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.UpdateAsync(`0)
    /**
    
            Updates the specified .
            

    - Parameter role: The role to updated.
    - Returns: 
            The  that represents the asynchronous operation, containing the  for the update.
            

    */
    open func UpdateAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.DeleteAsync(`0)
    /**
    
            Deletes the specified .
            

    - Parameter role: The role to delete.
    - Returns: 
            The  that represents the asynchronous operation, containing the  for the delete.
            

    */
    open func DeleteAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> RoleExistsAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.RoleExistsAsync(System.String)
    /**
    
            Gets a flag indicating whether the specified  exists.
            

    - Parameter roleName: The role name whose existence should be checked.
    - Returns: 
            The  that represents the asynchronous operation, containing true if the role name exists, otherwise false.
            

    */
    open func RoleExistsAsync(roleName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_bool___RoleExistsAsync_0__1__String(TRole.get_type_handle(), &__thrown, self.get_handle(), roleName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String NormalizeKey(System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.NormalizeKey(System.String)
    /**
    
            Gets a normalized representation of the specified .
            

    - Parameter key: The value to normalize.
    - Returns: A normalized representation of the specified .

    */
    open func NormalizeKey(key : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_String__NormalizeKey_0__1__String(TRole.get_type_handle(), &__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByIdAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.FindByIdAsync(System.String)
    /**
    
            Finds the role associated with the specified  if any.
            

    - Parameter roleId: The role ID whose role should be returned.
    - Returns: 
            The  that represents the asynchronous operation, containing the role
            associated with the specified 
            

    */
    open func FindByIdAsync(roleId : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_TRole___FindByIdAsync_0__1__String(TRole.get_type_handle(), &__thrown, self.get_handle(), roleId?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleNameAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.GetRoleNameAsync(`0)
    /**
    
            Gets the name of the specified .
            

    - Parameter role: The role whose name should be retrieved.
    - Returns: 
            The  that represents the asynchronous operation, containing the name of the
            specified .
            

    */
    open func GetRoleNameAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_string___GetRoleNameAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetRoleNameAsync(TRole, System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.SetRoleNameAsync(`0,System.String)
    /**
    
            Sets the name of the specified .
            

    - Parameter role: The role whose name should be set.
    - Parameter name: The name to set.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func SetRoleNameAsync(role : TRole, name : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetRoleNameAsync_0__2__TRole_String(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleIdAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.GetRoleIdAsync(`0)
    /**
    
            Gets the ID of the specified .
            

    - Parameter role: The role whose ID should be retrieved.
    - Returns: 
            The  that represents the asynchronous operation, containing the ID of the
            specified .
            

    */
    open func GetRoleIdAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_string___GetRoleIdAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByNameAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.FindByNameAsync(System.String)
    /**
    
            Finds the role associated with the specified  if any.
            

    - Parameter roleName: The name of the role to be returned.
    - Returns: 
            The  that represents the asynchronous operation, containing the role
            associated with the specified 
            

    */
    open func FindByNameAsync(roleName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_TRole___FindByNameAsync_0__1__String(TRole.get_type_handle(), &__thrown, self.get_handle(), roleName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddClaimAsync(TRole, System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.AddClaimAsync(`0,System.Security.Claims.Claim)
    /**
    
            Adds a claim to a role.
            

    - Parameter role: The role to add the claim to.
    - Parameter claim: The claim to add.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddClaimAsync_0__2__TRole_Claim(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveClaimAsync(TRole, System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.RemoveClaimAsync(`0,System.Security.Claims.Claim)
    /**
    
            Removes a claim from a role.
            

    - Parameter role: The role to remove the claim from.
    - Parameter claim: The claim to remove.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveClaimAsync_0__2__TRole_Claim(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.GetClaimsAsync(`0)
    /**
    
            Gets a list of claims associated with the specified .
            

    - Parameter role: The role whose claims should be returned.
    - Returns: 
            The  that represents the asynchronous operation, containing the list of s
            associated with the specified .
            

    */
    open func GetClaimsAsync(role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__1__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.Dispose
    /**
    
            Releases all resources used by the role manager.
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleManager_1_void__Dispose_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ILogger get_Logger()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_Logger
    open func get_Logger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_ILogger__get_Logger_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Logger(Microsoft.Extensions.Logging.ILogger)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.set_Logger(Microsoft.Extensions.Logging.ILogger)
    open func set_Logger(value : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleManager_1_void__set_Logger_0__1__ILogger(TRole.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.IRoleValidator<TRole>> get_RoleValidators()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_RoleValidators
    open func get_RoleValidators() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IRoleValidator_1<TRole>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IRoleValidator_TRole____get_RoleValidators_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_ErrorDescriber()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_ErrorDescriber
    open func get_ErrorDescriber() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_IdentityErrorDescriber__get_ErrorDescriber_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    open func set_ErrorDescriber(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleManager_1_void__set_ErrorDescriber_0__1__IdentityErrorDescriber(TRole.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.ILookupNormalizer get_KeyNormalizer()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_KeyNormalizer
    open func get_KeyNormalizer() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_ILookupNormalizer__get_KeyNormalizer_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_KeyNormalizer(Microsoft.AspNetCore.Identity.ILookupNormalizer)
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.set_KeyNormalizer(Microsoft.AspNetCore.Identity.ILookupNormalizer)
    open func set_KeyNormalizer(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleManager_1_void__set_KeyNormalizer_0__1__ILookupNormalizer(TRole.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Linq.IQueryable<TRole> get_Roles()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_Roles
    open func get_Roles() throws -> Optional<dotnet.System.Linq.IQueryable_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_System_Linq_IQueryable_TRole___get_Roles_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_SupportsQueryableRoles()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_SupportsQueryableRoles
    open func get_SupportsQueryableRoles() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_bool__get_SupportsQueryableRoles_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsRoleClaims()
// docid: M:Microsoft.AspNetCore.Identity.RoleManager`1.get_SupportsRoleClaims
    open func get_SupportsRoleClaims() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleManager_1_bool__get_SupportsRoleClaims_0__0(TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    
            Gets the  used to provider error messages.
            

    */
    open var ErrorDescriber : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_ErrorDescriber();
        }
        set(v) {
            return try! set_ErrorDescriber(value: v!);
        }
    }
    /**
    
            Gets the normalizer to use when normalizing role names to keys.
            

    */
    open var KeyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer> {
        get {
            return try! get_KeyNormalizer();
        }
        set(v) {
            return try! set_KeyNormalizer(value: v!);
        }
    }
    /**
    
            Gets the  used to log messages from the manager.
            

    */
    open var Logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        get {
            return try! get_Logger();
        }
        set(v) {
            return try! set_Logger(value: v!);
        }
    }
    /**
    
            Gets a list of validators for roles to call before persistence.
            

    */
    open var RoleValidators : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IRoleValidator_1<TRole>>> {
        get {
            return try! get_RoleValidators();
        }
    }
    /**
    
            Gets an IQueryable collection of Roles if the persistence store is an ,
            otherwise throws a .
            

    */
    open var Roles : Optional<dotnet.System.Linq.IQueryable_1<TRole>> {
        get {
            return try! get_Roles();
        }
    }
    /**
    
            Gets a flag indicating whether the underlying persistence store supports returning an  collection of roles.
            

    */
    open var SupportsQueryableRoles : Bool {
        get {
            return try! get_SupportsQueryableRoles();
        }
    }
    /**
    
            Gets a flag indicating whether the underlying persistence store supports s for roles.
            

    */
    open var SupportsRoleClaims : Bool {
        get {
            return try! get_SupportsRoleClaims();
        }
    }
} // RoleManager_1


// type: Microsoft.AspNetCore.Identity.RoleValidator`1
    /**
    
            Provides the default validation of roles.
            

    */
open class RoleValidator_1<TRole : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_RoleValidator_1_get_type_handle(TRole.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.RoleValidator`1.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Creates a new instance of .
            

    - Parameter errors: The  used to provider error messages.
    */
    public init(errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_RoleValidator_1_ctor_0__1__IdentityErrorDescriber(TRole.get_type_handle(), &__thrown, errors?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.RoleManager<TRole>, TRole)
// docid: M:Microsoft.AspNetCore.Identity.RoleValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.RoleManager{`0},`0)
    /**
    
            Validates a role as an asynchronous operation.
            

    - Parameter manager: The  managing the role store.
    - Parameter role: The role to validate.
    - Returns: A  that represents the  of the asynchronous validation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>, role : TRole) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__2__Microsoft_AspNetCore_Identity_RoleManager_TRole__TRole(TRole.get_type_handle(), &__thrown, self.get_handle(), nil, role.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // RoleValidator_1


// type: Microsoft.AspNetCore.Identity.SignInOptions
    /**
    
            Options for configuring sign in.
            

    */
open class SignInOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SignInOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SignInOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_RequireConfirmedEmail()
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.get_RequireConfirmedEmail
    open func get_RequireConfirmedEmail() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInOptions_bool__get_RequireConfirmedEmail_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireConfirmedEmail(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.set_RequireConfirmedEmail(System.Boolean)
    open func set_RequireConfirmedEmail(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInOptions_void__set_RequireConfirmedEmail_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireConfirmedPhoneNumber()
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.get_RequireConfirmedPhoneNumber
    open func get_RequireConfirmedPhoneNumber() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInOptions_bool__get_RequireConfirmedPhoneNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireConfirmedPhoneNumber(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.set_RequireConfirmedPhoneNumber(System.Boolean)
    open func set_RequireConfirmedPhoneNumber(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInOptions_void__set_RequireConfirmedPhoneNumber_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireConfirmedAccount()
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.get_RequireConfirmedAccount
    open func get_RequireConfirmedAccount() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInOptions_bool__get_RequireConfirmedAccount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireConfirmedAccount(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInOptions.set_RequireConfirmedAccount(System.Boolean)
    open func set_RequireConfirmedAccount(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInOptions_void__set_RequireConfirmedAccount_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets a flag indicating whether a confirmed  account is required to sign in. Defaults to false.
            

    */
    open var RequireConfirmedAccount : Bool {
        get {
            return try! get_RequireConfirmedAccount();
        }
        set(v) {
            return try! set_RequireConfirmedAccount(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating whether a confirmed email address is required to sign in. Defaults to false.
            

    */
    open var RequireConfirmedEmail : Bool {
        get {
            return try! get_RequireConfirmedEmail();
        }
        set(v) {
            return try! set_RequireConfirmedEmail(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating whether a confirmed telephone number is required to sign in. Defaults to false.
            

    */
    open var RequireConfirmedPhoneNumber : Bool {
        get {
            return try! get_RequireConfirmedPhoneNumber();
        }
        set(v) {
            return try! set_RequireConfirmedPhoneNumber(value: v);
        }
    }
} // SignInOptions


// type: Microsoft.AspNetCore.Identity.SignInResult
    /**
    
            Represents the result of a sign-in operation.
            

    */
open class SignInResult
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SignInResult_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SignInResult_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.ToString
    /**
    
            Converts the value of the current  object to its equivalent string representation.
            

    - Returns: A string representation of value of the current  object.

    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Succeeded()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_Succeeded
    open func get_Succeeded() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_bool__get_Succeeded_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_Succeeded(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.set_Succeeded(System.Boolean)
    open func set_Succeeded(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInResult_void__set_Succeeded_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsLockedOut()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_IsLockedOut
    open func get_IsLockedOut() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_bool__get_IsLockedOut_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_IsLockedOut(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.set_IsLockedOut(System.Boolean)
    open func set_IsLockedOut(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInResult_void__set_IsLockedOut_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsNotAllowed()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_IsNotAllowed
    open func get_IsNotAllowed() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_bool__get_IsNotAllowed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_IsNotAllowed(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.set_IsNotAllowed(System.Boolean)
    open func set_IsNotAllowed(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInResult_void__set_IsNotAllowed_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequiresTwoFactor()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_RequiresTwoFactor
    open func get_RequiresTwoFactor() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_bool__get_RequiresTwoFactor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequiresTwoFactor(bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.set_RequiresTwoFactor(System.Boolean)
    open func set_RequiresTwoFactor(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInResult_void__set_RequiresTwoFactor_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInResult get_Success()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_Success
    open class func get_Success() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_SignInResult__get_Success_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInResult get_Failed()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_Failed
    open class func get_Failed() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_SignInResult__get_Failed_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInResult get_LockedOut()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_LockedOut
    open class func get_LockedOut() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_SignInResult__get_LockedOut_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInResult get_NotAllowed()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_NotAllowed
    open class func get_NotAllowed() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_SignInResult__get_NotAllowed_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInResult get_TwoFactorRequired()
// docid: M:Microsoft.AspNetCore.Identity.SignInResult.get_TwoFactorRequired
    open class func get_TwoFactorRequired() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInResult_SignInResult__get_TwoFactorRequired_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Returns a  that represents a failed sign-in.
            

    */
    public static var Failed : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        get {
            return try! get_Failed();
        }
    }
    /**
    
            Returns a flag indication whether the user attempting to sign-in is locked out.
            

    */
    open var IsLockedOut : Bool {
        get {
            return try! get_IsLockedOut();
        }
        set(v) {
            return try! set_IsLockedOut(value: v);
        }
    }
    /**
    
            Returns a flag indication whether the user attempting to sign-in is not allowed to sign-in.
            

    */
    open var IsNotAllowed : Bool {
        get {
            return try! get_IsNotAllowed();
        }
        set(v) {
            return try! set_IsNotAllowed(value: v);
        }
    }
    /**
    
            Returns a  that represents a sign-in attempt that failed because
            the user was locked out.
            

    */
    public static var LockedOut : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        get {
            return try! get_LockedOut();
        }
    }
    /**
    
            Returns a  that represents a sign-in attempt that failed because
            the user is not allowed to sign-in.
            

    */
    public static var NotAllowed : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        get {
            return try! get_NotAllowed();
        }
    }
    /**
    
            Returns a flag indication whether the user attempting to sign-in requires two factor authentication.
            

    */
    open var RequiresTwoFactor : Bool {
        get {
            return try! get_RequiresTwoFactor();
        }
        set(v) {
            return try! set_RequiresTwoFactor(value: v);
        }
    }
    /**
    
            Returns a flag indication whether the sign-in was successful.
            

    */
    open var Succeeded : Bool {
        get {
            return try! get_Succeeded();
        }
        set(v) {
            return try! set_Succeeded(value: v);
        }
    }
    /**
    
            Returns a  that represents a successful sign-in.
            

    */
    public static var Success : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        get {
            return try! get_Success();
        }
    }
    /**
    
            Returns a  that represents a sign-in attempt that needs two-factor
            authentication.
            

    */
    public static var TwoFactorRequired : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult> {
        get {
            return try! get_TwoFactorRequired();
        }
    }
} // SignInResult


// type: Microsoft.AspNetCore.Identity.StoreOptions
    /**
    
            Used for store specific options
            

    */
open class StoreOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_StoreOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.StoreOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_StoreOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxLengthForKeys()
// docid: M:Microsoft.AspNetCore.Identity.StoreOptions.get_MaxLengthForKeys
    open func get_MaxLengthForKeys() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_StoreOptions_i32__get_MaxLengthForKeys_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxLengthForKeys(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.StoreOptions.set_MaxLengthForKeys(System.Int32)
    open func set_MaxLengthForKeys(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_StoreOptions_void__set_MaxLengthForKeys_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ProtectPersonalData()
// docid: M:Microsoft.AspNetCore.Identity.StoreOptions.get_ProtectPersonalData
    open func get_ProtectPersonalData() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_StoreOptions_bool__get_ProtectPersonalData_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ProtectPersonalData(bool)
// docid: M:Microsoft.AspNetCore.Identity.StoreOptions.set_ProtectPersonalData(System.Boolean)
    open func set_ProtectPersonalData(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_StoreOptions_void__set_ProtectPersonalData_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            If set to a positive number, the default OnModelCreating will use this value as the max length for any
            properties used as keys, i.e. UserId, LoginProvider, ProviderKey.
            

    */
    open var MaxLengthForKeys : Swift.Int32 {
        get {
            return try! get_MaxLengthForKeys();
        }
        set(v) {
            return try! set_MaxLengthForKeys(value: v);
        }
    }
    /**
    
            If set to true, the store must protect all personally identifying data for a user.
            This will be enforced by requiring the store to implement .
            

    */
    open var ProtectPersonalData : Bool {
        get {
            return try! get_ProtectPersonalData();
        }
        set(v) {
            return try! set_ProtectPersonalData(value: v);
        }
    }
} // StoreOptions


// type: Microsoft.AspNetCore.Identity.TokenOptions
    /**
    
            Options for user tokens.
            

    */
open class TokenOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_TokenOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.String DefaultProvider
    /**
    
            Default token provider name used by email confirmation, password reset, and change email.
            

    */
    open class var DefaultProvider : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_TokenOptions_get_DefaultProvider();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String DefaultEmailProvider
    /**
    
            Default token provider name used by the email provider.
            

    */
    open class var DefaultEmailProvider : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_TokenOptions_get_DefaultEmailProvider();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String DefaultPhoneProvider
    /**
    
            Default token provider name used by the phone provider.
            

    */
    open class var DefaultPhoneProvider : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_TokenOptions_get_DefaultPhoneProvider();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String DefaultAuthenticatorProvider
    /**
    
            Default token provider name used by the .
            

    */
    open class var DefaultAuthenticatorProvider : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_TokenOptions_get_DefaultAuthenticatorProvider();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_TokenOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Collections.Generic.Dictionary<System.String,Microsoft.AspNetCore.Identity.TokenProviderDescriptor> get_ProviderMap()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_ProviderMap
    open func get_ProviderMap() throws -> Optional<dotnet.System.Collections.Generic.Dictionary_2<dotnet.System.String,aspnetcore.Microsoft.AspNetCore.Identity.TokenProviderDescriptor>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_System_Collections_Generic_Dictionary_string_Microsoft_AspNetCore_Identity_TokenProviderDescriptor___get_ProviderMap_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.Dictionary_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderMap(System.Collections.Generic.Dictionary<System.String,Microsoft.AspNetCore.Identity.TokenProviderDescriptor>)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_ProviderMap(System.Collections.Generic.Dictionary{System.String,Microsoft.AspNetCore.Identity.TokenProviderDescriptor})
    open func set_ProviderMap(value : Optional<dotnet.System.Collections.Generic.Dictionary_2<dotnet.System.String,aspnetcore.Microsoft.AspNetCore.Identity.TokenProviderDescriptor>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_ProviderMap_0__1__System_Collections_Generic_Dictionary_string_Microsoft_AspNetCore_Identity_TokenProviderDescriptor_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_EmailConfirmationTokenProvider()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_EmailConfirmationTokenProvider
    open func get_EmailConfirmationTokenProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_EmailConfirmationTokenProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EmailConfirmationTokenProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_EmailConfirmationTokenProvider(System.String)
    open func set_EmailConfirmationTokenProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_EmailConfirmationTokenProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_PasswordResetTokenProvider()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_PasswordResetTokenProvider
    open func get_PasswordResetTokenProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_PasswordResetTokenProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_PasswordResetTokenProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_PasswordResetTokenProvider(System.String)
    open func set_PasswordResetTokenProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_PasswordResetTokenProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ChangeEmailTokenProvider()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_ChangeEmailTokenProvider
    open func get_ChangeEmailTokenProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_ChangeEmailTokenProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ChangeEmailTokenProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_ChangeEmailTokenProvider(System.String)
    open func set_ChangeEmailTokenProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_ChangeEmailTokenProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ChangePhoneNumberTokenProvider()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_ChangePhoneNumberTokenProvider
    open func get_ChangePhoneNumberTokenProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_ChangePhoneNumberTokenProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ChangePhoneNumberTokenProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_ChangePhoneNumberTokenProvider(System.String)
    open func set_ChangePhoneNumberTokenProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_ChangePhoneNumberTokenProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_AuthenticatorTokenProvider()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_AuthenticatorTokenProvider
    open func get_AuthenticatorTokenProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_AuthenticatorTokenProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticatorTokenProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_AuthenticatorTokenProvider(System.String)
    open func set_AuthenticatorTokenProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_AuthenticatorTokenProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_AuthenticatorIssuer()
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.get_AuthenticatorIssuer
    open func get_AuthenticatorIssuer() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenOptions_String__get_AuthenticatorIssuer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticatorIssuer(System.String)
// docid: M:Microsoft.AspNetCore.Identity.TokenOptions.set_AuthenticatorIssuer(System.String)
    open func set_AuthenticatorIssuer(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenOptions_void__set_AuthenticatorIssuer_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the issuer used for the authenticator issuer.
            

    */
    open var AuthenticatorIssuer : Optional<dotnet.System.String> {
        get {
            return try! get_AuthenticatorIssuer();
        }
        set(v) {
            return try! set_AuthenticatorIssuer(value: v!);
        }
    }
    /**
    
            Gets or sets the  used to validate two factor sign ins with an authenticator.
            

    */
    open var AuthenticatorTokenProvider : Optional<dotnet.System.String> {
        get {
            return try! get_AuthenticatorTokenProvider();
        }
        set(v) {
            return try! set_AuthenticatorTokenProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the  used to generate tokens used in email change confirmation emails.
            

    */
    open var ChangeEmailTokenProvider : Optional<dotnet.System.String> {
        get {
            return try! get_ChangeEmailTokenProvider();
        }
        set(v) {
            return try! set_ChangeEmailTokenProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the  used to generate tokens used when changing phone numbers.
            

    */
    open var ChangePhoneNumberTokenProvider : Optional<dotnet.System.String> {
        get {
            return try! get_ChangePhoneNumberTokenProvider();
        }
        set(v) {
            return try! set_ChangePhoneNumberTokenProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the token provider used to generate tokens used in account confirmation emails.
            

    */
    open var EmailConfirmationTokenProvider : Optional<dotnet.System.String> {
        get {
            return try! get_EmailConfirmationTokenProvider();
        }
        set(v) {
            return try! set_EmailConfirmationTokenProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the  used to generate tokens used in password reset emails.
            

    */
    open var PasswordResetTokenProvider : Optional<dotnet.System.String> {
        get {
            return try! get_PasswordResetTokenProvider();
        }
        set(v) {
            return try! set_PasswordResetTokenProvider(value: v!);
        }
    }
    /**
    
            Will be used to construct UserTokenProviders with the key used as the providerName.
            

    */
    open var ProviderMap : Optional<dotnet.System.Collections.Generic.Dictionary_2<dotnet.System.String,aspnetcore.Microsoft.AspNetCore.Identity.TokenProviderDescriptor>> {
        get {
            return try! get_ProviderMap();
        }
        set(v) {
            return try! set_ProviderMap(value: v!);
        }
    }
} // TokenOptions


// type: Microsoft.AspNetCore.Identity.TokenProviderDescriptor
    /**
    
            Used to represents a token provider in 's TokenMap.
            

    */
open class TokenProviderDescriptor
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_TokenProviderDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Type)
// docid: M:Microsoft.AspNetCore.Identity.TokenProviderDescriptor.#ctor(System.Type)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter type: The concrete type for this token provider.
    */
    public init(type : Optional<dotnet.System.Type_>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_TokenProviderDescriptor_ctor_0__1__Type(&__thrown, type?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_ProviderType()
// docid: M:Microsoft.AspNetCore.Identity.TokenProviderDescriptor.get_ProviderType
    open func get_ProviderType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenProviderDescriptor_Type__get_ProviderType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Object get_ProviderInstance()
// docid: M:Microsoft.AspNetCore.Identity.TokenProviderDescriptor.get_ProviderInstance
    open func get_ProviderInstance() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TokenProviderDescriptor_Object__get_ProviderInstance_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderInstance(System.Object)
// docid: M:Microsoft.AspNetCore.Identity.TokenProviderDescriptor.set_ProviderInstance(System.Object)
    open func set_ProviderInstance(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_TokenProviderDescriptor_void__set_ProviderInstance_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            If specified, the instance to be used for the token provider.
            

    */
    open var ProviderInstance : Optional<dotnet.System.Object> {
        get {
            return try! get_ProviderInstance();
        }
        set(v) {
            return try! set_ProviderInstance(value: v!);
        }
    }
    /**
    
            The type that will be used for this token provider.
            

    */
    open var ProviderType : Optional<dotnet.System.Type_> {
        get {
            return try! get_ProviderType();
        }
    }
} // TokenProviderDescriptor


// type: Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider`1
    /**
    
            Represents a token provider that generates time-based codes using the user's security stamp.
            

    */
open class TotpSecurityStampBasedTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_TotpSecurityStampBasedTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.Task<System.String> GenerateAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider`1.GenerateAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Generates a token for the specified  and .
            

    - Parameter purpose: The purpose the token will be used for.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the token for the specified 
             and .
            

    */
    open func GenerateAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TotpSecurityStampBasedTokenProvider_1_System_Threading_Tasks_Task_string___GenerateAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> ValidateAsync(System.String, System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider`1.ValidateAsync(System.String,System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a flag indicating whether the specified  is valid for the given
             and .
            

    - Parameter purpose: The purpose the token will be used for.
    - Parameter token: The token to validate.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be validated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the a flag indicating the result
            of validating the  for the specified  and .
            The task will return true if the token is valid, otherwise false.
            

    */
    open func ValidateAsync(purpose : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TotpSecurityStampBasedTokenProvider_1_System_Threading_Tasks_Task_bool___ValidateAsync_0__4__String_String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, token?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserModifierAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider`1.GetUserModifierAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a constant, provider and user unique modifier used for entropy in generated tokens from user information.
            

    - Parameter purpose: The purpose the token will be generated for.
    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token should be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing a constant modifier for the specified 
             and .
            

    */
    open func GetUserModifierAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TotpSecurityStampBasedTokenProvider_1_System_Threading_Tasks_Task_string___GetUserModifierAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.TotpSecurityStampBasedTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a flag indicating whether the token provider can generate a token suitable for two-factor authentication token for
            the specified .
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user a token could be generated for.
    - Returns: 
            The  that represents the asynchronous operation, containing the a flag indicating if a two
            factor token could be generated by this provider for the specified .
            The task will return true if a two-factor authentication token could be generated, otherwise false.
            

    */
    open func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_TotpSecurityStampBasedTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // TotpSecurityStampBasedTokenProvider_1


// type: Microsoft.AspNetCore.Identity.UpperInvariantLookupNormalizer
    /**
    
            Implements  by converting keys to their upper cased invariant culture representation.
            

    */
public final class UpperInvariantLookupNormalizer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Identity_ILookupNormalizer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UpperInvariantLookupNormalizer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.UpperInvariantLookupNormalizer.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UpperInvariantLookupNormalizer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String NormalizeName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UpperInvariantLookupNormalizer.NormalizeName(System.String)
    /**
    
            Returns a normalized representation of the specified .
            

    - Parameter name: The key to normalize.
    - Returns: A normalized representation of the specified .

    */
    public func NormalizeName(name : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UpperInvariantLookupNormalizer_String__NormalizeName_0__1__String(&__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String NormalizeEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UpperInvariantLookupNormalizer.NormalizeEmail(System.String)
    /**
    
            Returns a normalized representation of the specified .
            

    - Parameter email: The email to normalize.
    - Returns: A normalized representation of the specified .

    */
    public func NormalizeEmail(email : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UpperInvariantLookupNormalizer_String__NormalizeEmail_0__1__String(&__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // UpperInvariantLookupNormalizer


// type: Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`1
    /**
    
            Provides methods to create a claims principal for a given user.
            

    */
open class UserClaimsPrincipalFactory_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.UserManager<TUser>, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions>)
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`1.#ctor(Microsoft.AspNetCore.Identity.UserManager{`0},Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.IdentityOptions})
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter userManager: The  to retrieve user information from.
    - Parameter optionsAccessor: The configured .
    */
    public init(userManager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_1_ctor_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_IdentityOptions_(TUser.get_type_handle(), &__thrown, nil, (optionsAccessor?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<System.Security.Claims.ClaimsPrincipal> CreateAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`1.CreateAsync(`0)
    /**
    
            Creates a  from an user asynchronously.
            

    - Parameter user: The user to create a  from.
    - Returns: The  that represents the asynchronous creation operation, containing the created .

    */
    open func CreateAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Security.Claims.ClaimsPrincipal>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_1_System_Threading_Tasks_Task_System_Security_Claims_ClaimsPrincipal___CreateAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.UserManager<TUser> get_UserManager()
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`1.get_UserManager
    open func get_UserManager() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_1_Microsoft_AspNetCore_Identity_UserManager_TUser___get_UserManager_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityOptions get_Options()
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`1.get_Options
    open func get_Options() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_1_IdentityOptions__get_Options_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  for this factory.
            

    */
    open var Options : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        get {
            return try! get_Options();
        }
    }
    /**
    
            Gets the  for this factory.
            

    */
    open var UserManager : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>> {
        get {
            return try! get_UserManager();
        }
    }
} // UserClaimsPrincipalFactory_1


// type: Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`2
    /**
    
            Provides methods to create a claims principal for a given user.
            

    */
open class UserClaimsPrincipalFactory_2<TUser : SGBridgeGenericValue,TRole : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory_1<TUser>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_2_get_type_handle(TUser.get_type_handle(),TRole.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.UserManager<TUser>, Microsoft.AspNetCore.Identity.RoleManager<TRole>, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions>)
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`2.#ctor(Microsoft.AspNetCore.Identity.UserManager{`0},Microsoft.AspNetCore.Identity.RoleManager{`1},Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.IdentityOptions})
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter userManager: The  to retrieve user information from.
    - Parameter roleManager: The  to retrieve a user's roles from.
    - Parameter options: The configured .
    */
    public init(userManager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, roleManager : aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>, options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_2_ctor_0__3__Microsoft_AspNetCore_Identity_UserManager_TUser__Microsoft_AspNetCore_Identity_RoleManager_TRole__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_IdentityOptions_(TUser.get_type_handle(), TRole.get_type_handle(), &__thrown, nil, nil, (options?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.RoleManager<TRole> get_RoleManager()
// docid: M:Microsoft.AspNetCore.Identity.UserClaimsPrincipalFactory`2.get_RoleManager
    open func get_RoleManager() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserClaimsPrincipalFactory_2_Microsoft_AspNetCore_Identity_RoleManager_TRole___get_RoleManager_0__0(TUser.get_type_handle(), TRole.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  for this factory.
            

    */
    open var RoleManager : Optional<aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>> {
        get {
            return try! get_RoleManager();
        }
    }
} // UserClaimsPrincipalFactory_2


// type: Microsoft.AspNetCore.Identity.UserLoginInfo
    /**
    
            Represents login information and source for a user record.
            

    */
open class UserLoginInfo
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserLoginInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.#ctor(System.String,System.String,System.String)
    /**
    
            Creates a new instance of 
            

    - Parameter loginProvider: The provider associated with this login information.
    - Parameter providerKey: The unique identifier for this user provided by the login provider.
    - Parameter displayName: The display name for this user provided by the login provider.
    */
    public init(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, displayName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserLoginInfo_ctor_0__3__String_String_String(&__thrown, loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, displayName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_LoginProvider()
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.get_LoginProvider
    open func get_LoginProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserLoginInfo_String__get_LoginProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LoginProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.set_LoginProvider(System.String)
    open func set_LoginProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserLoginInfo_void__set_LoginProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ProviderKey()
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.get_ProviderKey
    open func get_ProviderKey() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserLoginInfo_String__get_ProviderKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderKey(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.set_ProviderKey(System.String)
    open func set_ProviderKey(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserLoginInfo_void__set_ProviderKey_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ProviderDisplayName()
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.get_ProviderDisplayName
    open func get_ProviderDisplayName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserLoginInfo_String__get_ProviderDisplayName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderDisplayName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserLoginInfo.set_ProviderDisplayName(System.String)
    open func set_ProviderDisplayName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserLoginInfo_void__set_ProviderDisplayName_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the provider for this instance of .
            

    */
    open var LoginProvider : Optional<dotnet.System.String> {
        get {
            return try! get_LoginProvider();
        }
        set(v) {
            return try! set_LoginProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the display name for the provider.
            

    */
    open var ProviderDisplayName : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderDisplayName();
        }
        set(v) {
            return try! set_ProviderDisplayName(value: v!);
        }
    }
    /**
    
            Gets or sets the unique identifier for the user identity user provided by the login provider.
            

    */
    open var ProviderKey : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderKey();
        }
        set(v) {
            return try! set_ProviderKey(value: v!);
        }
    }
} // UserLoginInfo


// type: Microsoft.AspNetCore.Identity.UserManager`1
    /**
    
            Provides the APIs for managing user in a persistence store.
            

    */
open class UserManager_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserManager_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.String ResetPasswordTokenPurpose
    /**
    
            The data protection purpose used for the reset password related methods.
            

    */
    open class var ResetPasswordTokenPurpose : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_UserManager_1_get_ResetPasswordTokenPurpose();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String ChangePhoneNumberTokenPurpose
    /**
    
            The data protection purpose used for the change phone number methods.
            

    */
    open class var ChangePhoneNumberTokenPurpose : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_UserManager_1_get_ChangePhoneNumberTokenPurpose();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String ConfirmEmailTokenPurpose
    /**
    
            The data protection purpose used for the email confirmation related methods.
            

    */
    open class var ConfirmEmailTokenPurpose : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_UserManager_1_get_ConfirmEmailTokenPurpose();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // .ctor(Microsoft.AspNetCore.Identity.IUserStore<TUser>, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions>, Microsoft.AspNetCore.Identity.IPasswordHasher<TUser>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IUserValidator<TUser>>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IPasswordValidator<TUser>>, Microsoft.AspNetCore.Identity.ILookupNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber, System.IServiceProvider, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.UserManager<TUser>>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.#ctor(Microsoft.AspNetCore.Identity.IUserStore{`0},Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.IdentityOptions},Microsoft.AspNetCore.Identity.IPasswordHasher{`0},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IUserValidator{`0}},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IPasswordValidator{`0}},Microsoft.AspNetCore.Identity.ILookupNormalizer,Microsoft.AspNetCore.Identity.IdentityErrorDescriber,System.IServiceProvider,Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.UserManager{`0}})
    /**
    
            Constructs a new instance of .
            

    - Parameter store: The persistence store the manager will operate over.
    - Parameter optionsAccessor: The accessor used to access the .
    - Parameter passwordHasher: The password hashing implementation to use when saving passwords.
    - Parameter userValidators: A collection of  to validate users against.
    - Parameter passwordValidators: A collection of  to validate passwords against.
    - Parameter keyNormalizer: The  to use when generating index keys for users.
    - Parameter errors: The  used to provider error messages.
    - Parameter services: The  used to resolve services.
    - Parameter logger: The logger used to log messages, warnings and errors.
    */
    public init(store : aspnetcore.Microsoft.AspNetCore.Identity.IUserStore_1<TUser>, optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>>, passwordHasher : aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1<TUser>, userValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IUserValidator_1<TUser>>>, passwordValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordValidator_1<TUser>>>, keyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>, errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>, services : Optional<dotnet.System.IServiceProvider>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserManager_1_ctor_0__9__Microsoft_AspNetCore_Identity_IUserStore_TUser__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_IdentityOptions__Microsoft_AspNetCore_Identity_IPasswordHasher_TUser__System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IUserValidator_TUser___System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IPasswordValidator_TUser___ILookupNormalizer_IdentityErrorDescriber_IServiceProvider_Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_UserManager_TUser__(TUser.get_type_handle(), &__thrown, nil, (optionsAccessor?.get_handle()), nil, (userValidators?.get_handle()), (passwordValidators?.get_handle()), keyNormalizer?.get_handle() ?? nil, errors?.get_handle() ?? nil, services?.get_handle() ?? nil, (logger?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.Dispose
    /**
    
            Releases all resources used by the user manager.
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__Dispose_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String GetUserName(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUserName(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Returns the Name claim value if present otherwise returns null.
            

    - Parameter principal: The  instance.
    - Returns: The Name claim value, or null if the claim is not present.

    */
    open func GetUserName(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__GetUserName_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String GetUserId(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUserId(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Returns the User ID claim value if present otherwise returns null.
            

    - Parameter principal: The  instance.
    - Returns: The User ID claim value, or null if the claim is not present.

    */
    open func GetUserId(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__GetUserId_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> GetUserAsync(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUserAsync(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Returns the user corresponding to the IdentityOptions.ClaimsIdentity.UserIdClaimType claim in
            the principal or null.
            

    - Parameter principal: The principal which contains the user id claim.
    - Returns: The user corresponding to the IdentityOptions.ClaimsIdentity.UserIdClaimType claim in
            the principal or null

    */
    open func GetUserAsync(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_TUser___GetUserAsync_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateConcurrencyStampAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateConcurrencyStampAsync(`0)
    /**
    
            Generates a value suitable for use in concurrency tracking.
            

    - Parameter user: The user to generate the stamp for.
    - Returns: 
            The  that represents the asynchronous operation, containing the security
            stamp for the specified .
            

    */
    open func GenerateConcurrencyStampAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateConcurrencyStampAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.CreateAsync(`0)
    /**
    
            Creates the specified  in the backing store with no password,
            as an asynchronous operation.
            

    - Parameter user: The user to create.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func CreateAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.UpdateAsync(`0)
    /**
    
            Updates the specified  in the backing store.
            

    - Parameter user: The user to update.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func UpdateAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.DeleteAsync(`0)
    /**
    
            Deletes the specified  from the backing store.
            

    - Parameter user: The user to delete.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func DeleteAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByIdAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.FindByIdAsync(System.String)
    /**
    
            Finds and returns a user, if any, who has the specified .
            

    - Parameter userId: The user ID to search for.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByIdAsync(userId : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_TUser___FindByIdAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), userId?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByNameAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.FindByNameAsync(System.String)
    /**
    
            Finds and returns a user, if any, who has the specified user name.
            

    - Parameter userName: The user name to search for.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByNameAsync(userName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_TUser___FindByNameAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), userName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.CreateAsync(`0,System.String)
    /**
    
            Creates the specified  in the backing store with given password,
            as an asynchronous operation.
            

    - Parameter user: The user to create.
    - Parameter password: The password for the user to hash and store.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func CreateAsync(user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String NormalizeName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.NormalizeName(System.String)
    /**
    
            Normalize user or role name for consistent comparisons.
            

    - Parameter name: The name to normalize.
    - Returns: A normalized value representing the specified .

    */
    open func NormalizeName(name : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__NormalizeName_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String NormalizeEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.NormalizeEmail(System.String)
    /**
    
            Normalize email for consistent comparisons.
            

    - Parameter email: The email to normalize.
    - Returns: A normalized value representing the specified .

    */
    open func NormalizeEmail(email : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__NormalizeEmail_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task UpdateNormalizedUserNameAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.UpdateNormalizedUserNameAsync(`0)
    /**
    
            Updates the normalized user name for the specified .
            

    - Parameter user: The user whose user name should be normalized and updated.
    - Returns: The  that represents the asynchronous operation.

    */
    open func UpdateNormalizedUserNameAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_Task__UpdateNormalizedUserNameAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserNameAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUserNameAsync(`0)
    /**
    
            Gets the user name for the specified .
            

    - Parameter user: The user whose name should be retrieved.
    - Returns: The  that represents the asynchronous operation, containing the name for the specified .

    */
    open func GetUserNameAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetUserNameAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetUserNameAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetUserNameAsync(`0,System.String)
    /**
    
            Sets the given  for the specified .
            

    - Parameter user: The user whose name should be set.
    - Parameter userName: The user name to set.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetUserNameAsync(user : TUser, userName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetUserNameAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), userName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserIdAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUserIdAsync(`0)
    /**
    
            Gets the user identifier for the specified .
            

    - Parameter user: The user whose identifier should be retrieved.
    - Returns: The  that represents the asynchronous operation, containing the identifier for the specified .

    */
    open func GetUserIdAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetUserIdAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> CheckPasswordAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.CheckPasswordAsync(`0,System.String)
    /**
    
            Returns a flag indicating whether the given  is valid for the
            specified .
            

    - Parameter user: The user whose password should be validated.
    - Parameter password: The password to validate
    - Returns: The  that represents the asynchronous operation, containing true if
            the specified  matches the one store for the ,
            otherwise false.

    */
    open func CheckPasswordAsync(user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___CheckPasswordAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> HasPasswordAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.HasPasswordAsync(`0)
    /**
    
            Gets a flag indicating whether the specified  has a password.
            

    - Parameter user: The user to return a flag for, indicating whether they have a password or not.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the specified  has a password
            otherwise false.
            

    */
    open func HasPasswordAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___HasPasswordAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddPasswordAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddPasswordAsync(`0,System.String)
    /**
    
            Adds the  to the specified  only if the user
            does not already have a password.
            

    - Parameter user: The user whose password should be set.
    - Parameter password: The password to set.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddPasswordAsync(user : TUser, password : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddPasswordAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ChangePasswordAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ChangePasswordAsync(`0,System.String,System.String)
    /**
    
            Changes a user's password after confirming the specified  is correct,
            as an asynchronous operation.
            

    - Parameter user: The user whose password should be set.
    - Parameter currentPassword: The current password to validate before changing.
    - Parameter newPassword: The new password to set for the specified .
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ChangePasswordAsync(user : TUser, currentPassword : Optional<dotnet.System.String>, newPassword : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ChangePasswordAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), currentPassword?.get_handle() ?? nil, newPassword?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemovePasswordAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemovePasswordAsync(`0)
    /**
    
            Removes a user's password.
            

    - Parameter user: The user whose password should be removed.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemovePasswordAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemovePasswordAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetSecurityStampAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetSecurityStampAsync(`0)
    /**
    
            Get the security stamp for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Returns: The  that represents the asynchronous operation, containing the security stamp for the specified .

    */
    open func GetSecurityStampAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetSecurityStampAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateSecurityStampAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.UpdateSecurityStampAsync(`0)
    /**
    
            Regenerates the security stamp for the specified .
            

    - Parameter user: The user whose security stamp should be regenerated.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func UpdateSecurityStampAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateSecurityStampAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GeneratePasswordResetTokenAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GeneratePasswordResetTokenAsync(`0)
    /**
    
            Generates a password reset token for the specified , using
            the configured password reset token provider.
            

    - Parameter user: The user to generate a password reset token for.
    - Returns: The  that represents the asynchronous operation,
            containing a password reset token for the specified .

    */
    open func GeneratePasswordResetTokenAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GeneratePasswordResetTokenAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ResetPasswordAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ResetPasswordAsync(`0,System.String,System.String)
    /**
    
            Resets the 's password to the specified  after
            validating the given password reset .
            

    - Parameter user: The user whose password should be reset.
    - Parameter token: The password reset token to verify.
    - Parameter newPassword: The new password to set if reset token verification succeeds.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ResetPasswordAsync(user : TUser, token : Optional<dotnet.System.String>, newPassword : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ResetPasswordAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), token?.get_handle() ?? nil, newPassword?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByLoginAsync(System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.FindByLoginAsync(System.String,System.String)
    /**
    
            Retrieves the user associated with the specified external login provider and login provider key.
            

    - Parameter loginProvider: The login provider who provided the .
    - Parameter providerKey: The key provided by the  to identify a user.
    - Returns: 
            The  for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
            

    */
    open func FindByLoginAsync(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_TUser___FindByLoginAsync_0__2__String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveLoginAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveLoginAsync(`0,System.String,System.String)
    /**
    
            Attempts to remove the provided external login information from the specified .
            and returns a flag indicating whether the removal succeed or not.
            

    - Parameter user: The user to remove the login information from.
    - Parameter loginProvider: The login provide whose information should be removed.
    - Parameter providerKey: The key given by the external login provider for the specified user.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveLoginAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveLoginAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddLoginAsync(TUser, Microsoft.AspNetCore.Identity.UserLoginInfo)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddLoginAsync(`0,Microsoft.AspNetCore.Identity.UserLoginInfo)
    /**
    
            Adds an external  to the specified .
            

    - Parameter user: The user to add the login to.
    - Parameter login: The external  to add to the specified .
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddLoginAsync(user : TUser, login : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddLoginAsync_0__2__TUser_UserLoginInfo(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), login?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.UserLoginInfo>> GetLoginsAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetLoginsAsync(`0)
    /**
    
            Retrieves the associated logins for the specified .
            

    - Parameter user: The user whose associated logins to retrieve.
    - Returns: 
            The  for the asynchronous operation, containing a list of  for the specified , if any.
            

    */
    open func GetLoginsAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_UserLoginInfo____GetLoginsAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddClaimAsync(TUser, System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddClaimAsync(`0,System.Security.Claims.Claim)
    /**
    
            Adds the specified  to the .
            

    - Parameter user: The user to add the claim to.
    - Parameter claim: The claim to add.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddClaimAsync(user : TUser, claim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddClaimAsync_0__2__TUser_Claim(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})
    /**
    
            Adds the specified  to the .
            

    - Parameter user: The user to add the claim to.
    - Parameter claims: The claims to add.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddClaimsAsync_0__2__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ReplaceClaimAsync(TUser, System.Security.Claims.Claim, System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ReplaceClaimAsync(`0,System.Security.Claims.Claim,System.Security.Claims.Claim)
    /**
    
            Replaces the given  on the specified  with the 
            

    - Parameter user: The user to replace the claim on.
    - Parameter claim: The claim to replace.
    - Parameter newClaim: The new claim to replace the existing  with.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ReplaceClaimAsync(user : TUser, claim : Optional<dotnet.System.Security.Claims.Claim>, newClaim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ReplaceClaimAsync_0__3__TUser_Claim_Claim(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), claim?.get_handle() ?? nil, newClaim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveClaimAsync(TUser, System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveClaimAsync(`0,System.Security.Claims.Claim)
    /**
    
            Removes the specified  from the given .
            

    - Parameter user: The user to remove the specified  from.
    - Parameter claim: The  to remove.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveClaimAsync(user : TUser, claim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveClaimAsync_0__2__TUser_Claim(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})
    /**
    
            Removes the specified  from the given .
            

    - Parameter user: The user to remove the specified  from.
    - Parameter claims: A collection of s to remove.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveClaimsAsync_0__2__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetClaimsAsync(`0)
    /**
    
            Gets a list of s to be belonging to the specified  as an asynchronous operation.
            

    - Parameter user: The user whose claims to retrieve.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of s.
            

    */
    open func GetClaimsAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddToRoleAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddToRoleAsync(`0,System.String)
    /**
    
            Add the specified  to the named role.
            

    - Parameter user: The user to add to the named role.
    - Parameter role: The name of the role to add the user to.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddToRoleAsync(user : TUser, role : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddToRoleAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AddToRolesAsync(TUser, System.Collections.Generic.IEnumerable<System.String>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AddToRolesAsync(`0,System.Collections.Generic.IEnumerable{System.String})
    /**
    
            Add the specified  to the named roles.
            

    - Parameter user: The user to add to the named roles.
    - Parameter roles: The name of the roles to add the user to.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func AddToRolesAsync(user : TUser, roles : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AddToRolesAsync_0__2__TUser_System_Collections_Generic_IEnumerable_string_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (roles?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveFromRoleAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveFromRoleAsync(`0,System.String)
    /**
    
            Removes the specified  from the named role.
            

    - Parameter user: The user to remove from the named role.
    - Parameter role: The name of the role to remove the user from.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveFromRoleAsync(user : TUser, role : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveFromRoleAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveFromRolesAsync(TUser, System.Collections.Generic.IEnumerable<System.String>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveFromRolesAsync(`0,System.Collections.Generic.IEnumerable{System.String})
    /**
    
            Removes the specified  from the named roles.
            

    - Parameter user: The user to remove from the named roles.
    - Parameter roles: The name of the roles to remove the user from.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func RemoveFromRolesAsync(user : TUser, roles : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveFromRolesAsync_0__2__TUser_System_Collections_Generic_IEnumerable_string_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (roles?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.String>> GetRolesAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetRolesAsync(`0)
    /**
    
            Gets a list of role names the specified  belongs to.
            

    - Parameter user: The user whose role names to retrieve.
    - Returns: The  that represents the asynchronous operation, containing a list of role names.

    */
    open func GetRolesAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_string____GetRolesAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsInRoleAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.IsInRoleAsync(`0,System.String)
    /**
    
            Returns a flag indicating whether the specified  is a member of the given named role.
            

    - Parameter user: The user whose role membership should be checked.
    - Parameter role: The name of the role to be checked.
    - Returns: 
            The  that represents the asynchronous operation, containing a flag indicating whether the specified  is
            a member of the named role.
            

    */
    open func IsInRoleAsync(user : TUser, role : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___IsInRoleAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), role?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetEmailAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetEmailAsync(`0)
    /**
    
            Gets the email address for the specified .
            

    - Parameter user: The user whose email should be returned.
    - Returns: The task object containing the results of the asynchronous operation, the email address for the specified .

    */
    open func GetEmailAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetEmailAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetEmailAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetEmailAsync(`0,System.String)
    /**
    
            Sets the  address for a .
            

    - Parameter user: The user whose email should be set.
    - Parameter email: The email to set.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func SetEmailAsync(user : TUser, email : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetEmailAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByEmailAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.FindByEmailAsync(System.String)
    /**
    
            Gets the user, if any, associated with the normalized value of the specified email address.
            Note: Its recommended that identityOptions.User.RequireUniqueEmail be set to true when using this method, otherwise
            the store may throw if there are users with duplicate emails.
            

    - Parameter email: The email address to return the user for.
    - Returns: 
            The task object containing the results of the asynchronous lookup operation, the user, if any, associated with a normalized value of the specified email address.
            

    */
    open func FindByEmailAsync(email : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_TUser___FindByEmailAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), email?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task UpdateNormalizedEmailAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.UpdateNormalizedEmailAsync(`0)
    /**
    
            Updates the normalized email for the specified .
            

    - Parameter user: The user whose email address should be normalized and updated.
    - Returns: The task object representing the asynchronous operation.

    */
    open func UpdateNormalizedEmailAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_Task__UpdateNormalizedEmailAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateEmailConfirmationTokenAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateEmailConfirmationTokenAsync(`0)
    /**
    
            Generates an email confirmation token for the specified user.
            

    - Parameter user: The user to generate an email confirmation token for.
    - Returns: 
            The  that represents the asynchronous operation, an email confirmation token.
            

    */
    open func GenerateEmailConfirmationTokenAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateEmailConfirmationTokenAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ConfirmEmailAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ConfirmEmailAsync(`0,System.String)
    /**
    
            Validates that an email confirmation token matches the specified .
            

    - Parameter user: The user to validate the token against.
    - Parameter token: The email confirmation token to validate.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ConfirmEmailAsync(user : TUser, token : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ConfirmEmailAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), token?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsEmailConfirmedAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.IsEmailConfirmedAsync(`0)
    /**
    
            Gets a flag indicating whether the email address for the specified  has been verified, true if the email address is verified otherwise
            false.
            

    - Parameter user: The user whose email confirmation status should be returned.
    - Returns: 
            The task object containing the results of the asynchronous operation, a flag indicating whether the email address for the specified 
            has been confirmed or not.
            

    */
    open func IsEmailConfirmedAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___IsEmailConfirmedAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateChangeEmailTokenAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateChangeEmailTokenAsync(`0,System.String)
    /**
    
            Generates an email change token for the specified user.
            

    - Parameter user: The user to generate an email change token for.
    - Parameter newEmail: The new email address.
    - Returns: 
            The  that represents the asynchronous operation, an email change token.
            

    */
    open func GenerateChangeEmailTokenAsync(user : TUser, newEmail : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateChangeEmailTokenAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), newEmail?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ChangeEmailAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ChangeEmailAsync(`0,System.String,System.String)
    /**
    
            Updates a users emails if the specified email change  is valid for the user.
            

    - Parameter user: The user whose email should be updated.
    - Parameter newEmail: The new email address.
    - Parameter token: The change email token to be verified.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ChangeEmailAsync(user : TUser, newEmail : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ChangeEmailAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), newEmail?.get_handle() ?? nil, token?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetPhoneNumberAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetPhoneNumberAsync(`0)
    /**
    
            Gets the telephone number, if any, for the specified .
            

    - Parameter user: The user whose telephone number should be retrieved.
    - Returns: The  that represents the asynchronous operation, containing the user's telephone number, if any.

    */
    open func GetPhoneNumberAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetPhoneNumberAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetPhoneNumberAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetPhoneNumberAsync(`0,System.String)
    /**
    
            Sets the phone number for the specified .
            

    - Parameter user: The user whose phone number to set.
    - Parameter phoneNumber: The phone number to set.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func SetPhoneNumberAsync(user : TUser, phoneNumber : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetPhoneNumberAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), phoneNumber?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ChangePhoneNumberAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ChangePhoneNumberAsync(`0,System.String,System.String)
    /**
    
            Sets the phone number for the specified  if the specified
            change  is valid.
            

    - Parameter user: The user whose phone number to set.
    - Parameter phoneNumber: The phone number to set.
    - Parameter token: The phone number confirmation token to validate.
    - Returns: 
            The  that represents the asynchronous operation, containing the 
            of the operation.
            

    */
    open func ChangePhoneNumberAsync(user : TUser, phoneNumber : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ChangePhoneNumberAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), phoneNumber?.get_handle() ?? nil, token?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsPhoneNumberConfirmedAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.IsPhoneNumberConfirmedAsync(`0)
    /**
    
            Gets a flag indicating whether the specified 's telephone number has been confirmed.
            

    - Parameter user: The user to return a flag for, indicating whether their telephone number is confirmed.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the specified  has a confirmed
            telephone number otherwise false.
            

    */
    open func IsPhoneNumberConfirmedAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___IsPhoneNumberConfirmedAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateChangePhoneNumberTokenAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateChangePhoneNumberTokenAsync(`0,System.String)
    /**
    
            Generates a telephone number change token for the specified user.
            

    - Parameter user: The user to generate a telephone number token for.
    - Parameter phoneNumber: The new phone number the validation token should be sent to.
    - Returns: 
            The  that represents the asynchronous operation, containing the telephone change number token.
            

    */
    open func GenerateChangePhoneNumberTokenAsync(user : TUser, phoneNumber : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateChangePhoneNumberTokenAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), phoneNumber?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> VerifyChangePhoneNumberTokenAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.VerifyChangePhoneNumberTokenAsync(`0,System.String,System.String)
    /**
    
            Returns a flag indicating whether the specified 's phone number change verification
            token is valid for the given .
            

    - Parameter user: The user to validate the token against.
    - Parameter token: The telephone number change token to validate.
    - Parameter phoneNumber: The telephone number the token was generated for.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the 
            is valid, otherwise false.
            

    */
    open func VerifyChangePhoneNumberTokenAsync(user : TUser, token : Optional<dotnet.System.String>, phoneNumber : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___VerifyChangePhoneNumberTokenAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), token?.get_handle() ?? nil, phoneNumber?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> VerifyUserTokenAsync(TUser, System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.VerifyUserTokenAsync(`0,System.String,System.String,System.String)
    /**
    
            Returns a flag indicating whether the specified  is valid for
            the given  and .
            

    - Parameter user: The user to validate the token against.
    - Parameter tokenProvider: The token provider used to generate the token.
    - Parameter purpose: The purpose the token should be generated for.
    - Parameter token: The token to validate
    - Returns: 
            The  that represents the asynchronous operation, returning true if the 
            is valid, otherwise false.
            

    */
    open func VerifyUserTokenAsync(user : TUser, tokenProvider : Optional<dotnet.System.String>, purpose : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___VerifyUserTokenAsync_0__4__TUser_String_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), tokenProvider?.get_handle() ?? nil, purpose?.get_handle() ?? nil, token?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateUserTokenAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateUserTokenAsync(`0,System.String,System.String)
    /**
    
            Generates a token for the given  and .
            

    - Parameter purpose: The purpose the token will be for.
    - Parameter user: The user the token will be for.
    - Parameter tokenProvider: The provider which will generate the token.
    - Returns: 
            The  that represents result of the asynchronous operation, a token for
            the given user and purpose.
            

    */
    open func GenerateUserTokenAsync(user : TUser, tokenProvider : Optional<dotnet.System.String>, purpose : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateUserTokenAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), tokenProvider?.get_handle() ?? nil, purpose?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void RegisterTokenProvider(System.String, Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider<TUser>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RegisterTokenProvider(System.String,Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider{`0})
    /**
    
            Registers a token provider.
            

    - Parameter providerName: The name of the provider to register.
    - Parameter provider: The provider to register.
    */
    open func RegisterTokenProvider(providerName : Optional<dotnet.System.String>, provider : aspnetcore.Microsoft.AspNetCore.Identity.IUserTwoFactorTokenProvider_1<TUser>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__RegisterTokenProvider_0__2__String_Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_TUser_(TUser.get_type_handle(), &__thrown, self.get_handle(), providerName?.get_handle() ?? nil, nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.String>> GetValidTwoFactorProvidersAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetValidTwoFactorProvidersAsync(`0)
    /**
    
            Gets a list of valid two factor token providers for the specified ,
            as an asynchronous operation.
            

    - Parameter user: The user the whose two factor authentication providers will be returned.
    - Returns: 
            The  that represents result of the asynchronous operation, a list of two
            factor authentication providers for the specified user.
            

    */
    open func GetValidTwoFactorProvidersAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_string____GetValidTwoFactorProvidersAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> VerifyTwoFactorTokenAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.VerifyTwoFactorTokenAsync(`0,System.String,System.String)
    /**
    
            Verifies the specified two factor authentication  against the .
            

    - Parameter user: The user the token is supposed to be for.
    - Parameter tokenProvider: The provider which will verify the token.
    - Parameter token: The token to verify.
    - Returns: 
            The  that represents result of the asynchronous operation, true if the token is valid,
            otherwise false.
            

    */
    open func VerifyTwoFactorTokenAsync(user : TUser, tokenProvider : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___VerifyTwoFactorTokenAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), tokenProvider?.get_handle() ?? nil, token?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateTwoFactorTokenAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateTwoFactorTokenAsync(`0,System.String)
    /**
    
            Gets a two factor authentication token for the specified .
            

    - Parameter user: The user the token is for.
    - Parameter tokenProvider: The provider which will generate the token.
    - Returns: 
            The  that represents result of the asynchronous operation, a two factor authentication token
            for the user.
            

    */
    open func GenerateTwoFactorTokenAsync(user : TUser, tokenProvider : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GenerateTwoFactorTokenAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), tokenProvider?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetTwoFactorEnabledAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetTwoFactorEnabledAsync(`0)
    /**
    
            Returns a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be retrieved.
    - Returns: 
            The  that represents the asynchronous operation, true if the specified 
            has two factor authentication enabled, otherwise false.
            

    */
    open func GetTwoFactorEnabledAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___GetTwoFactorEnabledAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetTwoFactorEnabledAsync(TUser, bool)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetTwoFactorEnabledAsync(`0,System.Boolean)
    /**
    
            Sets a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be set.
    - Parameter enabled: A flag indicating whether the specified  has two factor authentication enabled.
    - Returns: 
            The  that represents the asynchronous operation, the  of the operation
            

    */
    open func SetTwoFactorEnabledAsync(user : TUser, enabled : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetTwoFactorEnabledAsync_0__2__TUser_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsLockedOutAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.IsLockedOutAsync(`0)
    /**
    
            Returns a flag indicating whether the specified  is locked out,
            as an asynchronous operation.
            

    - Parameter user: The user whose locked out status should be retrieved.
    - Returns: 
            The  that represents the asynchronous operation, true if the specified 
            is locked out, otherwise false.
            

    */
    open func IsLockedOutAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___IsLockedOutAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetLockoutEnabledAsync(TUser, bool)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetLockoutEnabledAsync(`0,System.Boolean)
    /**
    
            Sets a flag indicating whether the specified  is locked out,
            as an asynchronous operation.
            

    - Parameter user: The user whose locked out status should be set.
    - Parameter enabled: Flag indicating whether the user is locked out or not.
    - Returns: 
            The  that represents the asynchronous operation, the  of the operation
            

    */
    open func SetLockoutEnabledAsync(user : TUser, enabled : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetLockoutEnabledAsync_0__2__TUser_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetLockoutEnabledAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetLockoutEnabledAsync(`0)
    /**
    
            Retrieves a flag indicating whether user lockout can be enabled for the specified user.
            

    - Parameter user: The user whose ability to be locked out should be returned.
    - Returns: 
            The  that represents the asynchronous operation, true if a user can be locked out, otherwise false.
            

    */
    open func GetLockoutEnabledAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_bool___GetLockoutEnabledAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetLockoutEndDateAsync(TUser, System.Nullable<System.DateTimeOffset>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetLockoutEndDateAsync(`0,System.Nullable{System.DateTimeOffset})
    /**
    
            Locks out a user until the specified end date has passed. Setting a end date in the past immediately unlocks a user.
            

    - Parameter user: The user whose lockout date should be set.
    - Parameter lockoutEnd: The  after which the 's lockout should end.
    - Returns: The  that represents the asynchronous operation, containing the  of the operation.

    */
    open func SetLockoutEndDateAsync(user : TUser, lockoutEnd : Optional<dotnet.System.DateTimeOffset>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetLockoutEndDateAsync_0__2__TUser_System_Nullable_System_DateTimeOffset_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (lockoutEnd != nil) ? lockoutEnd!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> AccessFailedAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.AccessFailedAsync(`0)
    /**
    
            Increments the access failed count for the user as an asynchronous operation.
            If the failed access account is greater than or equal to the configured maximum number of attempts,
            the user will be locked out for the configured lockout time span.
            

    - Parameter user: The user whose failed access count to increment.
    - Returns: The  that represents the asynchronous operation, containing the  of the operation.

    */
    open func AccessFailedAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___AccessFailedAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ResetAccessFailedCountAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ResetAccessFailedCountAsync(`0)
    /**
    
            Resets the access failed count for the specified .
            

    - Parameter user: The user whose failed access count should be reset.
    - Returns: The  that represents the asynchronous operation, containing the  of the operation.

    */
    open func ResetAccessFailedCountAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ResetAccessFailedCountAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> GetAccessFailedCountAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetAccessFailedCountAsync(`0)
    /**
    
            Retrieves the current number of failed accesses for the given .
            

    - Parameter user: The user whose access failed count should be retrieved for.
    - Returns: The  that contains the result the asynchronous operation, the current failed access count
            for the user.

    */
    open func GetAccessFailedCountAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_i32___GetAccessFailedCountAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersForClaimAsync(System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUsersForClaimAsync(System.Security.Claims.Claim)
    /**
    
            Returns a list of users from the user store who have the specified .
            

    - Parameter claim: The claim to look for.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of s who
            have the specified claim.
            

    */
    open func GetUsersForClaimAsync(claim : Optional<dotnet.System.Security.Claims.Claim>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersForClaimAsync_0__1__Claim(TUser.get_type_handle(), &__thrown, self.get_handle(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersInRoleAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetUsersInRoleAsync(System.String)
    /**
    
            Returns a list of users from the user store who are members of the specified .
            

    - Parameter roleName: The name of the role whose users should be returned.
    - Returns: 
            A  that represents the result of the asynchronous query, a list of s who
            are members of the specified role.
            

    */
    open func GetUsersInRoleAsync(roleName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersInRoleAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), roleName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetAuthenticationTokenAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetAuthenticationTokenAsync(`0,System.String,System.String)
    /**
    
            Returns an authentication token for a user.
            

    - Parameter user: 
    - Parameter loginProvider: The authentication scheme for the provider the token is associated with.
    - Parameter tokenName: The name of the token.
    - Returns: The authentication token for a user

    */
    open func GetAuthenticationTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, tokenName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetAuthenticationTokenAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, tokenName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> SetAuthenticationTokenAsync(TUser, System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.SetAuthenticationTokenAsync(`0,System.String,System.String,System.String)
    /**
    
            Sets an authentication token for a user.
            

    - Parameter user: 
    - Parameter loginProvider: The authentication scheme for the provider the token is associated with.
    - Parameter tokenName: The name of the token.
    - Parameter tokenValue: The value of the token.
    - Returns: Whether the user was successfully updated.

    */
    open func SetAuthenticationTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, tokenName : Optional<dotnet.System.String>, tokenValue : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___SetAuthenticationTokenAsync_0__4__TUser_String_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, tokenName?.get_handle() ?? nil, tokenValue?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RemoveAuthenticationTokenAsync(TUser, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RemoveAuthenticationTokenAsync(`0,System.String,System.String)
    /**
    
            Remove an authentication token for a user.
            

    - Parameter user: 
    - Parameter loginProvider: The authentication scheme for the provider the token is associated with.
    - Parameter tokenName: The name of the token.
    - Returns: Whether a token was removed.

    */
    open func RemoveAuthenticationTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, tokenName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RemoveAuthenticationTokenAsync_0__3__TUser_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, tokenName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetAuthenticatorKeyAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetAuthenticatorKeyAsync(`0)
    /**
    
            Returns the authenticator key for the user.
            

    - Parameter user: The user.
    - Returns: The authenticator key

    */
    open func GetAuthenticatorKeyAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_string___GetAuthenticatorKeyAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ResetAuthenticatorKeyAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.ResetAuthenticatorKeyAsync(`0)
    /**
    
            Resets the authenticator key for the user.
            

    - Parameter user: The user.
    - Returns: Whether the user was successfully updated.

    */
    open func ResetAuthenticatorKeyAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ResetAuthenticatorKeyAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String GenerateNewAuthenticatorKey()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateNewAuthenticatorKey
    /**
    
            Generates a new base32 encoded 160-bit security secret (size of SHA1 hash).
            

    - Returns: The new security secret.

    */
    open func GenerateNewAuthenticatorKey() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__GenerateNewAuthenticatorKey_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.String>> GenerateNewTwoFactorRecoveryCodesAsync(TUser, System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GenerateNewTwoFactorRecoveryCodesAsync(`0,System.Int32)
    /**
    
            Generates recovery codes for the user, this invalidates any previous recovery codes for the user.
            

    - Parameter user: The user to generate recovery codes for.
    - Parameter number: The number of codes to generate.
    - Returns: The new recovery codes for the user.  Note: there may be less than number returned, as duplicates will be removed.

    */
    open func GenerateNewTwoFactorRecoveryCodesAsync(user : TUser, number : Swift.Int32) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IEnumerable_string____GenerateNewTwoFactorRecoveryCodesAsync_0__2__TUser_i32(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), number);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> RedeemTwoFactorRecoveryCodeAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.RedeemTwoFactorRecoveryCodeAsync(`0,System.String)
    /**
    
            Returns whether a recovery code is valid for a user. Note: recovery codes are only valid
            once, and will be invalid after use.
            

    - Parameter user: The user who owns the recovery code.
    - Parameter code: The recovery code to use.
    - Returns: True if the recovery code was found for the user.

    */
    open func RedeemTwoFactorRecoveryCodeAsync(user : TUser, code : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___RedeemTwoFactorRecoveryCodeAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), code?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> CountRecoveryCodesAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.CountRecoveryCodesAsync(`0)
    /**
    
            Returns how many recovery code are still valid for a user.
            

    - Parameter user: The user.
    - Returns: How many recovery code are still valid for a user.

    */
    open func CountRecoveryCodesAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_i32___CountRecoveryCodesAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Byte[]> CreateSecurityTokenAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.CreateSecurityTokenAsync(`0)
    /**
    
            Creates bytes to use as a security token from the user's security stamp.
            

    - Parameter user: The user.
    - Returns: The security token bytes.

    */
    open func CreateSecurityTokenAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System_Arr<Swift.UInt8>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Threading_Tasks_Task_u8Array___CreateSecurityTokenAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String GetChangeEmailTokenPurpose(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.GetChangeEmailTokenPurpose(System.String)
    /**
    
            Generates the token purpose used to change email.
            

    - Parameter newEmail: The new email address.
    - Returns: The token purpose.

    */
    open class func GetChangeEmailTokenPurpose(newEmail : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_String__GetChangeEmailTokenPurpose_0__1__String(TUser.get_type_handle(), &__thrown, newEmail?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ILogger get_Logger()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_Logger
    open func get_Logger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_ILogger__get_Logger_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Logger(Microsoft.Extensions.Logging.ILogger)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.set_Logger(Microsoft.Extensions.Logging.ILogger)
    open func set_Logger(value : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__set_Logger_0__1__ILogger(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IPasswordHasher<TUser> get_PasswordHasher()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_PasswordHasher
    open func get_PasswordHasher() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_Microsoft_AspNetCore_Identity_IPasswordHasher_TUser___get_PasswordHasher_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_PasswordHasher(Microsoft.AspNetCore.Identity.IPasswordHasher<TUser>)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.set_PasswordHasher(Microsoft.AspNetCore.Identity.IPasswordHasher{`0})
    open func set_PasswordHasher(value : aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1<TUser>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__set_PasswordHasher_0__1__Microsoft_AspNetCore_Identity_IPasswordHasher_TUser_(TUser.get_type_handle(), &__thrown, self.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.IUserValidator<TUser>> get_UserValidators()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_UserValidators
    open func get_UserValidators() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IUserValidator_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IUserValidator_TUser____get_UserValidators_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.IPasswordValidator<TUser>> get_PasswordValidators()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_PasswordValidators
    open func get_PasswordValidators() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordValidator_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IPasswordValidator_TUser____get_PasswordValidators_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.ILookupNormalizer get_KeyNormalizer()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_KeyNormalizer
    open func get_KeyNormalizer() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_ILookupNormalizer__get_KeyNormalizer_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_KeyNormalizer(Microsoft.AspNetCore.Identity.ILookupNormalizer)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.set_KeyNormalizer(Microsoft.AspNetCore.Identity.ILookupNormalizer)
    open func set_KeyNormalizer(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__set_KeyNormalizer_0__1__ILookupNormalizer(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_ErrorDescriber()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_ErrorDescriber
    open func get_ErrorDescriber() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_IdentityErrorDescriber__get_ErrorDescriber_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    open func set_ErrorDescriber(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__set_ErrorDescriber_0__1__IdentityErrorDescriber(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityOptions get_Options()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_Options
    open func get_Options() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_IdentityOptions__get_Options_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Options(Microsoft.AspNetCore.Identity.IdentityOptions)
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.set_Options(Microsoft.AspNetCore.Identity.IdentityOptions)
    open func set_Options(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserManager_1_void__set_Options_0__1__IdentityOptions(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_SupportsUserAuthenticationTokens()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserAuthenticationTokens
    open func get_SupportsUserAuthenticationTokens() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserAuthenticationTokens_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserAuthenticatorKey()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserAuthenticatorKey
    open func get_SupportsUserAuthenticatorKey() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserAuthenticatorKey_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserTwoFactorRecoveryCodes()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserTwoFactorRecoveryCodes
    open func get_SupportsUserTwoFactorRecoveryCodes() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserTwoFactorRecoveryCodes_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserTwoFactor()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserTwoFactor
    open func get_SupportsUserTwoFactor() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserTwoFactor_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserPassword()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserPassword
    open func get_SupportsUserPassword() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserPassword_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserSecurityStamp()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserSecurityStamp
    open func get_SupportsUserSecurityStamp() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserSecurityStamp_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserRole()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserRole
    open func get_SupportsUserRole() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserRole_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserLogin()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserLogin
    open func get_SupportsUserLogin() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserLogin_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserEmail()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserEmail
    open func get_SupportsUserEmail() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserEmail_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserPhoneNumber()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserPhoneNumber
    open func get_SupportsUserPhoneNumber() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserPhoneNumber_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserClaim()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserClaim
    open func get_SupportsUserClaim() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserClaim_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsUserLockout()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsUserLockout
    open func get_SupportsUserLockout() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsUserLockout_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_SupportsQueryableUsers()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_SupportsQueryableUsers
    open func get_SupportsQueryableUsers() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_bool__get_SupportsQueryableUsers_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Linq.IQueryable<TUser> get_Users()
// docid: M:Microsoft.AspNetCore.Identity.UserManager`1.get_Users
    open func get_Users() throws -> Optional<dotnet.System.Linq.IQueryable_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserManager_1_System_Linq_IQueryable_TUser___get_Users_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            The  used to generate error messages.
            

    */
    open var ErrorDescriber : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_ErrorDescriber();
        }
        set(v) {
            return try! set_ErrorDescriber(value: v!);
        }
    }
    /**
    
            The  used to normalize things like user and role names.
            

    */
    open var KeyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer> {
        get {
            return try! get_KeyNormalizer();
        }
        set(v) {
            return try! set_KeyNormalizer(value: v!);
        }
    }
    /**
    
            The  used to log messages from the manager.
            

    */
    open var Logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        get {
            return try! get_Logger();
        }
        set(v) {
            return try! set_Logger(value: v!);
        }
    }
    /**
    
            The  used to configure Identity.
            

    */
    open var Options : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        get {
            return try! get_Options();
        }
        set(v) {
            return try! set_Options(value: v!);
        }
    }
    /**
    
            The  used to hash passwords.
            

    */
    open var PasswordHasher : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1<TUser>> {
        get {
            return try! get_PasswordHasher();
        }
        set(v) {
            return try! set_PasswordHasher(value: v!);
        }
    }
    /**
    
            The  used to validate passwords.
            

    */
    open var PasswordValidators : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordValidator_1<TUser>>> {
        get {
            return try! get_PasswordValidators();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports returning
             collections of information.
            

    */
    open var SupportsQueryableUsers : Bool {
        get {
            return try! get_SupportsQueryableUsers();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports authentication tokens.
            

    */
    open var SupportsUserAuthenticationTokens : Bool {
        get {
            return try! get_SupportsUserAuthenticationTokens();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports a user authenticator.
            

    */
    open var SupportsUserAuthenticatorKey : Bool {
        get {
            return try! get_SupportsUserAuthenticatorKey();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user claims.
            

    */
    open var SupportsUserClaim : Bool {
        get {
            return try! get_SupportsUserClaim();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user emails.
            

    */
    open var SupportsUserEmail : Bool {
        get {
            return try! get_SupportsUserEmail();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user lock-outs.
            

    */
    open var SupportsUserLockout : Bool {
        get {
            return try! get_SupportsUserLockout();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports external logins.
            

    */
    open var SupportsUserLogin : Bool {
        get {
            return try! get_SupportsUserLogin();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user passwords.
            

    */
    open var SupportsUserPassword : Bool {
        get {
            return try! get_SupportsUserPassword();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user telephone numbers.
            

    */
    open var SupportsUserPhoneNumber : Bool {
        get {
            return try! get_SupportsUserPhoneNumber();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports user roles.
            

    */
    open var SupportsUserRole : Bool {
        get {
            return try! get_SupportsUserRole();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports security stamps.
            

    */
    open var SupportsUserSecurityStamp : Bool {
        get {
            return try! get_SupportsUserSecurityStamp();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports two factor authentication.
            

    */
    open var SupportsUserTwoFactor : Bool {
        get {
            return try! get_SupportsUserTwoFactor();
        }
    }
    /**
    
            Gets a flag indicating whether the backing user store supports recovery codes.
            

    */
    open var SupportsUserTwoFactorRecoveryCodes : Bool {
        get {
            return try! get_SupportsUserTwoFactorRecoveryCodes();
        }
    }
    /**
    
            The  used to validate users.
            

    */
    open var UserValidators : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.IUserValidator_1<TUser>>> {
        get {
            return try! get_UserValidators();
        }
    }
    /**
    
                Returns an IQueryable of users if the store is an IQueryableUserStore
            

    */
    open var Users : Optional<dotnet.System.Linq.IQueryable_1<TUser>> {
        get {
            return try! get_Users();
        }
    }
} // UserManager_1


// type: Microsoft.AspNetCore.Identity.UserOptions
    /**
    
            Options for user validation.
            

    */
open class UserOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.UserOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_AllowedUserNameCharacters()
// docid: M:Microsoft.AspNetCore.Identity.UserOptions.get_AllowedUserNameCharacters
    open func get_AllowedUserNameCharacters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserOptions_String__get_AllowedUserNameCharacters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AllowedUserNameCharacters(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserOptions.set_AllowedUserNameCharacters(System.String)
    open func set_AllowedUserNameCharacters(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserOptions_void__set_AllowedUserNameCharacters_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_RequireUniqueEmail()
// docid: M:Microsoft.AspNetCore.Identity.UserOptions.get_RequireUniqueEmail
    open func get_RequireUniqueEmail() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserOptions_bool__get_RequireUniqueEmail_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_RequireUniqueEmail(bool)
// docid: M:Microsoft.AspNetCore.Identity.UserOptions.set_RequireUniqueEmail(System.Boolean)
    open func set_RequireUniqueEmail(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserOptions_void__set_RequireUniqueEmail_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the list of allowed characters in the username used to validate user names. Defaults to abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+
            

    */
    open var AllowedUserNameCharacters : Optional<dotnet.System.String> {
        get {
            return try! get_AllowedUserNameCharacters();
        }
        set(v) {
            return try! set_AllowedUserNameCharacters(value: v!);
        }
    }
    /**
    
            Gets or sets a flag indicating whether the application requires unique emails for its users. Defaults to false.
            

    */
    open var RequireUniqueEmail : Bool {
        get {
            return try! get_RequireUniqueEmail();
        }
        set(v) {
            return try! set_RequireUniqueEmail(value: v);
        }
    }
} // UserOptions


// type: Microsoft.AspNetCore.Identity.UserValidator`1
    /**
    
            Provides validation services for user classes.
            

    */
open class UserValidator_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserValidator_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.UserValidator`1.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Creates a new instance of .
            

    - Parameter errors: The  used to provider error messages.
    */
    public init(errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserValidator_1_ctor_0__1__IdentityErrorDescriber(TUser.get_type_handle(), &__thrown, errors?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> ValidateAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.UserValidator`1.ValidateAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Validates the specified  as an asynchronous operation.
            

    - Parameter manager: The  that can be used to retrieve user properties.
    - Parameter user: The user to validate.
    - Returns: The  that represents the asynchronous operation, containing the  of the validation operation.

    */
    open func ValidateAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserValidator_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___ValidateAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_Describer()
// docid: M:Microsoft.AspNetCore.Identity.UserValidator`1.get_Describer
    open func get_Describer() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserValidator_1_IdentityErrorDescriber__get_Describer_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  used to provider error messages for the current .
            

    */
    open var Describer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_Describer();
        }
    }
} // UserValidator_1


}



// System
// System.Security
// System.Security.Claims
extension System.Security.Claims {
// type: System.Security.Claims.PrincipalExtensions
public struct PrincipalExtensions {
    // System.String FindFirstValue(System.Security.Claims.ClaimsPrincipal, System.String)
// docid: M:System.Security.Claims.PrincipalExtensions.FindFirstValue(System.Security.Claims.ClaimsPrincipal,System.String)
    /**
    
            Returns the value for the first claim of the specified type, otherwise null if the claim is not present.
            

    - Parameter principal: The  instance this method extends.
    - Parameter claimType: The claim type whose first value should be returned.
    - Returns: The value of the first instance of the specified claim type, or null if the claim is not present.

    */
    public static func FindFirstValue(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>, claimType : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Claims_PrincipalExtensions_String__FindFirstValue_0__2__ClaimsPrincipal_String(&__thrown, principal?.get_handle() ?? nil, claimType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // PrincipalExtensions


}



public protocol Microsoft_AspNetCore_Identity_ILookupNormalizer
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Identity_ILookupProtector
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Identity_ILookupProtectorKeyRing
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Identity_IPasswordHasher_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IPasswordHasher_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IPasswordValidator_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IPasswordValidator_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IPersonalDataProtector
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Identity_IProtectedUserStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IProtectedUserStore_1
{
    associatedtype TUser_IProtectedUserStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IQueryableRoleStore_1
    :
    Microsoft_AspNetCore_Identity_IRoleStore_1
    where
        TRole_IRoleStore_1 == TRole_IQueryableRoleStore_1
{
    associatedtype TRole_IQueryableRoleStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IQueryableUserStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IQueryableUserStore_1
{
    associatedtype TUser_IQueryableUserStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IRoleClaimStore_1
    :
    Microsoft_AspNetCore_Identity_IRoleStore_1
    where
        TRole_IRoleStore_1 == TRole_IRoleClaimStore_1
{
    associatedtype TRole_IRoleClaimStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IRoleStore_1
    :
    System_IDisposable
{
    associatedtype TRole_IRoleStore_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IRoleValidator_1
    :
    SGBridgeGetHandle
{
    associatedtype TRole_IRoleValidator_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IUserAuthenticationTokenStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserAuthenticationTokenStore_1
{
    associatedtype TUser_IUserAuthenticationTokenStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserAuthenticatorKeyStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserAuthenticatorKeyStore_1
{
    associatedtype TUser_IUserAuthenticatorKeyStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserClaimStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserClaimStore_1
{
    associatedtype TUser_IUserClaimStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IUserClaimsPrincipalFactory_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IUserConfirmation_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IUserConfirmation_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IUserEmailStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserEmailStore_1
{
    associatedtype TUser_IUserEmailStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserLockoutStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserLockoutStore_1
{
    associatedtype TUser_IUserLockoutStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserLoginStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserLoginStore_1
{
    associatedtype TUser_IUserLoginStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserPasswordStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserPasswordStore_1
{
    associatedtype TUser_IUserPasswordStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserPhoneNumberStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserPhoneNumberStore_1
{
    associatedtype TUser_IUserPhoneNumberStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserRoleStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserRoleStore_1
{
    associatedtype TUser_IUserRoleStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserSecurityStampStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserSecurityStampStore_1
{
    associatedtype TUser_IUserSecurityStampStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserStore_1
    :
    System_IDisposable
{
    associatedtype TUser_IUserStore_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IUserTwoFactorRecoveryCodeStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserTwoFactorRecoveryCodeStore_1
{
    associatedtype TUser_IUserTwoFactorRecoveryCodeStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserTwoFactorStore_1
    :
    Microsoft_AspNetCore_Identity_IUserStore_1
    where
        TUser_IUserStore_1 == TUser_IUserTwoFactorStore_1
{
    associatedtype TUser_IUserTwoFactorStore_1;
}

public protocol Microsoft_AspNetCore_Identity_IUserTwoFactorTokenProvider_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IUserTwoFactorTokenProvider_1 : SGBridgeGenericValue;
}

public protocol Microsoft_AspNetCore_Identity_IUserValidator_1
    :
    SGBridgeGetHandle
{
    associatedtype TUser_IUserValidator_1 : SGBridgeGenericValue;
}

// EXTENSION METHOD System.String FindFirstValue(System.Security.Claims.ClaimsPrincipal, System.String)
extension dotnet.System.Security.Claims.ClaimsPrincipal {
    public func FindFirstValue(claimType : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        return try aspnetcore.System.Security.Claims.PrincipalExtensions.FindFirstValue(principal: self, claimType: claimType);
    }
}

