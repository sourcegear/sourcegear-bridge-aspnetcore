// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.ActivatorUtilities
public struct ActivatorUtilities {
    // Microsoft.Extensions.DependencyInjection.ObjectFactory CreateFactory(System.Type, System.Type[])
// docid: M:Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateFactory(System.Type,System.Type[])
    /**
    
            Create a delegate that will instantiate a type with constructor arguments provided directly
            and/or from an .
            

    - Parameter instanceType: The type to activate
    - Parameter argumentTypes: 
            The types of objects, in order, that will be passed to the returned function as its second parameter
            
    - Returns: 
            A factory that will instantiate instanceType using an 
            and an argument array containing objects matching the types defined in argumentTypes
            

    */
    public static func CreateFactory(instanceType : dotnet.System.Type_, argumentTypes : dotnet.System_Arr<dotnet.System.Type_>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ObjectFactory {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ActivatorUtilities_ObjectFactory__CreateFactory_0__2__Type_TypeArray(&__thrown, instanceType.get_handle(), argumentTypes.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ObjectFactory(hndl : __return);
        }
    }
    // System.Object CreateInstance(System.IServiceProvider, System.Type, System.Object[])
// docid: M:Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance(System.IServiceProvider,System.Type,System.Object[])
    /**
    
            Instantiate a type with constructor arguments provided directly and/or from an .
            

    - Parameter provider: The service provider used to resolve dependencies
    - Parameter instanceType: The type to activate
    - Parameter parameters: Constructor arguments not provided by the .
    - Returns: An activated object of type instanceType

    */
    public static func CreateInstance(provider : dotnet.System.IServiceProvider, instanceType : dotnet.System.Type_, parameters : dotnet.System_Arr<dotnet.System.Object>) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ActivatorUtilities_Object__CreateInstance_0__3__IServiceProvider_Type_ObjectArray(&__thrown, provider.get_handle(), instanceType.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) T CreateInstance<T>(System.IServiceProvider, System.Object[])
    // System.Object GetServiceOrCreateInstance(System.IServiceProvider, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ActivatorUtilities.GetServiceOrCreateInstance(System.IServiceProvider,System.Type)
    /**
    
            Retrieve an instance of the given type from the service provider. If one is not found then instantiate it directly.
            

    - Parameter provider: The service provider
    - Parameter type: The type of the service
    - Returns: The resolved service or created instance

    */
    public static func GetServiceOrCreateInstance(provider : dotnet.System.IServiceProvider, type : dotnet.System.Type_) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ActivatorUtilities_Object__GetServiceOrCreateInstance_0__2__IServiceProvider_Type(&__thrown, provider.get_handle(), type.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) T GetServiceOrCreateInstance<T>(System.IServiceProvider)
} // ActivatorUtilities


// type: Microsoft.Extensions.DependencyInjection.ActivatorUtilitiesConstructorAttribute
    /**
    
            Marks the constructor to be used when activating type using .
            

    */
open class ActivatorUtilitiesConstructorAttribute
    :
    dotnet.System.Attribute
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ActivatorUtilitiesConstructorAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.DependencyInjection.ActivatorUtilitiesConstructorAttribute.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ActivatorUtilitiesConstructorAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ActivatorUtilitiesConstructorAttribute


// type: Microsoft.Extensions.DependencyInjection.AsyncServiceScope
// boxed value type
    /**
    
            An  implementation that implements .
            

    */
public final class AsyncServiceScope
    :
    dotnet.System.Object,
    Microsoft_Extensions_DependencyInjection_IServiceScope,
    System_IDisposable,
    System_IAsyncDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_AsyncServiceScope_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    */
    public var ServiceProvider : dotnet.System.IServiceProvider {
        get {
            return try! get_ServiceProvider();
        }
    }
    // .ctor(Microsoft.Extensions.DependencyInjection.IServiceScope)
// docid: M:Microsoft.Extensions.DependencyInjection.AsyncServiceScope.#ctor(Microsoft.Extensions.DependencyInjection.IServiceScope)
    /**
    
            Initializes a new instance of the  struct.
            Wraps an instance of .
            

    - Parameter serviceScope: The  instance to wrap.
    */
    public init(serviceScope : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_AsyncServiceScope_ctor_0__1__IServiceScope(&__thrown, serviceScope.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = Microsoft_Extensions_DependencyInjection_AsyncServiceScope_implicit_ctor();
            super.init(hndl: h);
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.DependencyInjection.AsyncServiceScope.Dispose
    /**
    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_AsyncServiceScope_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:Microsoft.Extensions.DependencyInjection.AsyncServiceScope.DisposeAsync
    /**
    */
    public func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_AsyncServiceScope_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ServiceProvider()
// docid: M:Microsoft.Extensions.DependencyInjection.AsyncServiceScope.get_ServiceProvider
    public func get_ServiceProvider() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_AsyncServiceScope_IServiceProvider__get_ServiceProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
} // AsyncServiceScope


// type: Microsoft.Extensions.DependencyInjection.IServiceCollection
    /**
    
            Specifies the contract for a collection of service descriptors.
            

    */
open class IServiceCollection
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServiceCollection
{
    public typealias T_ICollection_1 = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor;
    public typealias T_IEnumerable_1 = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor;
    public typealias T_IList_1 = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServiceCollection_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

} // IServiceCollection


// type: Microsoft.Extensions.DependencyInjection.IServiceProviderFactory`1
    /**
    
            Provides an extension point for creating a container specific builder and an .
            

    */
open class IServiceProviderFactory_1<TContainerBuilder : SGBridgeGenericValue>
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_1
{
    public typealias TContainerBuilder_IServiceProviderFactory_1 = TContainerBuilder;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_1_get_type_handle(TContainerBuilder.get_type_handle());
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // TContainerBuilder CreateBuilder(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.IServiceProviderFactory`1.CreateBuilder(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Creates a container builder from an .
            

    - Parameter services: The collection of services
    - Returns: A container builder that can be used to create an .

    */
    open func CreateBuilder(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection) throws -> TContainerBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_1_TContainerBuilder__CreateBuilder_0__1__IServiceCollection(TContainerBuilder.get_type_handle(), &__thrown, self.get_handle(), services.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TContainerBuilder(gval: __return);
        }
    }
    // System.IServiceProvider CreateServiceProvider(TContainerBuilder)
// docid: M:Microsoft.Extensions.DependencyInjection.IServiceProviderFactory`1.CreateServiceProvider(`0)
    /**
    
            Creates an  from the container builder.
            

    - Parameter containerBuilder: The container builder
    - Returns: An 

    */
    open func CreateServiceProvider(containerBuilder : TContainerBuilder) throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_1_IServiceProvider__CreateServiceProvider_0__1__TContainerBuilder(TContainerBuilder.get_type_handle(), &__thrown, self.get_handle(), containerBuilder.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
} // IServiceProviderFactory_1


// type: Microsoft.Extensions.DependencyInjection.IServiceProviderIsService
    /**
    
            Optional service used to determine if the specified type is available from the .
            

    */
open class IServiceProviderIsService
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServiceProviderIsService
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServiceProviderIsService_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // bool IsService(System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.IServiceProviderIsService.IsService(System.Type)
    /**
    
            Determines if the specified service type is available from the .
            

    - Parameter serviceType: An object that specifies the type of service object to test.
    - Returns: true if the specified service is a available, false if it is not.

    */
    open func IsService(serviceType : dotnet.System.Type_) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServiceProviderIsService_bool__IsService_0__1__Type(&__thrown, self.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IServiceProviderIsService


// type: Microsoft.Extensions.DependencyInjection.IServiceScope
    /**
    
            The  method ends the scope lifetime. Once Dispose
            is called, any scoped services that have been resolved from
             will be
            disposed.
            

    */
open class IServiceScope
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServiceScope,
    System_IDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServiceScope_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.IServiceProvider get_ServiceProvider()
// docid: M:Microsoft.Extensions.DependencyInjection.IServiceScope.get_ServiceProvider
    open func get_ServiceProvider() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServiceScope_IServiceProvider__get_ServiceProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
} // IServiceScope


// type: Microsoft.Extensions.DependencyInjection.IServiceScopeFactory
    /**
    
            A factory for creating instances of , which is used to create
            services within a scope.
            

    */
open class IServiceScopeFactory
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServiceScopeFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServiceScopeFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.Extensions.DependencyInjection.IServiceScope CreateScope()
// docid: M:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory.CreateScope
    /**
    
            Create an  which
            contains an  used to resolve dependencies from a
            newly created scope.
            

    - Returns: 
            An  controlling the
            lifetime of the scope. Once this is disposed, any scoped services that have been resolved
            from the 
            will also be disposed.
            

    */
    open func CreateScope() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServiceScopeFactory_IServiceScope__CreateScope_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope(hndl : __return);
        }
    }
} // IServiceScopeFactory


// type: Microsoft.Extensions.DependencyInjection.ISupportRequiredService
    /**
    
            Optional contract used by 
            to resolve services if supported by .
            

    */
open class ISupportRequiredService
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_ISupportRequiredService
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ISupportRequiredService_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Object GetRequiredService(System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ISupportRequiredService.GetRequiredService(System.Type)
    /**
    
            Gets service of type  from the  implementing
            this interface.
            

    - Parameter serviceType: An object that specifies the type of service object to get.
    - Returns: A service object of type .
            Throws an exception if the  cannot create the object.

    */
    open func GetRequiredService(serviceType : dotnet.System.Type_) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ISupportRequiredService_Object__GetRequiredService_0__1__Type(&__thrown, self.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
} // ISupportRequiredService


// type: Microsoft.Extensions.DependencyInjection.ObjectFactory
    /**
    
            The result of .
            

    */
public final class ObjectFactory
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ObjectFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Object Invoke(System.IServiceProvider, System.Object[])
// docid: M:Microsoft.Extensions.DependencyInjection.ObjectFactory.Invoke(System.IServiceProvider,System.Object[])
    public func Invoke(serviceProvider : dotnet.System.IServiceProvider, arguments : Optional<dotnet.System_Arr<dotnet.System.Object>>) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ObjectFactory_Object__Invoke_0__2__IServiceProvider_ObjectArray(&__thrown, self.get_handle(), serviceProvider.get_handle(), (arguments?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(System.IServiceProvider, System.Object[], System.AsyncCallback, System.Object)
// docid: M:Microsoft.Extensions.DependencyInjection.ObjectFactory.BeginInvoke(System.IServiceProvider,System.Object[],System.AsyncCallback,System.Object)
    public func BeginInvoke(serviceProvider : dotnet.System.IServiceProvider, arguments : Optional<dotnet.System_Arr<dotnet.System.Object>>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ObjectFactory_IAsyncResult__BeginInvoke_0__4__IServiceProvider_ObjectArray_AsyncCallback_Object(&__thrown, self.get_handle(), serviceProvider.get_handle(), (arguments?.get_handle()), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Object EndInvoke(System.IAsyncResult)
// docid: M:Microsoft.Extensions.DependencyInjection.ObjectFactory.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ObjectFactory_Object__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    public init(_ callback : @escaping (dotnet.System.IServiceProvider, Optional<dotnet.System_Arr<dotnet.System.Object>>) throws -> dotnet.System.Object) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, serviceProvider : NonnullHandle, arguments : NullableHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.IServiceProvider(hndl: serviceProvider), (arguments != nil) ? (dotnet.System_Arr(hndl: arguments!)) : nil);
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, serviceProvider : NonnullHandle, arguments : NullableHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle) -> NonnullHandle;
            return f(thrown, serviceProvider, arguments);
        }
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ObjectFactory_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Object Invoke(System.IServiceProvider, System.Object[])
// docid: M:Microsoft.Extensions.DependencyInjection.ObjectFactory.Invoke(System.IServiceProvider,System.Object[])
    public func callAsFunction(serviceProvider : dotnet.System.IServiceProvider, arguments : Optional<dotnet.System_Arr<dotnet.System.Object>>) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ObjectFactory_Object__Invoke_0__2__IServiceProvider_ObjectArray(&__thrown, self.get_handle(), serviceProvider.get_handle(), (arguments?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
} // ObjectFactory


// type: Microsoft.Extensions.DependencyInjection.ServiceCollection
    /**
    
            Default implementation of .
            

    */
open class ServiceCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ServiceCollection_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ServiceCollection_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Clear()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.Clear
    /**
    */
    open /* method final */ func Clear() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_ServiceCollection_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.Contains(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    */
    open /* method final */ func Contains(item : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_bool__Contains_0__1__ServiceDescriptor(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(Microsoft.Extensions.DependencyInjection.ServiceDescriptor[], System.Int32)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.CopyTo(Microsoft.Extensions.DependencyInjection.ServiceDescriptor[],System.Int32)
    /**
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_ServiceCollection_void__CopyTo_0__2__ServiceDescriptorArray_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.Generic.IEnumerator<Microsoft.Extensions.DependencyInjection.ServiceDescriptor> GetEnumerator()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.GetEnumerator
    /**
    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.Generic.IEnumerator_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_System_Collections_Generic_IEnumerator_Microsoft_Extensions_DependencyInjection_ServiceDescriptor___GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerator_1(hndl : __return);
        }
    }
    // System.Int32 IndexOf(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.IndexOf(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    */
    open /* method final */ func IndexOf(item : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_i32__IndexOf_0__1__ServiceDescriptor(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void Insert(System.Int32, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.Insert(System.Int32,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    */
    open /* method final */ func Insert(index : Swift.Int32, item : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_ServiceCollection_void__Insert_0__2__i32_ServiceDescriptor(&__thrown, self.get_handle(), index, item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Remove(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.Remove(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    */
    open /* method final */ func Remove(item : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_bool__Remove_0__1__ServiceDescriptor(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void RemoveAt(System.Int32)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.RemoveAt(System.Int32)
    /**
    */
    open /* method final */ func RemoveAt(index : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_ServiceCollection_void__RemoveAt_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.ServiceDescriptor get_Item(System.Int32)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.get_Item(System.Int32)
//BEGIN method_is_override
//matches_1
//matches :
    open /* method final */ func get_Item(index : Swift.Int32) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollection_ServiceDescriptor__get_Item_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Item(System.Int32, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollection.set_Item(System.Int32,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    open /* method final */ func set_Item(index : Swift.Int32, value : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_ServiceCollection_void__set_Item_0__2__i32_ServiceDescriptor(&__thrown, self.get_handle(), index, value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
} // ServiceCollection


// type: Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions
public struct ServiceCollectionServiceExtensions {
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds a scoped service of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register and the implementation to use.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddScoped(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddScoped_0__2__IServiceCollection_Type(&__thrown, services.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds a scoped service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddScoped(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddScoped_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, services.get_handle(), serviceType.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddScoped(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try AddScoped(services: services, serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds a scoped service of the type specified in  with an
            implementation of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddScoped(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddScoped_0__3__IServiceCollection_Type_Type(&__thrown, services.get_handle(), serviceType.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds a scoped service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddScoped<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddScoped_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddScoped<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try AddScoped(services: services, implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds a singleton service of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register and the implementation to use.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_0__2__IServiceCollection_Type(&__thrown, services.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds a singleton service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, services.get_handle(), serviceType.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddSingleton(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try AddSingleton(services: services, serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Object)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Object)
    /**
    
            Adds a singleton service of the type specified in  with an
            instance specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationInstance: The instance of the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationInstance : dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_0__3__IServiceCollection_Type_Object(&__thrown, services.get_handle(), serviceType.get_handle(), implementationInstance.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds a singleton service of the type specified in  with an
            implementation of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_0__3__IServiceCollection_Type_Type(&__thrown, services.get_handle(), serviceType.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds a singleton service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddSingleton<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try AddSingleton(services: services, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, TService)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0)
    /**
    
            Adds a singleton service of the type specified in  with an
            instance specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter implementationInstance: The instance of the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddSingleton<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationInstance : UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddSingleton_1__2__IServiceCollection_UTService(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationInstance.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds a transient service of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register and the implementation to use.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddTransient(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddTransient_0__2__IServiceCollection_Type(&__thrown, services.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds a transient service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddTransient(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddTransient_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, services.get_handle(), serviceType.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddTransient(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try AddTransient(services: services, serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds a transient service of the type specified in  with an
            implementation of the type specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter serviceType: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddTransient(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddTransient_0__3__IServiceCollection_Type_Type(&__thrown, services.get_handle(), serviceType.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds a transient service of the type specified in  with a
            factory specified in  to the
            specified .
            

    - Parameter services: The  to add the service to.
    - Parameter implementationFactory: The factory that creates the service.
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddTransient<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions_IServiceCollection__AddTransient_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddTransient<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try AddTransient(services: services, implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
} // ServiceCollectionServiceExtensions


// type: Microsoft.Extensions.DependencyInjection.ServiceDescriptor
    /**
    
            Describes a service with its service type, implementation, and lifetime.
            

    */
open class ServiceDescriptor
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ServiceDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Type, System.Func<System.IServiceProvider,System.Object>, Microsoft.Extensions.DependencyInjection.ServiceLifetime)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.#ctor(System.Type,System.Func{System.IServiceProvider,System.Object},Microsoft.Extensions.DependencyInjection.ServiceLifetime)
    /**
    
            Initializes a new instance of  with the specified .
            

    - Parameter serviceType: The  of the service.
    - Parameter factory: A factory used for creating service instances.
    - Parameter lifetime: The  of the service.
    */
    public init(serviceType : dotnet.System.Type_, factory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>, lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ctor_0__3__Type_System_Func_System_IServiceProvider_object__ServiceLifetime(&__thrown, serviceType.get_handle(), factory.get_handle(), lifetime.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Type, System.Object)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.#ctor(System.Type,System.Object)
    /**
    
            Initializes a new instance of  with the specified 
            as a .
            

    - Parameter serviceType: The  of the service.
    - Parameter instance: The instance implementing the service.
    */
    public init(serviceType : dotnet.System.Type_, instance : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ctor_0__2__Type_Object(&__thrown, serviceType.get_handle(), instance.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Type, System.Type, Microsoft.Extensions.DependencyInjection.ServiceLifetime)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.#ctor(System.Type,System.Type,Microsoft.Extensions.DependencyInjection.ServiceLifetime)
    /**
    
            Initializes a new instance of  with the specified .
            

    - Parameter serviceType: The  of the service.
    - Parameter implementationType: The  implementing the service.
    - Parameter lifetime: The  of the service.
    */
    public init(serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_, lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ctor_0__3__Type_Type_ServiceLifetime(&__thrown, serviceType.get_handle(), implementationType.get_handle(), lifetime.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Describe(System.Type, System.Func<System.IServiceProvider,System.Object>, Microsoft.Extensions.DependencyInjection.ServiceLifetime)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Describe(System.Type,System.Func{System.IServiceProvider,System.Object},Microsoft.Extensions.DependencyInjection.ServiceLifetime)
    /**
    
            Creates an instance of  with the specified
            , ,
            and .
            

    - Parameter serviceType: The type of the service.
    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Parameter lifetime: The lifetime of the service.
    - Returns: A new instance of .

    */
    open class func Describe(serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>, lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Describe_0__3__Type_System_Func_System_IServiceProvider_object__ServiceLifetime(&__thrown, serviceType.get_handle(), implementationFactory.get_handle(), lifetime.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Describe(serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object, lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try Describe(serviceType: serviceType, implementationFactory: del_implementationFactory, lifetime: lifetime);
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Describe(System.Type, System.Type, Microsoft.Extensions.DependencyInjection.ServiceLifetime)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Describe(System.Type,System.Type,Microsoft.Extensions.DependencyInjection.ServiceLifetime)
    /**
    
            Creates an instance of  with the specified
            , ,
            and .
            

    - Parameter serviceType: The type of the service.
    - Parameter implementationType: The type of the implementation.
    - Parameter lifetime: The lifetime of the service.
    - Returns: A new instance of .

    */
    open class func Describe(serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_, lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Describe_0__3__Type_Type_ServiceLifetime(&__thrown, serviceType.get_handle(), implementationType.get_handle(), lifetime.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Scoped(System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Scoped(System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter service: The type of the service.
    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Scoped(service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Scoped_0__2__Type_System_Func_System_IServiceProvider_object_(&__thrown, service.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Scoped(service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try Scoped(service: service, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Scoped(System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Scoped(System.Type,System.Type)
    /**
    
            Creates an instance of  with the specified
             and 
            and the  lifetime.
            

    - Parameter service: The type of the service.
    - Parameter implementationType: The type of the implementation.
    - Returns: A new instance of .

    */
    open class func Scoped(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Scoped_0__2__Type_Type(&__thrown, service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Scoped<TService>(System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Scoped``1(System.Func{System.IServiceProvider,``0})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Scoped<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Scoped_1__1__System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Scoped<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try Scoped(implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Scoped<TService, TImplementation>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Scoped<TService, TImplementation>(System.Func<System.IServiceProvider,TImplementation>)
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton(System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton(System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter serviceType: The type of the service.
    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Singleton(serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Singleton_0__2__Type_System_Func_System_IServiceProvider_object_(&__thrown, serviceType.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Singleton(serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try Singleton(serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton(System.Type, System.Object)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton(System.Type,System.Object)
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter serviceType: The type of the service.
    - Parameter implementationInstance: The instance of the implementation.
    - Returns: A new instance of .

    */
    open class func Singleton(serviceType : dotnet.System.Type_, implementationInstance : dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Singleton_0__2__Type_Object(&__thrown, serviceType.get_handle(), implementationInstance.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton(System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton(System.Type,System.Type)
    /**
    
            Creates an instance of  with the specified
             and 
            and the  lifetime.
            

    - Parameter service: The type of the service.
    - Parameter implementationType: The type of the implementation.
    - Returns: A new instance of .

    */
    open class func Singleton(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Singleton_0__2__Type_Type(&__thrown, service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton<TService>(System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton``1(System.Func{System.IServiceProvider,``0})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Singleton<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Singleton_1__1__System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Singleton<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try Singleton(implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton<TService>(TService)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Singleton``1(``0)
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter implementationInstance: The instance of the implementation.
    - Returns: A new instance of .

    */
    open class func Singleton<UTService : SGBridgeGenericValue>(implementationInstance : UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Singleton_1__1__UTService(UTService.get_type_handle(), &__thrown, implementationInstance.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton<TService, TImplementation>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Singleton<TService, TImplementation>(System.Func<System.IServiceProvider,TImplementation>)
    // System.String ToString()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Transient(System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Transient(System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter service: The type of the service.
    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Transient(service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Transient_0__2__Type_System_Func_System_IServiceProvider_object_(&__thrown, service.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Transient(service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try Transient(service: service, implementationFactory: del_implementationFactory);
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Transient(System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Transient(System.Type,System.Type)
    /**
    
            Creates an instance of  with the specified
             and 
            and the  lifetime.
            

    - Parameter service: The type of the service.
    - Parameter implementationType: The type of the implementation.
    - Returns: A new instance of .

    */
    open class func Transient(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Transient_0__2__Type_Type(&__thrown, service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.ServiceDescriptor Transient<TService>(System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.Transient``1(System.Func{System.IServiceProvider,``0})
    /**
    
            Creates an instance of  with the specified
            , ,
            and the  lifetime.
            

    - Parameter implementationFactory: A factory to create new instances of the service implementation.
    - Returns: A new instance of .

    */
    open class func Transient<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceDescriptor__Transient_1__1__System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Transient<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try Transient(implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Transient<TService, TImplementation>()
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.ServiceDescriptor Transient<TService, TImplementation>(System.Func<System.IServiceProvider,TImplementation>)
    // [IsSpecialName] System.Func<System.IServiceProvider,System.Object> get_ImplementationFactory()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.get_ImplementationFactory
    open func get_ImplementationFactory() throws -> Optional<dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_System_Func_System_IServiceProvider_object___get_ImplementationFactory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Object get_ImplementationInstance()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.get_ImplementationInstance
    open func get_ImplementationInstance() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_Object__get_ImplementationInstance_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Type get_ImplementationType()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.get_ImplementationType
    open func get_ImplementationType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_Type__get_ImplementationType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.ServiceLifetime get_Lifetime()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.get_Lifetime
    open func get_Lifetime() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_ServiceLifetime__get_Lifetime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime(val: __return);
        }
    }
    // [IsSpecialName] System.Type get_ServiceType()
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceDescriptor.get_ServiceType
    open func get_ServiceType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceDescriptor_Type__get_ServiceType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    open var ImplementationFactory : Optional<dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>> {
        get {
            return try! get_ImplementationFactory();
        }
    }
    open var ImplementationInstance : Optional<dotnet.System.Object> {
        get {
            return try! get_ImplementationInstance();
        }
    }
    open var ImplementationType : Optional<dotnet.System.Type_> {
        get {
            return try! get_ImplementationType();
        }
    }
    open var Lifetime : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime {
        get {
            return try! get_Lifetime();
        }
    }
    open var ServiceType : dotnet.System.Type_ {
        get {
            return try! get_ServiceType();
        }
    }
} // ServiceDescriptor


// type: Microsoft.Extensions.DependencyInjection.ServiceLifetime
    /**
    
            Specifies the lifetime of a service in an .
            

    */
public struct ServiceLifetime : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_ServiceLifetime_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.DependencyInjection.ServiceLifetime Singleton
    /**
    
            Specifies that a single instance of the service will be created.
            

    */
    public static var Singleton : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime {
        get {
        let __return = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime(val: Microsoft_Extensions_DependencyInjection_ServiceLifetime_get_Singleton());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.DependencyInjection.ServiceLifetime Scoped
    /**
    
            Specifies that a new instance of the service will be created for each scope.
            

    */
    public static var Scoped : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime {
        get {
        let __return = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime(val: Microsoft_Extensions_DependencyInjection_ServiceLifetime_get_Scoped());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.DependencyInjection.ServiceLifetime Transient
    /**
    
            Specifies that a new instance of the service will be created every time it is requested.
            

    */
    public static var Transient : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime {
        get {
        let __return = aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceLifetime(val: Microsoft_Extensions_DependencyInjection_ServiceLifetime_get_Transient());
            return __return;
        }
    }
} // ServiceLifetime


// type: Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions
public struct ServiceProviderServiceExtensions {
    // Microsoft.Extensions.DependencyInjection.AsyncServiceScope CreateAsyncScope(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateAsyncScope(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory)
    /**
    
            Creates a new  that can be used to resolve scoped services.
            

    - Parameter serviceScopeFactory: The  to create the scope from.
    - Returns: An  that can be used to resolve scoped services.

    */
    public static func CreateAsyncScope(serviceScopeFactory : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScopeFactory) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceProviderServiceExtensions_AsyncServiceScope__CreateAsyncScope_0__1__IServiceScopeFactory(&__thrown, serviceScopeFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.AsyncServiceScope CreateAsyncScope(System.IServiceProvider)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateAsyncScope(System.IServiceProvider)
    /**
    
            Creates a new  that can be used to resolve scoped services.
            

    - Parameter provider: The  to create the scope from.
    - Returns: An  that can be used to resolve scoped services.

    */
    public static func CreateAsyncScope(provider : dotnet.System.IServiceProvider) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceProviderServiceExtensions_AsyncServiceScope__CreateAsyncScope_0__1__IServiceProvider(&__thrown, provider.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceScope CreateScope(System.IServiceProvider)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateScope(System.IServiceProvider)
    /**
    
            Creates a new  that can be used to resolve scoped services.
            

    - Parameter provider: The  to create the scope from.
    - Returns: A  that can be used to resolve scoped services.

    */
    public static func CreateScope(provider : dotnet.System.IServiceProvider) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceProviderServiceExtensions_IServiceScope__CreateScope_0__1__IServiceProvider(&__thrown, provider.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope(hndl : __return);
        }
    }
    // System.Object GetRequiredService(System.IServiceProvider, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(System.IServiceProvider,System.Type)
    /**
    
            Get service of type  from the .
            

    - Parameter provider: The  to retrieve the service object from.
    - Parameter serviceType: An object that specifies the type of service object to get.
    - Returns: A service object of type .

    */
    public static func GetRequiredService(provider : dotnet.System.IServiceProvider, serviceType : dotnet.System.Type_) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceProviderServiceExtensions_Object__GetRequiredService_0__2__IServiceProvider_Type(&__thrown, provider.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) T GetRequiredService<T>(System.IServiceProvider)
    // System.Collections.Generic.IEnumerable<System.Object> GetServices(System.IServiceProvider, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetServices(System.IServiceProvider,System.Type)
    /**
    
            Get an enumeration of services of type  from the .
            

    - Parameter provider: The  to retrieve the services from.
    - Parameter serviceType: An object that specifies the type of service object to get.
    - Returns: An enumeration of services of type .

    */
    public static func GetServices(provider : dotnet.System.IServiceProvider, serviceType : dotnet.System.Type_) throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServiceProviderServiceExtensions_System_Collections_Generic_IEnumerable_object___GetServices_0__2__IServiceProvider_Type(&__thrown, provider.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) System.Collections.Generic.IEnumerable<T> GetServices<T>(System.IServiceProvider)
// TODO COPE (write_all_methods) (unused generic param) T GetService<T>(System.IServiceProvider)
} // ServiceProviderServiceExtensions


}
// Microsoft.Extensions.DependencyInjection.Extensions
extension Microsoft.Extensions.DependencyInjection.Extensions {
// type: Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions
public struct ServiceCollectionDescriptorExtensions {
    // Microsoft.Extensions.DependencyInjection.IServiceCollection Add(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Add(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    
            Adds the specified  to the .
            

    - Parameter collection: The .
    - Parameter descriptor: The  to add.
    - Returns: A reference to the current instance of .

    */
    public static func Add(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_IServiceCollection__Add_0__2__IServiceCollection_ServiceDescriptor(&__thrown, collection.get_handle(), descriptor.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection Add(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Add(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{Microsoft.Extensions.DependencyInjection.ServiceDescriptor})
    /**
    
            Adds a sequence of  to the .
            

    - Parameter collection: The .
    - Parameter descriptors: The s to add.
    - Returns: A reference to the current instance of .

    */
    public static func Add(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_IServiceCollection__Add_0__2__IServiceCollection_System_Collections_Generic_IEnumerable_Microsoft_Extensions_DependencyInjection_ServiceDescriptor_(&__thrown, collection.get_handle(), descriptors.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection RemoveAll(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.RemoveAll(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Removes all services of type  in .
            

    - Parameter collection: The .
    - Parameter serviceType: The service type to remove.
    - Returns: The  for chaining.

    */
    public static func RemoveAll(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_IServiceCollection__RemoveAll_0__2__IServiceCollection_Type(&__thrown, collection.get_handle(), serviceType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection RemoveAll<T>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // Microsoft.Extensions.DependencyInjection.IServiceCollection Replace(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Replace(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    
            Removes the first service in  with the same service type
            as  and adds  to the collection.
            

    - Parameter collection: The .
    - Parameter descriptor: The  to replace with.
    - Returns: The  for chaining.

    */
    public static func Replace(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_IServiceCollection__Replace_0__2__IServiceCollection_ServiceDescriptor(&__thrown, collection.get_handle(), descriptor.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // void TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    
            Adds the specified  to the  if the
            service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter descriptor: The  to add.
    */
    public static func TryAdd(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAdd_0__2__IServiceCollection_ServiceDescriptor(&__thrown, collection.get_handle(), descriptor.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{Microsoft.Extensions.DependencyInjection.ServiceDescriptor})
    /**
    
            Adds the specified  to the  if the
            service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter descriptors: The s to add.
    */
    public static func TryAdd(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAdd_0__2__IServiceCollection_System_Collections_Generic_IEnumerable_Microsoft_Extensions_DependencyInjection_ServiceDescriptor_(&__thrown, collection.get_handle(), descriptors.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
    /**
    
            Adds a  if an existing descriptor with the same
             and an implementation that does not already exist
            in .
            

    - Parameter services: The .
    - Parameter descriptor: The .
    */
    public static func TryAddEnumerable(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddEnumerable_0__2__IServiceCollection_ServiceDescriptor(&__thrown, services.get_handle(), descriptor.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Collections.Generic.IEnumerable{Microsoft.Extensions.DependencyInjection.ServiceDescriptor})
    /**
    
            Adds the specified s if an existing descriptor with the same
             and an implementation that does not already exist
            in .
            

    - Parameter services: The .
    - Parameter descriptors: The s.
    */
    public static func TryAddEnumerable(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddEnumerable_0__2__IServiceCollection_System_Collections_Generic_IEnumerable_Microsoft_Extensions_DependencyInjection_ServiceDescriptor_(&__thrown, services.get_handle(), descriptors.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds the specified  as a  service
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    */
    public static func TryAddScoped(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddScoped_0__2__IServiceCollection_Type(&__thrown, collection.get_handle(), service.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddScoped(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddScoped_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, collection.get_handle(), service.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddScoped(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try TryAddScoped(collection: collection, service: service, implementationFactory: del_implementationFactory);
    }
    // void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds the specified  as a  service
            with the  implementation
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    */
    public static func TryAddScoped(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddScoped_0__3__IServiceCollection_Type_Type(&__thrown, collection.get_handle(), service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // void TryAddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter services: The .
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddScoped<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddScoped_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddScoped<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try TryAddScoped(services: services, implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds the specified  as a  service
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    */
    public static func TryAddSingleton(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddSingleton_0__2__IServiceCollection_Type(&__thrown, collection.get_handle(), service.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddSingleton(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddSingleton_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, collection.get_handle(), service.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddSingleton(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try TryAddSingleton(collection: collection, service: service, implementationFactory: del_implementationFactory);
    }
    // void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds the specified  as a  service
            with the  implementation
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    */
    public static func TryAddSingleton(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddSingleton_0__3__IServiceCollection_Type_Type(&__thrown, collection.get_handle(), service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter services: The .
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddSingleton<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddSingleton_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddSingleton<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try TryAddSingleton(services: services, implementationFactory: del_implementationFactory);
    }
    // void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, TService)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,``0)
    /**
    
            Adds the specified  as a  service
            with an instance specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter instance: The instance of the service to add.
    */
    public static func TryAddSingleton<UTService : SGBridgeGenericValue>(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, instance : UTService) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddSingleton_1__2__IServiceCollection_UTService(UTService.get_type_handle(), &__thrown, collection.get_handle(), instance.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)
    /**
    
            Adds the specified  as a  service
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    */
    public static func TryAddTransient(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddTransient_0__2__IServiceCollection_Type(&__thrown, collection.get_handle(), service.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Func{System.IServiceProvider,System.Object})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddTransient(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddTransient_0__3__IServiceCollection_Type_System_Func_System_IServiceProvider_object_(&__thrown, collection.get_handle(), service.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddTransient(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try TryAddTransient(collection: collection, service: service, implementationFactory: del_implementationFactory);
    }
    // void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type,System.Type)
    /**
    
            Adds the specified  as a  service
            with the  implementation
            to the  if the service type hasn't already been registered.
            

    - Parameter collection: The .
    - Parameter service: The type of the service to register.
    - Parameter implementationType: The implementation type of the service.
    */
    public static func TryAddTransient(collection : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddTransient_0__3__IServiceCollection_Type_Type(&__thrown, collection.get_handle(), service.get_handle(), implementationType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    // void TryAddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
// docid: M:Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``0})
    /**
    
            Adds the specified  as a  service
            using the factory specified in 
            to the  if the service type hasn't already been registered.
            

    - Parameter services: The .
    - Parameter implementationFactory: The factory that creates the service.
    */
    public static func TryAddTransient<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_DependencyInjection_Extensions_ServiceCollectionDescriptorExtensions_void__TryAddTransient_1__2__IServiceCollection_System_Func_System_IServiceProvider_UTService_(UTService.get_type_handle(), &__thrown, services.get_handle(), implementationFactory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func TryAddTransient<UTService : SGBridgeGenericValue>(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try TryAddTransient(services: services, implementationFactory: del_implementationFactory);
    }
// TODO COPE (write_all_methods) (unused generic param) void TryAddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
} // ServiceCollectionDescriptorExtensions


}




public protocol Microsoft_Extensions_DependencyInjection_IServiceCollection
    :
    System_Collections_Generic_IList_1
    where
        T_IList_1 == aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor
{
}

public protocol Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_1
    :
    SGBridgeGetHandle
{
    associatedtype TContainerBuilder_IServiceProviderFactory_1 : SGBridgeGenericValue;
}

public protocol Microsoft_Extensions_DependencyInjection_IServiceProviderIsService
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_DependencyInjection_IServiceScope
    :
    System_IDisposable
{
}

public protocol Microsoft_Extensions_DependencyInjection_IServiceScopeFactory
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_DependencyInjection_ISupportRequiredService
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection Add(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func Add(descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Add(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptor: descriptor);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection Add(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func Add(descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Add(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptors: descriptors);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection RemoveAll(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func RemoveAll(serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.RemoveAll(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection RemoveAll<T>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection RemoveAll<T>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection Replace(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func Replace(descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.Replace(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptor: descriptor);
    }
}

// EXTENSION METHOD void TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAdd(descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAdd(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptor: descriptor);
    }
}

// EXTENSION METHOD void TryAdd(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAdd(descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAdd(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptors: descriptors);
    }
}

// EXTENSION METHOD void TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection, Microsoft.Extensions.DependencyInjection.ServiceDescriptor)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddEnumerable(descriptor : aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddEnumerable(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptor: descriptor);
    }
}

// EXTENSION METHOD void TryAddEnumerable(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Collections.Generic.IEnumerable<Microsoft.Extensions.DependencyInjection.ServiceDescriptor>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddEnumerable(descriptors : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceDescriptor>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddEnumerable(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), descriptors: descriptors);
    }
}

// EXTENSION METHOD void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddScoped(service : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service);
    }
}

// EXTENSION METHOD void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddScoped(service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddScoped(service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddScoped(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationType: implementationType);
    }
}

// EXTENSION METHOD void TryAddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD void TryAddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddScoped<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddScoped<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddSingleton(service : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service);
    }
}

// EXTENSION METHOD void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddSingleton(service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddSingleton(service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddSingleton(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationType: implementationType);
    }
}

// EXTENSION METHOD void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddSingleton<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddSingleton<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, TService)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddSingleton<UTService : SGBridgeGenericValue>(instance : UTService) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddSingleton(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), instance: instance);
    }
}

// EXTENSION METHOD void TryAddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddTransient(service : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service);
    }
}

// EXTENSION METHOD void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddTransient(service : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddTransient(service : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddTransient(service : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(collection: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), service: service, implementationType: implementationType);
    }
}

// EXTENSION METHOD void TryAddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD void TryAddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func TryAddTransient<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws {
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func TryAddTransient<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        try aspnetcore.Microsoft.Extensions.DependencyInjection.Extensions.ServiceCollectionDescriptorExtensions.TryAddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD void TryAddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) void TryAddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddScoped(serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddScoped(serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddScoped(serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddScoped(serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationType: implementationType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddScoped<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddScoped<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddScoped(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddScoped<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton(serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton(serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddSingleton(serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Object)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton(serviceType : dotnet.System.Type_, implementationInstance : dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationInstance: implementationInstance);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton(serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationType: implementationType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddSingleton<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, TService)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddSingleton<UTService : SGBridgeGenericValue>(implementationInstance : UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationInstance: implementationInstance);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddSingleton<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddTransient(serviceType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Func<System.IServiceProvider,System.Object>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddTransient(serviceType : dotnet.System.Type_, implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddTransient(serviceType : dotnet.System.Type_, implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> dotnet.System.Object) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,dotnet.System.Object>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Type, System.Type)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddTransient(serviceType : dotnet.System.Type_, implementationType : dotnet.System.Type_) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), serviceType: serviceType, implementationType: implementationType);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TService>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddTransient<UTService : SGBridgeGenericValue>(implementationFactory : dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: implementationFactory);
    }
    // delegate closure overload
    public func AddTransient<UTService : SGBridgeGenericValue>(implementationFactory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> UTService) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_implementationFactory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,UTService>(implementationFactory);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), implementationFactory: del_implementationFactory);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransient<TService, TImplementation>(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Func<System.IServiceProvider,TImplementation>)

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.AsyncServiceScope CreateAsyncScope(Microsoft.Extensions.DependencyInjection.IServiceScopeFactory)
extension Microsoft_Extensions_DependencyInjection_IServiceScopeFactory {
    public func CreateAsyncScope() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateAsyncScope(serviceScopeFactory: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScopeFactory(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.AsyncServiceScope CreateAsyncScope(System.IServiceProvider)
extension System_IServiceProvider {
    public func CreateAsyncScope() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.AsyncServiceScope {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateAsyncScope(provider: dotnet.System.IServiceProvider(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceScope CreateScope(System.IServiceProvider)
extension System_IServiceProvider {
    public func CreateScope() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceScope {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateScope(provider: dotnet.System.IServiceProvider(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD System.Object GetRequiredService(System.IServiceProvider, System.Type)
extension System_IServiceProvider {
    public func GetRequiredService(serviceType : dotnet.System.Type_) throws -> dotnet.System.Object {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(provider: dotnet.System.IServiceProvider(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD T GetRequiredService<T>(System.IServiceProvider)
// TODO COPE extension method (unused generic param) T GetRequiredService<T>(System.IServiceProvider)

// EXTENSION METHOD System.Collections.Generic.IEnumerable<System.Object> GetServices(System.IServiceProvider, System.Type)
extension System_IServiceProvider {
    public func GetServices(serviceType : dotnet.System.Type_) throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Object> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetServices(provider: dotnet.System.IServiceProvider(hndl: __copy_handle(self.get_handle())), serviceType: serviceType);
    }
}

// EXTENSION METHOD System.Collections.Generic.IEnumerable<T> GetServices<T>(System.IServiceProvider)
// TODO COPE extension method (unused generic param) System.Collections.Generic.IEnumerable<T> GetServices<T>(System.IServiceProvider)

// EXTENSION METHOD T GetService<T>(System.IServiceProvider)
// TODO COPE extension method (unused generic param) T GetService<T>(System.IServiceProvider)

