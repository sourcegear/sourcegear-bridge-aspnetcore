// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.Caching
// Microsoft.Extensions.Caching.Distributed
extension Microsoft.Extensions.Caching.Distributed {
// type: Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions
public struct DistributedCacheEntryExtensions {
    // Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.DateTimeOffset)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.DateTimeOffset)
    /**
    
            Sets an absolute expiration date for the cache entry.
            

    - Parameter options: The options to be operated on.
    - Parameter absolute: The expiration time, in absolute terms.
    */
    public static func SetAbsoluteExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryExtensions_DistributedCacheEntryOptions__SetAbsoluteExpiration_0__2__DistributedCacheEntryOptions_DateTimeOffset(&__thrown, options?.get_handle() ?? nil, absolute.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.TimeSpan)
    /**
    
            Sets an absolute expiration time, relative to now.
            

    - Parameter options: The options to be operated on.
    - Parameter relative: The expiration time, relative to now.
    */
    public static func SetAbsoluteExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryExtensions_DistributedCacheEntryOptions__SetAbsoluteExpiration_0__2__DistributedCacheEntryOptions_TimeSpan(&__thrown, options?.get_handle() ?? nil, relative.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetSlidingExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetSlidingExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.TimeSpan)
    /**
    
            Sets how long the cache entry can be inactive (e.g. not accessed) before it will be removed.
            This will not extend the entry lifetime beyond the absolute expiration (if set).
            

    - Parameter options: The options to be operated on.
    - Parameter offset: The sliding expiration time.
    */
    public static func SetSlidingExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryExtensions_DistributedCacheEntryOptions__SetSlidingExpiration_0__2__DistributedCacheEntryOptions_TimeSpan(&__thrown, options?.get_handle() ?? nil, offset.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DistributedCacheEntryExtensions


// type: Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions
    /**
    
            Provides the cache options for an entry in .
            

    */
open class DistributedCacheEntryOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.DateTimeOffset> get_AbsoluteExpiration()
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.get_AbsoluteExpiration
    open func get_AbsoluteExpiration() throws -> Optional<dotnet.System.DateTimeOffset> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_System_Nullable_System_DateTimeOffset___get_AbsoluteExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.DateTimeOffset(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpiration(System.Nullable<System.DateTimeOffset>)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.set_AbsoluteExpiration(System.Nullable{System.DateTimeOffset})
    open func set_AbsoluteExpiration(value : Optional<dotnet.System.DateTimeOffset>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_void__set_AbsoluteExpiration_0__1__System_Nullable_System_DateTimeOffset_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_AbsoluteExpirationRelativeToNow()
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.get_AbsoluteExpirationRelativeToNow
    open func get_AbsoluteExpirationRelativeToNow() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_System_Nullable_System_TimeSpan___get_AbsoluteExpirationRelativeToNow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpirationRelativeToNow(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.set_AbsoluteExpirationRelativeToNow(System.Nullable{System.TimeSpan})
    open func set_AbsoluteExpirationRelativeToNow(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_void__set_AbsoluteExpirationRelativeToNow_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_SlidingExpiration()
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.get_SlidingExpiration
    open func get_SlidingExpiration() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_System_Nullable_System_TimeSpan___get_SlidingExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_SlidingExpiration(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions.set_SlidingExpiration(System.Nullable{System.TimeSpan})
    open func set_SlidingExpiration(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheEntryOptions_void__set_SlidingExpiration_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets an absolute expiration date for the cache entry.
            

    */
    open var AbsoluteExpiration : Optional<dotnet.System.DateTimeOffset> {
        get {
            return try! get_AbsoluteExpiration();
        }
        set(v) {
            return try! set_AbsoluteExpiration(value: v!);
        }
    }
    /**
    
            Gets or sets an absolute expiration time, relative to now.
            

    */
    open var AbsoluteExpirationRelativeToNow : Optional<dotnet.System.TimeSpan> {
        get {
            return try! get_AbsoluteExpirationRelativeToNow();
        }
        set(v) {
            return try! set_AbsoluteExpirationRelativeToNow(value: v!);
        }
    }
    /**
    
            Gets or sets how long a cache entry can be inactive (e.g. not accessed) before it will be removed.
            This will not extend the entry lifetime beyond the absolute expiration (if set).
            

    */
    open var SlidingExpiration : Optional<dotnet.System.TimeSpan> {
        get {
            return try! get_SlidingExpiration();
        }
        set(v) {
            return try! set_SlidingExpiration(value: v!);
        }
    }
} // DistributedCacheEntryOptions


// type: Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions
public struct DistributedCacheExtensions {
    // System.String GetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.GetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String)
    /**
    
            Gets a string from the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to get the stored data for.
    - Returns: The string value from the stored cache key.

    */
    public static func GetString(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_String__GetString_0__2__IDistributedCache_String(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.GetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.Threading.CancellationToken)
    /**
    
            Asynchronously gets a string from the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to get the stored data for.
    - Parameter token: Optional. A  to cancel the operation.
    - Returns: A task that gets the string value from the stored cache key.

    */
    public static func GetStringAsync(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_System_Threading_Tasks_Task_string___GetStringAsync_0__3__IDistributedCache_String_CancellationToken(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Set(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Byte[])
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.Set(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.Byte[])
    /**
    
            Sets a sequence of bytes in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    */
    public static func Set(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_void__Set_0__3__IDistributedCache_String_u8Array(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task SetAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Byte[], System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.Byte[],System.Threading.CancellationToken)
    /**
    
            Asynchronously sets a sequence of bytes in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    - Parameter token: Optional. A  to cancel the operation.
    - Returns: A task that represents the asynchronous set operation.

    */
    public static func SetAsync(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_Task__SetAsync_0__4__IDistributedCache_String_u8Array_CancellationToken(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, (value?.get_handle()), token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.String)
    /**
    
            Sets a string in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    */
    public static func SetString(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_void__SetString_0__3__IDistributedCache_String_String(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.String,Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
    /**
    
            Sets a string in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    - Parameter options: The cache options for the entry.
    */
    public static func SetString(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_void__SetString_0__4__IDistributedCache_String_String_DistributedCacheEntryOptions(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value?.get_handle() ?? nil, options?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.String,Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.Threading.CancellationToken)
    /**
    
            Asynchronously sets a string in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    - Parameter options: The cache options for the entry.
    - Parameter token: Optional. A  to cancel the operation.
    - Returns: A task that represents the asynchronous set operation.

    */
    public static func SetStringAsync(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_Task__SetStringAsync_0__5__IDistributedCache_String_String_DistributedCacheEntryOptions_CancellationToken(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value?.get_handle() ?? nil, options?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Asynchronously sets a string in the specified cache with the specified key.
            

    - Parameter cache: The cache in which to store the data.
    - Parameter key: The key to store the data in.
    - Parameter value: The data to store in the cache.
    - Parameter token: Optional. A  to cancel the operation.
    - Returns: A task that represents the asynchronous set operation.

    */
    public static func SetStringAsync(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache>, key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_DistributedCacheExtensions_Task__SetStringAsync_0__4__IDistributedCache_String_String_CancellationToken(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DistributedCacheExtensions


// type: Microsoft.Extensions.Caching.Distributed.IDistributedCache
    /**
    
            Represents a distributed cache of serialized values.
            

    */
open class IDistributedCache
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_Caching_Distributed_IDistributedCache
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Distributed_IDistributedCache_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Distributed_IDistributedCache_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // System.Byte[] Get(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.Get(System.String)
    /**
    
            Gets a value with the given key.
            

    - Parameter key: A string identifying the requested value.
    - Returns: The located value or null.

    */
    open func Get(key : Optional<dotnet.System.String>) throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_IDistributedCache_u8Array__Get_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Byte[]> GetAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.GetAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Gets a value with the given key.
            

    - Parameter key: A string identifying the requested value.
    - Parameter token: Optional. The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the located value or null.

    */
    open func GetAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System_Arr<Swift.UInt8>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_IDistributedCache_System_Threading_Tasks_Task_u8Array___GetAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Refresh(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.Refresh(System.String)
    /**
    
            Refreshes a value in the cache based on its key, resetting its sliding expiration timeout (if any).
            

    - Parameter key: A string identifying the requested value.
    */
    open func Refresh(key : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_IDistributedCache_void__Refresh_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task RefreshAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.RefreshAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Refreshes a value in the cache based on its key, resetting its sliding expiration timeout (if any).
            

    - Parameter key: A string identifying the requested value.
    - Parameter token: Optional. The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RefreshAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_IDistributedCache_Task__RefreshAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Remove(System.String)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.Remove(System.String)
    /**
    
            Removes the value with the given key.
            

    - Parameter key: A string identifying the requested value.
    */
    open func Remove(key : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_IDistributedCache_void__Remove_0__1__String(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task RemoveAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.RemoveAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Removes the value with the given key.
            

    - Parameter key: A string identifying the requested value.
    - Parameter token: Optional. The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_IDistributedCache_Task__RemoveAsync_0__2__String_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Set(System.String, System.Byte[], Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.Set(System.String,System.Byte[],Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
    /**
    
            Sets a value with the given key.
            

    - Parameter key: A string identifying the requested value.
    - Parameter value: The value to set in the cache.
    - Parameter options: The cache options for the value.
    */
    open func Set(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Distributed_IDistributedCache_void__Set_0__3__String_u8Array_DistributedCacheEntryOptions(&__thrown, self.get_handle(), key?.get_handle() ?? nil, (value?.get_handle()), options?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task SetAsync(System.String, System.Byte[], Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Caching.Distributed.IDistributedCache.SetAsync(System.String,System.Byte[],Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions,System.Threading.CancellationToken)
    /**
    
            Sets the value with the given key.
            

    - Parameter key: A string identifying the requested value.
    - Parameter value: The value to set in the cache.
    - Parameter options: The cache options for the value.
    - Parameter token: Optional. The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetAsync(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Distributed_IDistributedCache_Task__SetAsync_0__4__String_u8Array_DistributedCacheEntryOptions_CancellationToken(&__thrown, self.get_handle(), key?.get_handle() ?? nil, (value?.get_handle()), options?.get_handle() ?? nil, token.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IDistributedCache


}

// Microsoft.Extensions.Caching.Memory
extension Microsoft.Extensions.Caching.Memory {
// type: Microsoft.Extensions.Caching.Memory.CacheEntryExtensions
public struct CacheEntryExtensions {
    // Microsoft.Extensions.Caching.Memory.ICacheEntry AddExpirationToken(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Primitives.IChangeToken)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.AddExpirationToken(Microsoft.Extensions.Caching.Memory.ICacheEntry,Microsoft.Extensions.Primitives.IChangeToken)
    /**
    
            Expire the cache entry if the given  expires.
            

    - Parameter entry: The .
    - Parameter expirationToken: The  that causes the cache entry to expire.
    - Returns: The  for chaining.

    */
    public static func AddExpirationToken(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__AddExpirationToken_0__2__ICacheEntry_IChangeToken(&__thrown, entry?.get_handle() ?? nil, expirationToken?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry,Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
    /**
    
            The given callback will be fired after the cache entry is evicted from the cache.
            

    - Parameter entry: The .
    - Parameter callback: The callback to run after the entry is evicted.
    - Returns: The  for chaining.

    */
    public static func RegisterPostEvictionCallback(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__RegisterPostEvictionCallback_0__2__ICacheEntry_PostEvictionDelegate(&__thrown, entry?.get_handle() ?? nil, callback?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func RegisterPostEvictionCallback(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try RegisterPostEvictionCallback(entry: entry, callback: del_callback);
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry,Microsoft.Extensions.Caching.Memory.PostEvictionDelegate,System.Object)
    /**
    
            The given callback will be fired after the cache entry is evicted from the cache.
            

    - Parameter entry: The .
    - Parameter callback: The callback to run after the entry is evicted.
    - Parameter state: The state to pass to the post-eviction callback.
    - Returns: The  for chaining.

    */
    public static func RegisterPostEvictionCallback(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__RegisterPostEvictionCallback_0__3__ICacheEntry_PostEvictionDelegate_Object(&__thrown, entry?.get_handle() ?? nil, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func RegisterPostEvictionCallback(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try RegisterPostEvictionCallback(entry: entry, callback: del_callback, state: state);
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.DateTimeOffset)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry,System.DateTimeOffset)
    /**
    
            Sets an absolute expiration date for the cache entry.
            

    - Parameter entry: The .
    - Parameter absolute: A  representing the expiration time in absolute terms.
    - Returns: The  for chaining.

    */
    public static func SetAbsoluteExpiration(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetAbsoluteExpiration_0__2__ICacheEntry_DateTimeOffset(&__thrown, entry?.get_handle() ?? nil, absolute.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry,System.TimeSpan)
    /**
    
            Sets an absolute expiration time, relative to now.
            

    - Parameter entry: The .
    - Parameter relative: The  representing the expiration time relative to now.
    - Returns: The  for chaining.

    */
    public static func SetAbsoluteExpiration(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetAbsoluteExpiration_0__2__ICacheEntry_TimeSpan(&__thrown, entry?.get_handle() ?? nil, relative.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetOptions(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetOptions(Microsoft.Extensions.Caching.Memory.ICacheEntry,Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
    /**
    
            Applies the values of an existing  to the entry.
            

    - Parameter entry: The .
    - Parameter options: Set the values of these options on the .
    - Returns: The  for chaining.

    */
    public static func SetOptions(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetOptions_0__2__ICacheEntry_MemoryCacheEntryOptions(&__thrown, entry?.get_handle() ?? nil, options?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetPriority(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.CacheItemPriority)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetPriority(Microsoft.Extensions.Caching.Memory.ICacheEntry,Microsoft.Extensions.Caching.Memory.CacheItemPriority)
    /**
    
            Sets the priority for keeping the cache entry in the cache during a memory pressure tokened cleanup.
            

    - Parameter entry: The entry to set the priority for.
    - Parameter priority: The  to set on the entry.
    - Returns: The  for chaining.

    */
    public static func SetPriority(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, priority : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetPriority_0__2__ICacheEntry_CacheItemPriority(&__thrown, entry?.get_handle() ?? nil, priority.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetSize(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.Int64)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetSize(Microsoft.Extensions.Caching.Memory.ICacheEntry,System.Int64)
    /**
    
            Sets the size of the cache entry value.
            

    - Parameter entry: The .
    - Parameter size: The size to set on the .
    - Returns: The  for chaining.

    */
    public static func SetSize(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, size : Swift.Int64) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetSize_0__2__ICacheEntry_i64(&__thrown, entry?.get_handle() ?? nil, size);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry,System.TimeSpan)
    /**
    
            Sets how long the cache entry can be inactive (e.g. not accessed) before it will be removed.
            This will not extend the entry lifetime beyond the absolute expiration (if set).
            

    - Parameter entry: The .
    - Parameter offset: A  representing a sliding expiration.
    - Returns: The  for chaining.

    */
    public static func SetSlidingExpiration(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetSlidingExpiration_0__2__ICacheEntry_TimeSpan(&__thrown, entry?.get_handle() ?? nil, offset.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry SetValue(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetValue(Microsoft.Extensions.Caching.Memory.ICacheEntry,System.Object)
    /**
    
            Sets the value of the cache entry.
            

    - Parameter entry: The .
    - Parameter value: The value to set on the .
    - Returns: The  for chaining.

    */
    public static func SetValue(entry : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>, value : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheEntryExtensions_ICacheEntry__SetValue_0__2__ICacheEntry_Object(&__thrown, entry?.get_handle() ?? nil, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // CacheEntryExtensions


// type: Microsoft.Extensions.Caching.Memory.CacheExtensions
public struct CacheExtensions {
    // System.Object Get(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object)
    public static func Get(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_Object__Get_0__2__IMemoryCache_Object(&__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TItem> GetOrCreateAsync<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, System.Func<Microsoft.Extensions.Caching.Memory.ICacheEntry,System.Threading.Tasks.Task<TItem>>)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,System.Func{Microsoft.Extensions.Caching.Memory.ICacheEntry,System.Threading.Tasks.Task{``0}})
    public static func GetOrCreateAsync<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, factory : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,dotnet.System.Threading.Tasks.Task_1<UTItem>>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<UTItem>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_System_Threading_Tasks_Task_UTItem___GetOrCreateAsync_1__3__IMemoryCache_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_System_Threading_Tasks_Task_UTItem__(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, (factory?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func GetOrCreateAsync<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, factory : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>) throws -> dotnet.System.Threading.Tasks.Task_1<UTItem>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<UTItem>> {
        let del_factory = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,dotnet.System.Threading.Tasks.Task_1<UTItem>>(factory);
        return try GetOrCreateAsync(cache: cache, key: key, factory: del_factory);
    }
    // TItem GetOrCreate<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, System.Func<Microsoft.Extensions.Caching.Memory.ICacheEntry,TItem>)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,System.Func{Microsoft.Extensions.Caching.Memory.ICacheEntry,``0})
    public static func GetOrCreate<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, factory : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,UTItem>>) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__GetOrCreate_1__3__IMemoryCache_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_UTItem_(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, (factory?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
    // delegate closure overload
    public static func GetOrCreate<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, factory : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>) throws -> UTItem) throws -> UTItem {
        let del_factory = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,UTItem>(factory);
        return try GetOrCreate(cache: cache, key: key, factory: del_factory);
    }
// TODO COPE (write_all_methods) (unused generic param) TItem Get<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object)
    // TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Set``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,``0)
    public static func Set<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, value : UTItem) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__Set_1__3__IMemoryCache_Object_UTItem(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
    // TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Set``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,``0,Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
    public static func Set<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, value : UTItem, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__Set_1__4__IMemoryCache_Object_UTItem_MemoryCacheEntryOptions(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value.to_gval(), options?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
    // TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, Microsoft.Extensions.Primitives.IChangeToken)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Set``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,``0,Microsoft.Extensions.Primitives.IChangeToken)
    public static func Set<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, value : UTItem, expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__Set_1__4__IMemoryCache_Object_UTItem_IChangeToken(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value.to_gval(), expirationToken?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
    // TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, System.DateTimeOffset)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Set``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,``0,System.DateTimeOffset)
    public static func Set<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, value : UTItem, absoluteExpiration : dotnet.System.DateTimeOffset) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__Set_1__4__IMemoryCache_Object_UTItem_DateTimeOffset(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value.to_gval(), absoluteExpiration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
    // TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Memory.CacheExtensions.Set``1(Microsoft.Extensions.Caching.Memory.IMemoryCache,System.Object,``0,System.TimeSpan)
    public static func Set<UTItem : SGBridgeGenericValue>(cache : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache>, key : Optional<dotnet.System.Object>, value : UTItem, absoluteExpirationRelativeToNow : dotnet.System.TimeSpan) throws -> UTItem {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_CacheExtensions_UTItem__Set_1__4__IMemoryCache_Object_UTItem_TimeSpan(UTItem.get_type_handle(), &__thrown, cache?.get_handle() ?? nil, key?.get_handle() ?? nil, value.to_gval(), absoluteExpirationRelativeToNow.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UTItem(gval: __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) bool TryGetValue<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, ref TItem)
} // CacheExtensions


// type: Microsoft.Extensions.Caching.Memory.CacheItemPriority
    /**
    
            Specifies how items are prioritized for preservation during a memory pressure triggered cleanup.
            

    */
public struct CacheItemPriority : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_CacheItemPriority_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.Caching.Memory.CacheItemPriority Low
    public static var Low : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: Microsoft_Extensions_Caching_Memory_CacheItemPriority_get_Low());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.CacheItemPriority Normal
    public static var Normal : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: Microsoft_Extensions_Caching_Memory_CacheItemPriority_get_Normal());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.CacheItemPriority High
    public static var High : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: Microsoft_Extensions_Caching_Memory_CacheItemPriority_get_High());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.CacheItemPriority NeverRemove
    public static var NeverRemove : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: Microsoft_Extensions_Caching_Memory_CacheItemPriority_get_NeverRemove());
            return __return;
        }
    }
} // CacheItemPriority


// type: Microsoft.Extensions.Caching.Memory.EvictionReason
public struct EvictionReason : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_EvictionReason_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason None
    public static var None : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_None());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason Removed
    /**
    
            Manually
            

    */
    public static var Removed : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_Removed());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason Replaced
    /**
    
            Overwritten
            

    */
    public static var Replaced : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_Replaced());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason Expired
    /**
    
            Timed out
            

    */
    public static var Expired : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_Expired());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason TokenExpired
    /**
    
            Event
            

    */
    public static var TokenExpired : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_TokenExpired());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Caching.Memory.EvictionReason Capacity
    /**
    
            Overflow
            

    */
    public static var Capacity : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: Microsoft_Extensions_Caching_Memory_EvictionReason_get_Capacity());
            return __return;
        }
    }
} // EvictionReason


// type: Microsoft.Extensions.Caching.Memory.ICacheEntry
    /**
    
            Represents an entry in the  implementation.
            

    */
open class ICacheEntry
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_Caching_Memory_ICacheEntry,
    System_IDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_ICacheEntry_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Memory_ICacheEntry_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] System.Nullable<System.DateTimeOffset> get_AbsoluteExpiration()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_AbsoluteExpiration
    open func get_AbsoluteExpiration() throws -> Optional<dotnet.System.DateTimeOffset> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Nullable_System_DateTimeOffset___get_AbsoluteExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.DateTimeOffset(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpiration(System.Nullable<System.DateTimeOffset>)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_AbsoluteExpiration(System.Nullable{System.DateTimeOffset})
    open func set_AbsoluteExpiration(value : Optional<dotnet.System.DateTimeOffset>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_AbsoluteExpiration_0__1__System_Nullable_System_DateTimeOffset_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_AbsoluteExpirationRelativeToNow()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_AbsoluteExpirationRelativeToNow
    open func get_AbsoluteExpirationRelativeToNow() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Nullable_System_TimeSpan___get_AbsoluteExpirationRelativeToNow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpirationRelativeToNow(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_AbsoluteExpirationRelativeToNow(System.Nullable{System.TimeSpan})
    open func set_AbsoluteExpirationRelativeToNow(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_AbsoluteExpirationRelativeToNow_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.Primitives.IChangeToken> get_ExpirationTokens()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_ExpirationTokens
    open func get_ExpirationTokens() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Collections_Generic_IList_Microsoft_Extensions_Primitives_IChangeToken___get_ExpirationTokens_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Object get_Key()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_Key
    open func get_Key() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_Object__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration> get_PostEvictionCallbacks()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_PostEvictionCallbacks
    open func get_PostEvictionCallbacks() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Collections_Generic_IList_Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration___get_PostEvictionCallbacks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Caching.Memory.CacheItemPriority get_Priority()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_Priority
    open func get_Priority() throws -> aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_CacheItemPriority__get_Priority_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: __return);
        }
    }
    // [IsSpecialName] void set_Priority(Microsoft.Extensions.Caching.Memory.CacheItemPriority)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_Priority(Microsoft.Extensions.Caching.Memory.CacheItemPriority)
    open func set_Priority(value : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_Priority_0__1__CacheItemPriority(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_Size()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_Size
    open func get_Size() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Nullable_i64___get_Size_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_Size(System.Nullable<System.Int64>)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_Size(System.Nullable{System.Int64})
    open func set_Size(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_Size_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_SlidingExpiration()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_SlidingExpiration
    open func get_SlidingExpiration() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Nullable_System_TimeSpan___get_SlidingExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_SlidingExpiration(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_SlidingExpiration(System.Nullable{System.TimeSpan})
    open func set_SlidingExpiration(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_SlidingExpiration_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Object get_Value()
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.get_Value
    open func get_Value() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_ICacheEntry_Object__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Value(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.ICacheEntry.set_Value(System.Object)
    open func set_Value(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_ICacheEntry_void__set_Value_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ICacheEntry


// type: Microsoft.Extensions.Caching.Memory.IMemoryCache
    /**
    
            Represents a local in-memory cache whose values are not serialized.
            

    */
open class IMemoryCache
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_Caching_Memory_IMemoryCache,
    System_IDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_IMemoryCache_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Memory_IMemoryCache_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // Microsoft.Extensions.Caching.Memory.ICacheEntry CreateEntry(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.IMemoryCache.CreateEntry(System.Object)
    /**
    
            Create or overwrite an entry in the cache.
            

    - Parameter key: An object identifying the entry.
    - Returns: The newly created  instance.

    */
    open func CreateEntry(key : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_IMemoryCache_ICacheEntry__CreateEntry_0__1__Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Remove(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.IMemoryCache.Remove(System.Object)
    /**
    
            Removes the object associated with the given key.
            

    - Parameter key: An object identifying the entry.
    */
    open func Remove(key : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_IMemoryCache_void__Remove_0__1__Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryGetValue(System.Object, ref System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.IMemoryCache.TryGetValue(System.Object,System.Object@)
    /**
    
            Gets the item associated with this key if present.
            

    - Parameter key: An object identifying the requested entry.
    - Parameter value: The located value or null.
    - Returns: True if the key was found.

    */
    open func TryGetValue(key : Optional<dotnet.System.Object>, value : inout Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_value = (value != nil) ? (value!.get_handle()) : nil;
        let __return = Microsoft_Extensions_Caching_Memory_IMemoryCache_bool__TryGetValue_0__2__Object_outObject(&__thrown, self.get_handle(), key?.get_handle() ?? nil, &_tmp_out_value);
        let __h__tmp2_value = _tmp_out_value;
        let _tmp2_value = (__h__tmp2_value != nil) ? dotnet.System.Object(hndl: __h__tmp2_value!) : nil;
            value = _tmp2_value;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IMemoryCache


// type: Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions
public struct MemoryCacheEntryExtensions {
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions AddExpirationToken(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Primitives.IChangeToken)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.AddExpirationToken(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,Microsoft.Extensions.Primitives.IChangeToken)
    /**
    
            Expire the cache entry if the given  expires.
            

    - Parameter options: The .
    - Parameter expirationToken: The  that causes the cache entry to expire.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddExpirationToken(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__AddExpirationToken_0__2__MemoryCacheEntryOptions_IChangeToken(&__thrown, options?.get_handle() ?? nil, expirationToken?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
    /**
    
            The given callback will be fired after the cache entry is evicted from the cache.
            

    - Parameter options: The .
    - Parameter callback: The callback to register for calling after an entry is evicted.
    - Returns: The  so that additional calls can be chained.

    */
    public static func RegisterPostEvictionCallback(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__RegisterPostEvictionCallback_0__2__MemoryCacheEntryOptions_PostEvictionDelegate(&__thrown, options?.get_handle() ?? nil, callback?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func RegisterPostEvictionCallback(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try RegisterPostEvictionCallback(options: options, callback: del_callback);
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,Microsoft.Extensions.Caching.Memory.PostEvictionDelegate,System.Object)
    /**
    
            The given callback will be fired after the cache entry is evicted from the cache.
            

    - Parameter options: The .
    - Parameter callback: The callback to register for calling after an entry is evicted.
    - Parameter state: The state to pass to the callback.
    - Returns: The  so that additional calls can be chained.

    */
    public static func RegisterPostEvictionCallback(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__RegisterPostEvictionCallback_0__3__MemoryCacheEntryOptions_PostEvictionDelegate_Object(&__thrown, options?.get_handle() ?? nil, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func RegisterPostEvictionCallback(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try RegisterPostEvictionCallback(options: options, callback: del_callback, state: state);
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.DateTimeOffset)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,System.DateTimeOffset)
    /**
    
            Sets an absolute expiration date for the cache entry.
            

    - Parameter options: The .
    - Parameter absolute: The expiration time, in absolute terms.
    - Returns: The  so that additional calls can be chained.

    */
    public static func SetAbsoluteExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__SetAbsoluteExpiration_0__2__MemoryCacheEntryOptions_DateTimeOffset(&__thrown, options?.get_handle() ?? nil, absolute.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,System.TimeSpan)
    /**
    
            Sets an absolute expiration time, relative to now.
            

    - Parameter options: The .
    - Parameter relative: The expiration time, relative to now.
    - Returns: The  so that additional calls can be chained.

    */
    public static func SetAbsoluteExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__SetAbsoluteExpiration_0__2__MemoryCacheEntryOptions_TimeSpan(&__thrown, options?.get_handle() ?? nil, relative.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetPriority(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.CacheItemPriority)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetPriority(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,Microsoft.Extensions.Caching.Memory.CacheItemPriority)
    /**
    
            Sets the priority for keeping the cache entry in the cache during a memory pressure tokened cleanup.
            

    - Parameter options: The option on which to set the priority.
    - Parameter priority: The  to set on the option.
    - Returns: The  so that additional calls can be chained.

    */
    public static func SetPriority(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, priority : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__SetPriority_0__2__MemoryCacheEntryOptions_CacheItemPriority(&__thrown, options?.get_handle() ?? nil, priority.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetSize(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.Int64)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,System.Int64)
    /**
    
            Sets the size of the cache entry value.
            

    - Parameter options: The options to set the entry size on.
    - Parameter size: The size to set on the .
    - Returns: The  so that additional calls can be chained.

    */
    public static func SetSize(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, size : Swift.Int64) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__SetSize_0__2__MemoryCacheEntryOptions_i64(&__thrown, options?.get_handle() ?? nil, size);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.TimeSpan)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions,System.TimeSpan)
    /**
    
            Sets how long the cache entry can be inactive (e.g. not accessed) before it will be removed.
            This will not extend the entry lifetime beyond the absolute expiration (if set).
            

    - Parameter options: The .
    - Parameter offset: The sliding expiration time.
    - Returns: The  so that additional calls can be chained.

    */
    public static func SetSlidingExpiration(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>, offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_MemoryCacheEntryOptions__SetSlidingExpiration_0__2__MemoryCacheEntryOptions_TimeSpan(&__thrown, options?.get_handle() ?? nil, offset.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // MemoryCacheEntryExtensions


// type: Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions
    /**
    
            Represents the cache options applied to an entry of the  instance.
            

    */
open class MemoryCacheEntryOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.DateTimeOffset> get_AbsoluteExpiration()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_AbsoluteExpiration
    open func get_AbsoluteExpiration() throws -> Optional<dotnet.System.DateTimeOffset> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Nullable_System_DateTimeOffset___get_AbsoluteExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.DateTimeOffset(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpiration(System.Nullable<System.DateTimeOffset>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.set_AbsoluteExpiration(System.Nullable{System.DateTimeOffset})
    open func set_AbsoluteExpiration(value : Optional<dotnet.System.DateTimeOffset>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_void__set_AbsoluteExpiration_0__1__System_Nullable_System_DateTimeOffset_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_AbsoluteExpirationRelativeToNow()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_AbsoluteExpirationRelativeToNow
    open func get_AbsoluteExpirationRelativeToNow() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Nullable_System_TimeSpan___get_AbsoluteExpirationRelativeToNow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_AbsoluteExpirationRelativeToNow(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.set_AbsoluteExpirationRelativeToNow(System.Nullable{System.TimeSpan})
    open func set_AbsoluteExpirationRelativeToNow(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_void__set_AbsoluteExpirationRelativeToNow_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.Primitives.IChangeToken> get_ExpirationTokens()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_ExpirationTokens
    open func get_ExpirationTokens() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Collections_Generic_IList_Microsoft_Extensions_Primitives_IChangeToken___get_ExpirationTokens_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration> get_PostEvictionCallbacks()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_PostEvictionCallbacks
    open func get_PostEvictionCallbacks() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Collections_Generic_IList_Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration___get_PostEvictionCallbacks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Caching.Memory.CacheItemPriority get_Priority()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_Priority
    open func get_Priority() throws -> aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_CacheItemPriority__get_Priority_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority(val: __return);
        }
    }
    // [IsSpecialName] void set_Priority(Microsoft.Extensions.Caching.Memory.CacheItemPriority)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.set_Priority(Microsoft.Extensions.Caching.Memory.CacheItemPriority)
    open func set_Priority(value : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_void__set_Priority_0__1__CacheItemPriority(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_Size()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_Size
    open func get_Size() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Nullable_i64___get_Size_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_Size(System.Nullable<System.Int64>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.set_Size(System.Nullable{System.Int64})
    open func set_Size(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_void__set_Size_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_SlidingExpiration()
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.get_SlidingExpiration
    open func get_SlidingExpiration() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Nullable_System_TimeSpan___get_SlidingExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_SlidingExpiration(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.set_SlidingExpiration(System.Nullable{System.TimeSpan})
    open func set_SlidingExpiration(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_void__set_SlidingExpiration_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets an absolute expiration date for the cache entry.
            

    */
    open var AbsoluteExpiration : Optional<dotnet.System.DateTimeOffset> {
        get {
            return try! get_AbsoluteExpiration();
        }
        set(v) {
            return try! set_AbsoluteExpiration(value: v!);
        }
    }
    /**
    
            Gets or sets an absolute expiration time, relative to now.
            

    */
    open var AbsoluteExpirationRelativeToNow : Optional<dotnet.System.TimeSpan> {
        get {
            return try! get_AbsoluteExpirationRelativeToNow();
        }
        set(v) {
            return try! set_AbsoluteExpirationRelativeToNow(value: v!);
        }
    }
    /**
    
            Gets the  instances which cause the cache entry to expire.
            

    */
    open var ExpirationTokens : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>> {
        get {
            return try! get_ExpirationTokens();
        }
    }
    /**
    
            Gets or sets the callbacks will be fired after the cache entry is evicted from the cache.
            

    */
    open var PostEvictionCallbacks : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration>> {
        get {
            return try! get_PostEvictionCallbacks();
        }
    }
    /**
    
            Gets or sets the priority for keeping the cache entry in the cache during a
            memory pressure triggered cleanup. The default is .
            

    */
    open var Priority : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority {
        get {
            return try! get_Priority();
        }
        set(v) {
            return try! set_Priority(value: v);
        }
    }
    /**
    
            Gets or sets the size of the cache entry value.
            

    */
    open var Size : Optional<Swift.Int64> {
        get {
            return try! get_Size();
        }
        set(v) {
            return try! set_Size(value: v!);
        }
    }
    /**
    
            Gets or sets how long a cache entry can be inactive (e.g. not accessed) before it will be removed.
            This will not extend the entry lifetime beyond the absolute expiration (if set).
            

    */
    open var SlidingExpiration : Optional<dotnet.System.TimeSpan> {
        get {
            return try! get_SlidingExpiration();
        }
        set(v) {
            return try! set_SlidingExpiration(value: v!);
        }
    }
} // MemoryCacheEntryOptions


// type: Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration
open class PostEvictionCallbackRegistration
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Caching.Memory.PostEvictionDelegate get_EvictionCallback()
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration.get_EvictionCallback
    open func get_EvictionCallback() throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_PostEvictionDelegate__get_EvictionCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EvictionCallback(Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration.set_EvictionCallback(Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
    open func set_EvictionCallback(value : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_void__set_EvictionCallback_0__1__PostEvictionDelegate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_EvictionCallback(value : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws {
        let del_value = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(value);
        return try set_EvictionCallback(value: del_value);
    }
    // [IsSpecialName] System.Object get_State()
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration.get_State
    open func get_State() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_Object__get_State_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_State(System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionCallbackRegistration.set_State(System.Object)
    open func set_State(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_PostEvictionCallbackRegistration_void__set_State_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    open var EvictionCallback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate> {
        get {
            return try! get_EvictionCallback();
        }
        set(v) {
            return try! set_EvictionCallback(value: v!);
        }
    }
    open var State : Optional<dotnet.System.Object> {
        get {
            return try! get_State();
        }
        set(v) {
            return try! set_State(value: v!);
        }
    }
} // PostEvictionCallbackRegistration


// type: Microsoft.Extensions.Caching.Memory.PostEvictionDelegate
    /**
    
            Signature of the callback which gets called when a cache entry expires.
            

    */
public final class PostEvictionDelegate
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object, System.Object, Microsoft.Extensions.Caching.Memory.EvictionReason, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionDelegate.Invoke(System.Object,System.Object,Microsoft.Extensions.Caching.Memory.EvictionReason,System.Object)
    public func Invoke(key : Optional<dotnet.System.Object>, value : Optional<dotnet.System.Object>, reason : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_void__Invoke_0__4__Object_Object_EvictionReason_Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil, value?.get_handle() ?? nil, reason.get_value(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.Object, Microsoft.Extensions.Caching.Memory.EvictionReason, System.Object, System.AsyncCallback, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionDelegate.BeginInvoke(System.Object,System.Object,Microsoft.Extensions.Caching.Memory.EvictionReason,System.Object,System.AsyncCallback,System.Object)
    public func BeginInvoke(key : Optional<dotnet.System.Object>, value : Optional<dotnet.System.Object>, reason : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, state : Optional<dotnet.System.Object>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_IAsyncResult__BeginInvoke_0__6__Object_Object_EvictionReason_Object_AsyncCallback_Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil, value?.get_handle() ?? nil, reason.get_value(), state?.get_handle() ?? nil, callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionDelegate.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public convenience init(_ __closure_Invoke : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws
    {
        let __interlude_Invoke : (UnsafeMutablePointer<NullableHandle>, NullableHandle, NullableHandle, Swift.Int32, NullableHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, key : NullableHandle, value : NullableHandle, reason : Swift.Int32, state : NullableHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try __closure_Invoke((key != nil) ? (dotnet.System.Object(hndl: key!)) : nil, (value != nil) ? (dotnet.System.Object(hndl: value!)) : nil, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason(val: reason), (state != nil) ? (dotnet.System.Object(hndl: state!)) : nil);
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        func __cb_Invoke(pdata_interlude : UnsafeRawPointer, thrown : UnsafeMutablePointer<NullableHandle>, key : NullableHandle, value : NullableHandle, reason : Swift.Int32, state : NullableHandle) -> Void
        {
            let f_interlude = Unmanaged<AnyObject>.fromOpaque(pdata_interlude).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle, NullableHandle, Swift.Int32, NullableHandle) -> Void;
            f_interlude(thrown, key, value, reason, state);
        }
        let __pdata_Invoke = UnsafeRawPointer(Unmanaged.passRetained(__interlude_Invoke as AnyObject).toOpaque());

        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_create(
            &__thrown,
            __cb_Invoke,
            __pdata_Invoke,
            nil
            );
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h);
        }
    }
    // void Invoke(System.Object, System.Object, Microsoft.Extensions.Caching.Memory.EvictionReason, System.Object)
// docid: M:Microsoft.Extensions.Caching.Memory.PostEvictionDelegate.Invoke(System.Object,System.Object,Microsoft.Extensions.Caching.Memory.EvictionReason,System.Object)
    public func callAsFunction(key : Optional<dotnet.System.Object>, value : Optional<dotnet.System.Object>, reason : aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Caching_Memory_PostEvictionDelegate_void__Invoke_0__4__Object_Object_EvictionReason_Object(&__thrown, self.get_handle(), key?.get_handle() ?? nil, value?.get_handle() ?? nil, reason.get_value(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // PostEvictionDelegate


}


// Microsoft.Extensions.Internal
extension Microsoft.Extensions.Internal {
// type: Microsoft.Extensions.Internal.ISystemClock
    /**
    
            Abstracts the system clock to facilitate testing.
            

    */
open class ISystemClock
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_Internal_ISystemClock
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Internal_ISystemClock_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Internal_ISystemClock_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_UtcNow()
// docid: M:Microsoft.Extensions.Internal.ISystemClock.get_UtcNow
    open func get_UtcNow() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Internal_ISystemClock_DateTimeOffset__get_UtcNow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
} // ISystemClock


// type: Microsoft.Extensions.Internal.SystemClock
    /**
    
            Provides access to the normal system clock.
            

    */
open class SystemClock
    :
    dotnet.System.Object,
    Microsoft_Extensions_Internal_ISystemClock
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Internal_SystemClock_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Internal_SystemClock_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Internal.SystemClock.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Internal_SystemClock_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_UtcNow()
// docid: M:Microsoft.Extensions.Internal.SystemClock.get_UtcNow
    open /* method final */ func get_UtcNow() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Internal_SystemClock_DateTimeOffset__get_UtcNow_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    /**
    
            Retrieves the current system time in UTC.
            

    */
    public var UtcNow : dotnet.System.DateTimeOffset {
        get {
            return try! get_UtcNow();
        }
    }
} // SystemClock


}



public protocol Microsoft_Extensions_Caching_Distributed_IDistributedCache
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_Caching_Memory_ICacheEntry
    :
    System_IDisposable
{
}

public protocol Microsoft_Extensions_Caching_Memory_IMemoryCache
    :
    System_IDisposable
{
}

public protocol Microsoft_Extensions_Internal_ISystemClock
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.DateTimeOffset)
extension aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions {
    public func SetAbsoluteExpiration(absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetAbsoluteExpiration(options: self, absolute: absolute);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.TimeSpan)
extension aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions {
    public func SetAbsoluteExpiration(relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetAbsoluteExpiration(options: self, relative: relative);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions SetSlidingExpiration(Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.TimeSpan)
extension aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions {
    public func SetSlidingExpiration(offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryExtensions.SetSlidingExpiration(options: self, offset: offset);
    }
}

// EXTENSION METHOD System.String GetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func GetString(key : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.String> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.GetString(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task<System.String> GetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Threading.CancellationToken)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func GetStringAsync(key : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.GetStringAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, token: token);
    }
}

// EXTENSION METHOD void Set(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Byte[])
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func Set(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task SetAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.Byte[], System.Threading.CancellationToken)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func SetAsync(key : Optional<dotnet.System.String>, value : Optional<dotnet.System_Arr<Swift.UInt8>>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, token: token);
    }
}

// EXTENSION METHOD void SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func SetString(key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>) throws {
        try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetString(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value);
    }
}

// EXTENSION METHOD void SetString(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func SetString(key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>) throws {
        try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetString(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, options: options);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions, System.Threading.CancellationToken)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func SetStringAsync(key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetStringAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, options: options, token: token);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task SetStringAsync(Microsoft.Extensions.Caching.Distributed.IDistributedCache, System.String, System.String, System.Threading.CancellationToken)
extension Microsoft_Extensions_Caching_Distributed_IDistributedCache {
    public func SetStringAsync(key : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, token : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        return try aspnetcore.Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions.SetStringAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Distributed.IDistributedCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, token: token);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry AddExpirationToken(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Primitives.IChangeToken)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func AddExpirationToken(expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.AddExpirationToken(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), expirationToken: expirationToken);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func RegisterPostEvictionCallback(callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), callback: callback);
    }
    // delegate closure overload
    public func RegisterPostEvictionCallback(callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), callback: del_callback);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate, System.Object)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func RegisterPostEvictionCallback(callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), callback: callback, state: state);
    }
    // delegate closure overload
    public func RegisterPostEvictionCallback(callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.RegisterPostEvictionCallback(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), callback: del_callback, state: state);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.DateTimeOffset)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetAbsoluteExpiration(absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetAbsoluteExpiration(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), absolute: absolute);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.TimeSpan)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetAbsoluteExpiration(relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetAbsoluteExpiration(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), relative: relative);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetOptions(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetOptions(options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetOptions(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), options: options);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetPriority(Microsoft.Extensions.Caching.Memory.ICacheEntry, Microsoft.Extensions.Caching.Memory.CacheItemPriority)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetPriority(priority : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetPriority(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), priority: priority);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetSize(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.Int64)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetSize(size : Swift.Int64) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetSize(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), size: size);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.TimeSpan)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetSlidingExpiration(offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetSlidingExpiration(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), offset: offset);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.ICacheEntry SetValue(Microsoft.Extensions.Caching.Memory.ICacheEntry, System.Object)
extension Microsoft_Extensions_Caching_Memory_ICacheEntry {
    public func SetValue(value : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheEntryExtensions.SetValue(entry: aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry(hndl: __copy_handle(self.get_handle())), value: value);
    }
}

// EXTENSION METHOD System.Object Get(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Get(key : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.Object> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Get(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task<TItem> GetOrCreateAsync<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, System.Func<Microsoft.Extensions.Caching.Memory.ICacheEntry,System.Threading.Tasks.Task<TItem>>)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func GetOrCreateAsync<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, factory : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,dotnet.System.Threading.Tasks.Task_1<UTItem>>>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<UTItem>> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, factory: factory);
    }
    // delegate closure overload
    public func GetOrCreateAsync<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, factory : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>) throws -> dotnet.System.Threading.Tasks.Task_1<UTItem>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<UTItem>> {
        let del_factory = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,dotnet.System.Threading.Tasks.Task_1<UTItem>>(factory);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, factory: del_factory);
    }
}

// EXTENSION METHOD TItem GetOrCreate<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, System.Func<Microsoft.Extensions.Caching.Memory.ICacheEntry,TItem>)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func GetOrCreate<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, factory : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,UTItem>>) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, factory: factory);
    }
    // delegate closure overload
    public func GetOrCreate<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, factory : @escaping (Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry>) throws -> UTItem) throws -> UTItem {
        let del_factory = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Caching.Memory.ICacheEntry,UTItem>(factory);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, factory: del_factory);
    }
}

// EXTENSION METHOD TItem Get<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object)
// TODO COPE extension method (unused generic param) TItem Get<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object)

// EXTENSION METHOD TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Set<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, value : UTItem) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, value: value);
    }
}

// EXTENSION METHOD TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Set<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, value : UTItem, options : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions>) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, options: options);
    }
}

// EXTENSION METHOD TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, Microsoft.Extensions.Primitives.IChangeToken)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Set<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, value : UTItem, expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, expirationToken: expirationToken);
    }
}

// EXTENSION METHOD TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, System.DateTimeOffset)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Set<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, value : UTItem, absoluteExpiration : dotnet.System.DateTimeOffset) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, absoluteExpiration: absoluteExpiration);
    }
}

// EXTENSION METHOD TItem Set<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, TItem, System.TimeSpan)
extension Microsoft_Extensions_Caching_Memory_IMemoryCache {
    public func Set<UTItem : SGBridgeGenericValue>(key : Optional<dotnet.System.Object>, value : UTItem, absoluteExpirationRelativeToNow : dotnet.System.TimeSpan) throws -> UTItem {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.CacheExtensions.Set(cache: aspnetcore.Microsoft.Extensions.Caching.Memory.IMemoryCache(hndl: __copy_handle(self.get_handle())), key: key, value: value, absoluteExpirationRelativeToNow: absoluteExpirationRelativeToNow);
    }
}

// EXTENSION METHOD bool TryGetValue<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, ref TItem)
// TODO COPE extension method (unused generic param) bool TryGetValue<TItem>(Microsoft.Extensions.Caching.Memory.IMemoryCache, System.Object, ref TItem)

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions AddExpirationToken(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Primitives.IChangeToken)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func AddExpirationToken(expirationToken : Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.AddExpirationToken(options: self, expirationToken: expirationToken);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func RegisterPostEvictionCallback(callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(options: self, callback: callback);
    }
    // delegate closure overload
    public func RegisterPostEvictionCallback(callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(options: self, callback: del_callback);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions RegisterPostEvictionCallback(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.PostEvictionDelegate, System.Object)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func RegisterPostEvictionCallback(callback : Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate>, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(options: self, callback: callback, state: state);
    }
    // delegate closure overload
    public func RegisterPostEvictionCallback(callback : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Object>, aspnetcore.Microsoft.Extensions.Caching.Memory.EvictionReason, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        let del_callback = try aspnetcore.Microsoft.Extensions.Caching.Memory.PostEvictionDelegate(callback);
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.RegisterPostEvictionCallback(options: self, callback: del_callback, state: state);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.DateTimeOffset)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func SetAbsoluteExpiration(absolute : dotnet.System.DateTimeOffset) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetAbsoluteExpiration(options: self, absolute: absolute);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetAbsoluteExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.TimeSpan)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func SetAbsoluteExpiration(relative : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetAbsoluteExpiration(options: self, relative: relative);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetPriority(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, Microsoft.Extensions.Caching.Memory.CacheItemPriority)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func SetPriority(priority : aspnetcore.Microsoft.Extensions.Caching.Memory.CacheItemPriority) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetPriority(options: self, priority: priority);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetSize(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.Int64)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func SetSize(size : Swift.Int64) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize(options: self, size: size);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions SetSlidingExpiration(Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions, System.TimeSpan)
extension aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions {
    public func SetSlidingExpiration(offset : dotnet.System.TimeSpan) throws -> Optional<aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions> {
        return try aspnetcore.Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSlidingExpiration(options: self, offset: offset);
    }
}

