// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Hosting
extension Microsoft.AspNetCore.Hosting {
// type: Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions
public struct WebHostBuilderHttpSysExtensions {
    // Microsoft.AspNetCore.Hosting.IWebHostBuilder UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
// docid: M:Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
    /**
    
            Specify Http.sys as the server to be used by the web host.
            

    - Parameter hostBuilder: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder to configure.
            
    - Returns: 
            A reference to the  parameter object.
            

    */
    public static func UseHttpSys(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_WebHostBuilderHttpSysExtensions_IWebHostBuilder__UseHttpSys_0__1__IWebHostBuilder(&__thrown, hostBuilder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Hosting.IWebHostBuilder UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder, System.Action<Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder,System.Action{Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions})
    /**
    
            Specify Http.sys as the server to be used by the web host.
            

    - Parameter hostBuilder: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder to configure.
            
    - Parameter options: 
            A callback to configure Http.sys options.
            
    - Returns: 
            A reference to the  parameter object.
            

    */
    public static func UseHttpSys(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder, options : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_WebHostBuilderHttpSysExtensions_IWebHostBuilder__UseHttpSys_0__2__IWebHostBuilder_System_Action_Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_(&__thrown, hostBuilder.get_handle(), options.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseHttpSys(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder, options : @escaping (aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        let del_options = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>(options);
        return try UseHttpSys(hostBuilder: hostBuilder, options: del_options);
    }
} // WebHostBuilderHttpSysExtensions


}

// Microsoft.AspNetCore.Server
// Microsoft.AspNetCore.Server.HttpSys
extension Microsoft.AspNetCore.Server.HttpSys {
// type: Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager
    /**
    
            Exposes the Http.Sys authentication configurations.
            

    */
public final class AuthenticationManager
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes get_Schemes()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.get_Schemes
    public func get_Schemes() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_AuthenticationSchemes__get_Schemes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: __return);
        }
    }
    // [IsSpecialName] void set_Schemes(Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.set_Schemes(Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes)
    public func set_Schemes(value : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_void__set_Schemes_0__1__AuthenticationSchemes(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowAnonymous()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.get_AllowAnonymous
    public func get_AllowAnonymous() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_bool__get_AllowAnonymous_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowAnonymous(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.set_AllowAnonymous(System.Boolean)
    public func set_AllowAnonymous(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_void__set_AllowAnonymous_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AutomaticAuthentication()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.get_AutomaticAuthentication
    public func get_AutomaticAuthentication() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_bool__get_AutomaticAuthentication_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AutomaticAuthentication(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.set_AutomaticAuthentication(System.Boolean)
    public func set_AutomaticAuthentication(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_void__set_AutomaticAuthentication_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_AuthenticationDisplayName()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.get_AuthenticationDisplayName
    public func get_AuthenticationDisplayName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_String__get_AuthenticationDisplayName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticationDisplayName(System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager.set_AuthenticationDisplayName(System.String)
    public func set_AuthenticationDisplayName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_AuthenticationManager_void__set_AuthenticationDisplayName_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Indicates if anonymous requests will be surfaced to the application or challenged by the server.
            The default value is true.
            

    */
    public var AllowAnonymous : Bool {
        get {
            return try! get_AllowAnonymous();
        }
        set(v) {
            return try! set_AllowAnonymous(value: v);
        }
    }
    /**
    
            Sets the display name shown to users on login pages. The default is null.
            

    */
    public var AuthenticationDisplayName : Optional<dotnet.System.String> {
        get {
            return try! get_AuthenticationDisplayName();
        }
        set(v) {
            return try! set_AuthenticationDisplayName(value: v!);
        }
    }
    /**
    
            If true the server should set HttpContext.User. If false the server will only provide an
            identity when explicitly requested by the AuthenticationScheme. The default is true.
            

    */
    public var AutomaticAuthentication : Bool {
        get {
            return try! get_AutomaticAuthentication();
        }
        set(v) {
            return try! set_AutomaticAuthentication(value: v);
        }
    }
    /**
    
            When attaching to an existing queue this setting must match the one used to create the queue.
            

    */
    public var Schemes : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
            return try! get_Schemes();
        }
        set(v) {
            return try! set_Schemes(value: v);
        }
    }
} // AuthenticationManager


// type: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes
    /**
    
            Specifies protocols for authentication.
            

    */
public struct AuthenticationSchemes : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes None
    /**
    
            No authentication is enabled. This should only be used when HttpSysOptions.Authentication.AllowAnonymous is enabled (see ).
            

    */
    public static var None : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_None());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes Basic
    /**
    
            Specifies basic authentication.
            

    */
    public static var Basic : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_Basic());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes NTLM
    /**
    
            Specifies NTLM authentication.
            

    */
    public static var NTLM : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_NTLM());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes Negotiate
    /**
    
            Negotiates with the client to determine the authentication scheme. If both client and server support Kerberos, it is used;
            otherwise, NTLM is used.
            

    */
    public static var Negotiate : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_Negotiate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes Kerberos
    /**
    
            Specifies Kerberos authentication.
            

    */
    public static var Kerberos : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationSchemes(val: Microsoft_AspNetCore_Server_HttpSys_AuthenticationSchemes_get_Kerberos());
            return __return;
        }
    }
} // AuthenticationSchemes


// type: Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod
    /**
    
            Describes the client certificate negotiation method for HTTPS connections.
            

    */
public struct ClientCertificateMethod : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_ClientCertificateMethod_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod NoCertificate
    /**
    
            A client certificate will not be populated on the request.
            

    */
    public static var NoCertificate : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod(val: Microsoft_AspNetCore_Server_HttpSys_ClientCertificateMethod_get_NoCertificate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod AllowCertificate
    /**
    
            A client certificate will be populated if already present at the start of a request.
            

    */
    public static var AllowCertificate : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod(val: Microsoft_AspNetCore_Server_HttpSys_ClientCertificateMethod_get_AllowCertificate());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod AllowRenegotation
    /**
    
            The TLS session can be renegotiated to request a client certificate.
            

    */
    public static var AllowRenegotation : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod(val: Microsoft_AspNetCore_Server_HttpSys_ClientCertificateMethod_get_AllowRenegotation());
            return __return;
        }
    }
} // ClientCertificateMethod


// type: Microsoft.AspNetCore.Server.HttpSys.DelegationRule
    /**
    
            Rule that maintains a handle to the Request Queue and UrlPrefix to
            delegate to.
            

    */
open class DelegationRule
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_DelegationRule_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.DelegationRule.Dispose
    /**
    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_DelegationRule_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_QueueName()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.DelegationRule.get_QueueName
    open func get_QueueName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_DelegationRule_String__get_QueueName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_UrlPrefix()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.DelegationRule.get_UrlPrefix
    open func get_UrlPrefix() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_DelegationRule_String__get_UrlPrefix_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    
            The name of the Http.Sys request queue
            

    */
    open var QueueName : dotnet.System.String {
        get {
            return try! get_QueueName();
        }
    }
    /**
    
            The URL of the Http.Sys Url Prefix
            

    */
    open var UrlPrefix : dotnet.System.String {
        get {
            return try! get_UrlPrefix();
        }
    }
} // DelegationRule


// type: Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel
    /**
    
            Enum declaring the allowed values for the verbosity level when http.sys reject requests due to throttling.
            

    */
public struct Http503VerbosityLevel : SGBridgeGenericValue {
    let v : Swift.Int64;
    public init(val: Swift.Int64) { self.v = val; }
    public func get_value() -> Swift.Int64 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_Http503VerbosityLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int64(gval); }
    // static field: Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel Basic
    /**
    
            A 503 response is not sent; the connection is reset. This is the default HTTP Server API behavior.
            

    */
    public static var Basic : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel(val: Microsoft_AspNetCore_Server_HttpSys_Http503VerbosityLevel_get_Basic());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel Limited
    /**
    
            The HTTP Server API sends a 503 response with a "Service Unavailable" reason phrase.
            

    */
    public static var Limited : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel(val: Microsoft_AspNetCore_Server_HttpSys_Http503VerbosityLevel_get_Limited());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel Full
    /**
    
            The HTTP Server API sends a 503 response with a detailed reason phrase.
            

    */
    public static var Full : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel(val: Microsoft_AspNetCore_Server_HttpSys_Http503VerbosityLevel_get_Full());
            return __return;
        }
    }
} // Http503VerbosityLevel


// type: Microsoft.AspNetCore.Server.HttpSys.HttpSysDefaults
public struct HttpSysDefaults {
    // static field: System.String AuthenticationScheme
    /**
    
            The name of the authentication scheme used.
            

    */
    public static var AuthenticationScheme : dotnet.System.String {
        get {
        let __return = dotnet.System.String(hndl: Microsoft_AspNetCore_Server_HttpSys_HttpSysDefaults_get_AuthenticationScheme());
            return __return;
        }
    }
} // HttpSysDefaults


// type: Microsoft.AspNetCore.Server.HttpSys.HttpSysException
    /**
    
            Exception thrown by HttpSys when an error occurs
            

    */
open class HttpSysException
    :
    dotnet.System.ComponentModel.Win32Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_HttpSysException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Int32 get_ErrorCode()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysException.get_ErrorCode
    open override func get_ErrorCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysException_i32__get_ErrorCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    */
    open override var ErrorCode : Swift.Int32 {
        get {
            return try! get_ErrorCode();
        }
    }
} // HttpSysException


// type: Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions
    /**
    
            Contains the options used by HttpSys.
            

    */
open class HttpSysOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.#ctor
    /**
    
            Initializes a new .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_RequestQueueName()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_RequestQueueName
    open func get_RequestQueueName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_String__get_RequestQueueName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RequestQueueName(System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_RequestQueueName(System.String)
    open func set_RequestQueueName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_RequestQueueName_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode get_RequestQueueMode()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_RequestQueueMode
    open func get_RequestQueueMode() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_RequestQueueMode__get_RequestQueueMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode(val: __return);
        }
    }
    // [IsSpecialName] void set_RequestQueueMode(Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_RequestQueueMode(Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode)
    open func set_RequestQueueMode(value : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_RequestQueueMode_0__1__RequestQueueMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod get_ClientCertificateMethod()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_ClientCertificateMethod
    open func get_ClientCertificateMethod() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_ClientCertificateMethod__get_ClientCertificateMethod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod(val: __return);
        }
    }
    // [IsSpecialName] void set_ClientCertificateMethod(Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_ClientCertificateMethod(Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod)
    open func set_ClientCertificateMethod(value : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_ClientCertificateMethod_0__1__ClientCertificateMethod(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MaxAccepts()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_MaxAccepts
    open func get_MaxAccepts() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_i32__get_MaxAccepts_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxAccepts(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_MaxAccepts(System.Int32)
    open func set_MaxAccepts(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_MaxAccepts_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_EnableResponseCaching()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_EnableResponseCaching
    open func get_EnableResponseCaching() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_bool__get_EnableResponseCaching_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_EnableResponseCaching(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_EnableResponseCaching(System.Boolean)
    open func set_EnableResponseCaching(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_EnableResponseCaching_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection get_UrlPrefixes()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_UrlPrefixes
    open func get_UrlPrefixes() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_UrlPrefixCollection__get_UrlPrefixes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager get_Authentication()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_Authentication
    open func get_Authentication() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_AuthenticationManager__get_Authentication_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.TimeoutManager get_Timeouts()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_Timeouts
    open func get_Timeouts() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.TimeoutManager {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_TimeoutManager__get_Timeouts_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.TimeoutManager(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_ThrowWriteExceptions()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_ThrowWriteExceptions
    open func get_ThrowWriteExceptions() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_bool__get_ThrowWriteExceptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ThrowWriteExceptions(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_ThrowWriteExceptions(System.Boolean)
    open func set_ThrowWriteExceptions(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_ThrowWriteExceptions_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxConnections()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_MaxConnections
    open func get_MaxConnections() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_System_Nullable_i64___get_MaxConnections_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxConnections(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_MaxConnections(System.Nullable{System.Int64})
    open func set_MaxConnections(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_MaxConnections_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_RequestQueueLimit()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_RequestQueueLimit
    open func get_RequestQueueLimit() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_i64__get_RequestQueueLimit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_RequestQueueLimit(System.Int64)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_RequestQueueLimit(System.Int64)
    open func set_RequestQueueLimit(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_RequestQueueLimit_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxRequestBodySize()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_MaxRequestBodySize
    open func get_MaxRequestBodySize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_System_Nullable_i64___get_MaxRequestBodySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxRequestBodySize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_MaxRequestBodySize(System.Nullable{System.Int64})
    open func set_MaxRequestBodySize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_MaxRequestBodySize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_AllowSynchronousIO()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_AllowSynchronousIO
    open func get_AllowSynchronousIO() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_bool__get_AllowSynchronousIO_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowSynchronousIO(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_AllowSynchronousIO(System.Boolean)
    open func set_AllowSynchronousIO(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_AllowSynchronousIO_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel get_Http503Verbosity()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_Http503Verbosity
    open func get_Http503Verbosity() throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_Http503VerbosityLevel__get_Http503Verbosity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel(val: __return);
        }
    }
    // [IsSpecialName] void set_Http503Verbosity(Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_Http503Verbosity(Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel)
    open func set_Http503Verbosity(value : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_Http503Verbosity_0__1__Http503VerbosityLevel(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UnsafePreferInlineScheduling()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_UnsafePreferInlineScheduling
    open func get_UnsafePreferInlineScheduling() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_bool__get_UnsafePreferInlineScheduling_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UnsafePreferInlineScheduling(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_UnsafePreferInlineScheduling(System.Boolean)
    open func set_UnsafePreferInlineScheduling(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_UnsafePreferInlineScheduling_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UseLatin1RequestHeaders()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.get_UseLatin1RequestHeaders
    open func get_UseLatin1RequestHeaders() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_bool__get_UseLatin1RequestHeaders_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseLatin1RequestHeaders(bool)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions.set_UseLatin1RequestHeaders(System.Boolean)
    open func set_UseLatin1RequestHeaders(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_HttpSysOptions_void__set_UseLatin1RequestHeaders_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets a value that controls whether synchronous IO is allowed for the HttpContext.Request.Body and HttpContext.Response.Body.
            The default is `false`.
            

    */
    open var AllowSynchronousIO : Bool {
        get {
            return try! get_AllowSynchronousIO();
        }
        set(v) {
            return try! set_AllowSynchronousIO(value: v);
        }
    }
    /**
    
            Http.Sys authentication settings. These may be modified at any time prior to disposing
            the listener.
            

    */
    open var Authentication : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.AuthenticationManager {
        get {
            return try! get_Authentication();
        }
    }
    /**
    
            Indicates how client certificates should be populated. The default is to allow a certificate without renegotiation.
            This does not change the netsh 'clientcertnegotiation' binding option which will need to be enabled for
            ClientCertificateMethod.AllowCertificate to resolve a certificate.
            

    */
    open var ClientCertificateMethod : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.ClientCertificateMethod {
        get {
            return try! get_ClientCertificateMethod();
        }
        set(v) {
            return try! set_ClientCertificateMethod(value: v);
        }
    }
    /**
    
            Attempts kernel mode caching for responses with eligible headers. The response may not include
            Set-Cookie, Vary, or Pragma headers. It must include a Cache-Control header with Public and
            either a Shared-Max-Age or Max-Age value, or an Expires header.
            

    */
    open var EnableResponseCaching : Bool {
        get {
            return try! get_EnableResponseCaching();
        }
        set(v) {
            return try! set_EnableResponseCaching(value: v);
        }
    }
    /**
    
            Gets or sets a value that controls how http.sys reacts when rejecting requests due to throttling conditions - like when the request
            queue limit is reached. The default in http.sys is "Basic" which means http.sys is just resetting the TCP connection. IIS uses Limited
            as its default behavior which will result in sending back a 503 - Service Unavailable back to the client.
            This settings does not apply when attaching to an existing queue.
            

    */
    open var Http503Verbosity : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.Http503VerbosityLevel {
        get {
            return try! get_Http503Verbosity();
        }
        set(v) {
            return try! set_Http503Verbosity(value: v);
        }
    }
    /**
    
            Gets or sets the number of concurrent workers draining requests from the Http.sys queue.
            

    */
    open var MaxAccepts : Swift.Int32 {
        get {
            return try! get_MaxAccepts();
        }
        set(v) {
            return try! set_MaxAccepts(value: v);
        }
    }
    /**
    
            Gets or sets the maximum number of concurrent connections to accept, -1 for infinite, or null to
            use the machine wide setting from the registry. The default value is null.
            This settings does not apply when attaching to an existing queue.
            

    */
    open var MaxConnections : Optional<Swift.Int64> {
        get {
            return try! get_MaxConnections();
        }
        set(v) {
            return try! set_MaxConnections(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum allowed size of any request body in bytes.
            When set to null, the maximum request body size is unlimited.
            This limit has no effect on upgraded connections which are always unlimited.
            This can be overridden per-request via .
            

    */
    open var MaxRequestBodySize : Optional<Swift.Int64> {
        get {
            return try! get_MaxRequestBodySize();
        }
        set(v) {
            return try! set_MaxRequestBodySize(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum number of requests that will be queued up in Http.Sys.
            This settings does not apply when attaching to an existing queue.
            

    */
    open var RequestQueueLimit : Swift.Int64 {
        get {
            return try! get_RequestQueueLimit();
        }
        set(v) {
            return try! set_RequestQueueLimit(value: v);
        }
    }
    /**
    
            Indicates if this server instance is responsible for creating and configuring the request queue,
            of if it should attach to an existing queue. The default is to create.
            

    */
    open var RequestQueueMode : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode {
        get {
            return try! get_RequestQueueMode();
        }
        set(v) {
            return try! set_RequestQueueMode(value: v);
        }
    }
    /**
    
            The name of the Http.Sys request queue
            

    */
    open var RequestQueueName : Optional<dotnet.System.String> {
        get {
            return try! get_RequestQueueName();
        }
        set(v) {
            return try! set_RequestQueueName(value: v!);
        }
    }
    /**
    
            Gets or Sets if response body writes that fail due to client disconnects should throw exceptions or
            complete normally. The default is false.
            

    */
    open var ThrowWriteExceptions : Bool {
        get {
            return try! get_ThrowWriteExceptions();
        }
        set(v) {
            return try! set_ThrowWriteExceptions(value: v);
        }
    }
    /**
    
            Exposes the Http.Sys timeout configurations.  These may also be configured in the registry.
            These may be modified at any time prior to disposing the listener.
            These settings do not apply when attaching to an existing queue.
            

    */
    open var Timeouts : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.TimeoutManager {
        get {
            return try! get_Timeouts();
        }
    }
    /**
    
            Inline request processing instead of dispatching to the threadpool.
            

    */
    open var UnsafePreferInlineScheduling : Bool {
        get {
            return try! get_UnsafePreferInlineScheduling();
        }
        set(v) {
            return try! set_UnsafePreferInlineScheduling(value: v);
        }
    }
    /**
    
            The url prefixes to register with Http.Sys. These may be modified at any time prior to disposing
            the listener.
            When attached to an existing queue the prefixes are only used to compute PathBase for requests.
            

    */
    open var UrlPrefixes : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection {
        get {
            return try! get_UrlPrefixes();
        }
    }
    /**
    
            Configures request headers to use  encoding.
            

    */
    open var UseLatin1RequestHeaders : Bool {
        get {
            return try! get_UseLatin1RequestHeaders();
        }
        set(v) {
            return try! set_UseLatin1RequestHeaders(value: v);
        }
    }
} // HttpSysOptions


// type: Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestDelegationFeature
    /**
    
            Interface for delegating requests to other Http.Sys request queues.
            

    */
open class IHttpSysRequestDelegationFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestDelegationFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestDelegationFeature_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void DelegateRequest(Microsoft.AspNetCore.Server.HttpSys.DelegationRule)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestDelegationFeature.DelegateRequest(Microsoft.AspNetCore.Server.HttpSys.DelegationRule)
    /**
    
            Attempt to delegate the request to another Http.Sys request queue. The request body
            must not be read nor the response started before this is invoked. Check 
            before invoking.
            

    - Parameter destination: The rule maintaining the handle to the destination queue.
    */
    open func DelegateRequest(destination : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.DelegationRule) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestDelegationFeature_void__DelegateRequest_0__1__DelegationRule(&__thrown, self.get_handle(), destination.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CanDelegate()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestDelegationFeature.get_CanDelegate
    open func get_CanDelegate() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestDelegationFeature_bool__get_CanDelegate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IHttpSysRequestDelegationFeature


// type: Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature
    /**
    
            This exposes the Http.Sys HTTP_REQUEST_INFO extensibility point as opaque data for the caller to interperate.
            https://docs.microsoft.com/en-us/windows/win32/api/http/ns-http-http_request_v2
            https://docs.microsoft.com/en-us/windows/win32/api/http/ns-http-http_request_info
            

    */
open class IHttpSysRequestInfoFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestInfoFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestInfoFeature_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Collections.Generic.IReadOnlyDictionary<System.Int32,System.ReadOnlyMemory<System.Byte>> get_RequestInfo()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.IHttpSysRequestInfoFeature.get_RequestInfo
    open func get_RequestInfo() throws -> dotnet.System.Collections.Generic.IReadOnlyDictionary_2<Swift.Int32,dotnet.System.ReadOnlyMemory_1<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestInfoFeature_System_Collections_Generic_IReadOnlyDictionary_i32_System_System_ReadOnlyMemory_u8____get_RequestInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyDictionary_2(hndl : __return);
        }
    }
} // IHttpSysRequestInfoFeature


// type: Microsoft.AspNetCore.Server.HttpSys.IServerDelegationFeature
    /**
    
            This exposes the creation of delegation rules on request queues owned by the server.
            

    */
open class IServerDelegationFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Server_HttpSys_IServerDelegationFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_IServerDelegationFeature_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.Server.HttpSys.DelegationRule CreateDelegationRule(System.String, System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.IServerDelegationFeature.CreateDelegationRule(System.String,System.String)
    /**
    
            Create a delegation rule on request queue owned by the server.
            

    - Parameter queueName: The name of the Http.Sys request queue.
    - Parameter urlPrefix: The URL of the Http.Sys Url Prefix.
    - Returns: 
            Creates a  that can used to delegate individual requests.
            

    */
    open func CreateDelegationRule(queueName : dotnet.System.String, urlPrefix : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.DelegationRule {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_IServerDelegationFeature_DelegationRule__CreateDelegationRule_0__2__String_String(&__thrown, self.get_handle(), queueName.get_handle(), urlPrefix.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.DelegationRule(hndl : __return);
        }
    }
} // IServerDelegationFeature


// type: Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode
    /**
    
            Used to indicate if this server instance should create a new Http.Sys request queue
            or attach to an existing one.
            

    */
public struct RequestQueueMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_RequestQueueMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode Create
    /**
    
            Create a new queue. This will fail if there's an existing queue with the same name.
            

    */
    public static var Create : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode(val: Microsoft_AspNetCore_Server_HttpSys_RequestQueueMode_get_Create());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode Attach
    /**
    
            Attach to an existing queue with the name given. This will fail if the queue does not already exist.
            Most configuration options do not apply when attaching to an existing queue.
            

    */
    public static var Attach : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode(val: Microsoft_AspNetCore_Server_HttpSys_RequestQueueMode_get_Attach());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode CreateOrAttach
    /**
    
            Create a queue with the given name if it does not already exist, otherwise attach to the existing queue.
            Most configuration options do not apply when attaching to an existing queue.
            

    */
    public static var CreateOrAttach : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Server.HttpSys.RequestQueueMode(val: Microsoft_AspNetCore_Server_HttpSys_RequestQueueMode_get_CreateOrAttach());
            return __return;
        }
    }
} // RequestQueueMode


// type: Microsoft.AspNetCore.Server.HttpSys.TimeoutManager
    /**
    
            Exposes the Http.Sys timeout configurations.  These may also be configured in the registry.
            These settings do not apply when attaching to an existing queue.
            

    */
public final class TimeoutManager
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.TimeSpan get_EntityBody()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_EntityBody
    public func get_EntityBody() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_TimeSpan__get_EntityBody_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_EntityBody(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_EntityBody(System.TimeSpan)
    public func set_EntityBody(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_EntityBody_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_DrainEntityBody()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_DrainEntityBody
    public func get_DrainEntityBody() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_TimeSpan__get_DrainEntityBody_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_DrainEntityBody(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_DrainEntityBody(System.TimeSpan)
    public func set_DrainEntityBody(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_DrainEntityBody_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_RequestQueue()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_RequestQueue
    public func get_RequestQueue() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_TimeSpan__get_RequestQueue_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_RequestQueue(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_RequestQueue(System.TimeSpan)
    public func set_RequestQueue(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_RequestQueue_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_IdleConnection()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_IdleConnection
    public func get_IdleConnection() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_TimeSpan__get_IdleConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IdleConnection(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_IdleConnection(System.TimeSpan)
    public func set_IdleConnection(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_IdleConnection_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_HeaderWait()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_HeaderWait
    public func get_HeaderWait() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_TimeSpan__get_HeaderWait_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HeaderWait(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_HeaderWait(System.TimeSpan)
    public func set_HeaderWait(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_HeaderWait_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_MinSendBytesPerSecond()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.get_MinSendBytesPerSecond
    public func get_MinSendBytesPerSecond() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_i64__get_MinSendBytesPerSecond_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MinSendBytesPerSecond(System.Int64)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.TimeoutManager.set_MinSendBytesPerSecond(System.Int64)
    public func set_MinSendBytesPerSecond(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_TimeoutManager_void__set_MinSendBytesPerSecond_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
             The time, in seconds, allowed for the HTTP Server API to drain the entity body on a Keep-Alive connection.
             The default timer is 2 minutes.
            
             On a Keep-Alive connection, after the application has sent a response for a request and before the request
             entity body has completely arrived, the HTTP Server API starts draining the remainder of the entity body to
             reach another potentially pipelined request from the client. If the time to drain the remaining entity body
             exceeds the allowed period the connection is timed out.
            
             Use TimeSpan.Zero to indicate that system defaults should be used.
             

    */
    public var DrainEntityBody : dotnet.System.TimeSpan {
        get {
            return try! get_DrainEntityBody();
        }
        set(v) {
            return try! set_DrainEntityBody(value: v);
        }
    }
    /**
    
             The time, in seconds, allowed for the request entity body to arrive.  The default timer is 2 minutes.
            
             The HTTP Server API turns on this timer when the request has an entity body. The timer expiration is
             initially set to the configured value. When the HTTP Server API receives additional data indications on the
             request, it resets the timer to give the connection another interval.
            
             Use TimeSpan.Zero to indicate that system defaults should be used.
             

    */
    public var EntityBody : dotnet.System.TimeSpan {
        get {
            return try! get_EntityBody();
        }
        set(v) {
            return try! set_EntityBody(value: v);
        }
    }
    /**
    
             The time, in seconds, allowed for the HTTP Server API to parse the request header.  The default timer is
             2 minutes.
            
             This timeout is only enforced after the first request on the connection is routed to the application.
            
             Use TimeSpan.Zero to indicate that system defaults should be used.
             

    */
    public var HeaderWait : dotnet.System.TimeSpan {
        get {
            return try! get_HeaderWait();
        }
        set(v) {
            return try! set_HeaderWait(value: v);
        }
    }
    /**
    
             The time, in seconds, allowed for an idle connection.  The default timer is 2 minutes.
            
             This timeout is only enforced after the first request on the connection is routed to the application.
            
             Use TimeSpan.Zero to indicate that system defaults should be used.
             

    */
    public var IdleConnection : dotnet.System.TimeSpan {
        get {
            return try! get_IdleConnection();
        }
        set(v) {
            return try! set_IdleConnection(value: v);
        }
    }
    /**
    
             The minimum send rate, in bytes-per-second, for the response. The default response send rate is 150
             bytes-per-second.
            
             Use 0 to indicate that system defaults should be used.
            
             To disable this timer set it to UInt32.MaxValue
             

    */
    public var MinSendBytesPerSecond : Swift.Int64 {
        get {
            return try! get_MinSendBytesPerSecond();
        }
        set(v) {
            return try! set_MinSendBytesPerSecond(value: v);
        }
    }
    /**
    
             The time, in seconds, allowed for the request to remain in the request queue before the application picks
             it up.  The default timer is 2 minutes.
            
             Use TimeSpan.Zero to indicate that system defaults should be used.
             

    */
    public var RequestQueue : dotnet.System.TimeSpan {
        get {
            return try! get_RequestQueue();
        }
        set(v) {
            return try! set_RequestQueue(value: v);
        }
    }
} // TimeoutManager


// type: Microsoft.AspNetCore.Server.HttpSys.UrlPrefix
    /**
    
            A set of URL parameters used to listen for incoming requests.
            

    */
open class UrlPrefix
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // Microsoft.AspNetCore.Server.HttpSys.UrlPrefix Create(System.String, System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(System.String,System.String,System.String,System.String)
    /**
    
            http://msdn.microsoft.com/en-us/library/windows/desktop/aa364698(v=vs.85).aspx
            

    - Parameter scheme: http or https. Will be normalized to lower case.
    - Parameter host: +, (ASTERISK), IPv4, [IPv6], or a dns name. Http.Sys does not permit punycode (xn--), use Unicode instead.
    - Parameter port: If empty, the default port for the given scheme will be used (80 or 443).
    - Parameter path: Should start and end with a '/', though a missing trailing slash will be added. This value must be un-escaped.
    */
    open class func Create(scheme : dotnet.System.String, host : dotnet.System.String, port : dotnet.System.String, path : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_UrlPrefix__Create_0__4__String_String_String_String(&__thrown, scheme.get_handle(), host.get_handle(), port.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.HttpSys.UrlPrefix Create(System.String, System.String, System.Nullable<System.Int32>, System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(System.String,System.String,System.Nullable{System.Int32},System.String)
    /**
    
            http://msdn.microsoft.com/en-us/library/windows/desktop/aa364698(v=vs.85).aspx
            

    - Parameter scheme: http or https. Will be normalized to lower case.
    - Parameter host: +, (ASTERISK), IPv4, [IPv6], or a dns name. Http.Sys does not permit punycode (xn--), use Unicode instead.
    - Parameter portValue: If empty, the default port for the given scheme will be used (80 or 443).
    - Parameter path: Should start and end with a '/', though a missing trailing slash will be added. This value must be un-escaped.
    */
    open class func Create(scheme : dotnet.System.String, host : dotnet.System.String, portValue : Optional<Swift.Int32>, path : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_UrlPrefix__Create_0__4__String_String_System_Nullable_i32__String(&__thrown, scheme.get_handle(), host.get_handle(), (portValue != nil) ? System_Int32_box(portValue!) : nil, path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Server.HttpSys.UrlPrefix Create(System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Create(System.String)
    /**
    
            http://msdn.microsoft.com/en-us/library/windows/desktop/aa364698(v=vs.85).aspx
            

    - Parameter prefix: The string that the  will be created from.
    */
    open class func Create(prefix : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_UrlPrefix__Create_0__1__String(&__thrown, prefix.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix(hndl : __return);
        }
    }
    // bool Equals(System.Object)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.Equals(System.Object)
    /**
    */
    open override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.GetHashCode
    /**
    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsHttps()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_IsHttps
    open func get_IsHttps() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_bool__get_IsHttps_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Scheme()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_Scheme
    open func get_Scheme() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__get_Scheme_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Host()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_Host
    open func get_Host() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__get_Host_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Port()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_Port
    open func get_Port() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__get_Port_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_PortValue()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_PortValue
    open func get_PortValue() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_i32__get_PortValue_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Path()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_Path
    open func get_Path() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__get_Path_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_FullPrefix()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefix.get_FullPrefix
    open func get_FullPrefix() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefix_String__get_FullPrefix_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    
            Gets a string representation of the prefix
            

    */
    open var FullPrefix : dotnet.System.String {
        get {
            return try! get_FullPrefix();
        }
    }
    /**
    
            Gets the host domain name used by the prefix.
            

    */
    open var Host : dotnet.System.String {
        get {
            return try! get_Host();
        }
    }
    /**
    
            Gets a value that determines if the prefix's scheme is HTTPS.
            

    */
    open var IsHttps : Bool {
        get {
            return try! get_IsHttps();
        }
    }
    /**
    
            Gets the path component of the prefix.
            

    */
    open var Path : dotnet.System.String {
        get {
            return try! get_Path();
        }
    }
    /**
    
            Gets a string representation of the port used by the prefix.
            

    */
    open var Port : dotnet.System.String {
        get {
            return try! get_Port();
        }
    }
    /**
    
            Gets an integer representation of the port used by the prefix.
            

    */
    open var PortValue : Swift.Int32 {
        get {
            return try! get_PortValue();
        }
    }
    /**
    
            Gets the scheme used by the prefix.
            

    */
    open var Scheme : dotnet.System.String {
        get {
            return try! get_Scheme();
        }
    }
} // UrlPrefix


// type: Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection
    /**
    
            A collection or URL prefixes
            

    */
open class UrlPrefixCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Add(System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Add(System.String)
    /**
    
            Creates a  from the given string, and adds it to this collection.
            

    - Parameter prefix: The string representing the  to add to this collection.
    */
    open func Add(prefix : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_void__Add_0__1__String(&__thrown, self.get_handle(), prefix.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Add(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Add(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
    /**
    
            Adds a  to this collection.
            

    - Parameter item: The prefix to add to this collection.
    */
    open /* method final */ func Add(item : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_void__Add_0__1__UrlPrefix(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Clear()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Clear
    /**
    */
    open /* method final */ func Clear() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Contains(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Contains(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
    /**
    */
    open /* method final */ func Contains(item : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_bool__Contains_0__1__UrlPrefix(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix[], System.Int32)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.CopyTo(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix[],System.Int32)
    /**
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix>, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_void__CopyTo_0__2__UrlPrefixArray_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Remove(System.String)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Remove(System.String)
    /**
    */
    open func Remove(prefix : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_bool__Remove_0__1__String(&__thrown, self.get_handle(), prefix.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Remove(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.Remove(Microsoft.AspNetCore.Server.HttpSys.UrlPrefix)
    /**
    */
    open /* method final */ func Remove(item : aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_bool__Remove_0__1__UrlPrefix(&__thrown, self.get_handle(), item.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Collections.Generic.IEnumerator<Microsoft.AspNetCore.Server.HttpSys.UrlPrefix> GetEnumerator()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.GetEnumerator
    /**
    
            Returns an enumerator that iterates through this collection.
            

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.Generic.IEnumerator_1<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.UrlPrefix> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_System_Collections_Generic_IEnumerator_Microsoft_AspNetCore_Server_HttpSys_UrlPrefix___GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerator_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:Microsoft.AspNetCore.Server.HttpSys.UrlPrefixCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_HttpSys_UrlPrefixCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    
            Gets a value that determines if this collection is readOnly.
            

    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
} // UrlPrefixCollection


}




public protocol Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestDelegationFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_HttpSys_IHttpSysRequestInfoFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Server_HttpSys_IServerDelegationFeature
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Hosting.IWebHostBuilder UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
extension Microsoft_AspNetCore_Hosting_IWebHostBuilder {
    public func UseHttpSys() throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Hosting.IWebHostBuilder UseHttpSys(Microsoft.AspNetCore.Hosting.IWebHostBuilder, System.Action<Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>)
extension Microsoft_AspNetCore_Hosting_IWebHostBuilder {
    public func UseHttpSys(options : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())), options: options);
    }
    // delegate closure overload
    public func UseHttpSys(options : @escaping (aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        let del_options = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.HttpSys.HttpSysOptions>(options);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderHttpSysExtensions.UseHttpSys(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())), options: del_options);
    }
}

