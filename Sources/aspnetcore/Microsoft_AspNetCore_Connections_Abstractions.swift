// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Connections
extension Microsoft.AspNetCore.Connections {
// type: Microsoft.AspNetCore.Connections.AddressInUseException
    /**
    
            An exception that is thrown when there the current address Kestrel is trying to bind to is in use.
            

    */
open class AddressInUseException
    :
    dotnet.System.InvalidOperationException
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_AddressInUseException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Connections.AddressInUseException.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    */
    public init(message : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_AddressInUseException_ctor_0__1__String(&__thrown, message.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:Microsoft.AspNetCore.Connections.AddressInUseException.#ctor(System.String,System.Exception)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    - Parameter inner: The underlying .
    */
    public init(message : dotnet.System.String, inner : dotnet.System.Exception) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_AddressInUseException_ctor_0__2__String_Exception(&__thrown, message.get_handle(), inner.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // AddressInUseException


// type: Microsoft.AspNetCore.Connections.BaseConnectionContext
    /**
    
            Represents the context for a connection.
            

    */
open class BaseConnectionContext
    :
    dotnet.System.Object,
    System_IAsyncDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_BaseConnectionContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Abort()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort
    /**
    
            Aborts the underlying connection.
            

    */
    open func Abort() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__Abort_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
    /**
    
            Aborts the underlying connection.
            

    - Parameter abortReason: A  describing the reason the connection is being terminated.
    */
    open func Abort(abortReason : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionAbortedException) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__Abort_0__1__ConnectionAbortedException(&__thrown, self.get_handle(), abortReason.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.DisposeAsync
    /**
    
            Releases resources for the underlying connection.
            

    - Returns: A  that completes when resources have been released.

    */
    open func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_ConnectionId()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_ConnectionId
    open func get_ConnectionId() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_String__get_ConnectionId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionId(System.String)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.set_ConnectionId(System.String)
    open func set_ConnectionId(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__set_ConnectionId_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Features.IFeatureCollection get_Features()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_Features
    open func get_Features() throws -> aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_IFeatureCollection__get_Features_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_Items()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_Items
    open func get_Items() throws -> dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_System_Collections_Generic_IDictionary_object_object___get_Items_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IDictionary_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Items(System.Collections.Generic.IDictionary<System.Object,System.Object>)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.set_Items(System.Collections.Generic.IDictionary{System.Object,System.Object})
    open func set_Items(value : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__set_Items_0__1__System_Collections_Generic_IDictionary_object_object_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ConnectionClosed()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_ConnectionClosed
    open func get_ConnectionClosed() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_CancellationToken__get_ConnectionClosed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionClosed(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.set_ConnectionClosed(System.Threading.CancellationToken)
    open func set_ConnectionClosed(value : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__set_ConnectionClosed_0__1__CancellationToken(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_LocalEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_LocalEndPoint
    open func get_LocalEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_EndPoint__get_LocalEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LocalEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.set_LocalEndPoint(System.Net.EndPoint)
    open func set_LocalEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__set_LocalEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_RemoteEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.get_RemoteEndPoint
    open func get_RemoteEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_BaseConnectionContext_EndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.BaseConnectionContext.set_RemoteEndPoint(System.Net.EndPoint)
    open func set_RemoteEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_BaseConnectionContext_void__set_RemoteEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Triggered when the client connection is closed.
            

    */
    open var ConnectionClosed : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_ConnectionClosed();
        }
        set(v) {
            return try! set_ConnectionClosed(value: v);
        }
    }
    /**
    
            Gets or sets a unique identifier to represent this connection in trace logs.
            

    */
    open var ConnectionId : dotnet.System.String {
        get {
            return try! get_ConnectionId();
        }
        set(v) {
            return try! set_ConnectionId(value: v);
        }
    }
    /**
    
            Gets the collection of features provided by the server and middleware available on this connection.
            

    */
    open var Features : aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        get {
            return try! get_Features();
        }
    }
    /**
    
            Gets or sets a key/value collection that can be used to share data within the scope of this connection.
            

    */
    open var Items : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        get {
            return try! get_Items();
        }
        set(v) {
            return try! set_Items(value: v);
        }
    }
    /**
    
            Gets or sets the local endpoint for this connection.
            

    */
    open var LocalEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_LocalEndPoint();
        }
        set(v) {
            return try! set_LocalEndPoint(value: v!);
        }
    }
    /**
    
            Gets or sets the remote endpoint for this connection.
            

    */
    open var RemoteEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_RemoteEndPoint();
        }
        set(v) {
            return try! set_RemoteEndPoint(value: v!);
        }
    }
} // BaseConnectionContext


// type: Microsoft.AspNetCore.Connections.ConnectionAbortedException
    /**
    
            An exception that is thrown when a connection is aborted by the server.
            

    */
open class ConnectionAbortedException
    :
    dotnet.System.OperationCanceledException
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionAbortedException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionAbortedException.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionAbortedException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionAbortedException.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    */
    public init(message : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionAbortedException_ctor_0__1__String(&__thrown, message.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionAbortedException.#ctor(System.String,System.Exception)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    - Parameter inner: The underlying .
    */
    public init(message : dotnet.System.String, inner : dotnet.System.Exception) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionAbortedException_ctor_0__2__String_Exception(&__thrown, message.get_handle(), inner.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ConnectionAbortedException


// type: Microsoft.AspNetCore.Connections.ConnectionBuilder
    /**
    
            A default implementation for .
            

    */
open class ConnectionBuilder
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Connections_IConnectionBuilder
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilder.#ctor(System.IServiceProvider)
    /**
    
            Initializes a new instance of .
            

    - Parameter applicationServices: The application services .
    */
    public init(applicationServices : dotnet.System.IServiceProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionBuilder_ctor_0__1__IServiceProvider(&__thrown, applicationServices.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.Connections.IConnectionBuilder Use(System.Func<Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate>)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilder.Use(System.Func{Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate})
    /**
    */
    open /* method final */ func Use(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionBuilder_IConnectionBuilder__Use_0__1__System_Func_Microsoft_AspNetCore_Connections_ConnectionDelegate_Microsoft_AspNetCore_Connections_ConnectionDelegate_(&__thrown, self.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    open /* method final */ func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>(middleware);
        return try Use(middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.ConnectionDelegate Build()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilder.Build
    /**
    */
    open /* method final */ func Build() throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionBuilder_ConnectionDelegate__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate(hndl : __return);
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilder.get_ApplicationServices
    open /* method final */ func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionBuilder_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
    /**
    */
    public var ApplicationServices : dotnet.System.IServiceProvider {
        get {
            return try! get_ApplicationServices();
        }
    }
} // ConnectionBuilder


// type: Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions
public struct ConnectionBuilderExtensions {
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Connections.IConnectionBuilder UseConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Connections.IConnectionBuilder)
    // Microsoft.AspNetCore.Connections.IConnectionBuilder Use(Microsoft.AspNetCore.Connections.IConnectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.Func<System.Threading.Tasks.Task>,System.Threading.Tasks.Task>)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(Microsoft.AspNetCore.Connections.IConnectionBuilder,System.Func{Microsoft.AspNetCore.Connections.ConnectionContext,System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.Task})
    /**
    
            Add the given  to the connection.
            

    - Parameter connectionBuilder: The .
    - Parameter middleware: The middleware to add to the .
    - Returns: The .

    */
    public static func Use(connectionBuilder : aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder, middleware : dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>,dotnet.System.Threading.Tasks.Task>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionBuilderExtensions_IConnectionBuilder__Use_0__2__IConnectionBuilder_System_Func_Microsoft_AspNetCore_Connections_ConnectionContext_System_System_Func_Task__Task_(&__thrown, connectionBuilder.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func Use(connectionBuilder : aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder, middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>, Optional<dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>>) throws -> dotnet.System.Threading.Tasks.Task) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>,dotnet.System.Threading.Tasks.Task>(middleware);
        return try Use(connectionBuilder: connectionBuilder, middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.IConnectionBuilder Run(Microsoft.AspNetCore.Connections.IConnectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.Threading.Tasks.Task>)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(Microsoft.AspNetCore.Connections.IConnectionBuilder,System.Func{Microsoft.AspNetCore.Connections.ConnectionContext,System.Threading.Tasks.Task})
    /**
    
            Add the given  to the connection.
            

    - Parameter connectionBuilder: The .
    - Parameter middleware: The middleware to add to the .
    - Returns: The .

    */
    public static func Run(connectionBuilder : aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder, middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Threading.Tasks.Task>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionBuilderExtensions_IConnectionBuilder__Run_0__2__IConnectionBuilder_System_Func_Microsoft_AspNetCore_Connections_ConnectionContext_Task_(&__thrown, connectionBuilder.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func Run(connectionBuilder : aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder, middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>) throws -> dotnet.System.Threading.Tasks.Task) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Threading.Tasks.Task>(middleware);
        return try Run(connectionBuilder: connectionBuilder, middleware: del_middleware);
    }
} // ConnectionBuilderExtensions


// type: Microsoft.AspNetCore.Connections.ConnectionContext
    /**
    
            Encapsulates all information about an individual connection.
            

    */
open class ConnectionContext
    :
    aspnetcore.Microsoft.AspNetCore.Connections.BaseConnectionContext
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionContext.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
    /**
    
            Aborts the underlying connection.
            

    - Parameter abortReason: A  describing the reason the connection is being terminated.
    */
    open override func Abort(abortReason : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionAbortedException) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_ConnectionContext_void__Abort_0__1__ConnectionAbortedException(&__thrown, self.get_handle(), abortReason.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Abort()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionContext.Abort
    /**
    
            Aborts the underlying connection.
            

    */
    open override func Abort() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_ConnectionContext_void__Abort_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipelines.IDuplexPipe get_Transport()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionContext.get_Transport
    open func get_Transport() throws -> aspnetcore.System.IO.Pipelines.IDuplexPipe {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionContext_IDuplexPipe__get_Transport_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.IDuplexPipe(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Transport(System.IO.Pipelines.IDuplexPipe)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionContext.set_Transport(System.IO.Pipelines.IDuplexPipe)
    open func set_Transport(value : aspnetcore.System.IO.Pipelines.IDuplexPipe) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_ConnectionContext_void__set_Transport_0__1__IDuplexPipe(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the  that can be used to read or write data on this connection.
            

    */
    open var Transport : aspnetcore.System.IO.Pipelines.IDuplexPipe {
        get {
            return try! get_Transport();
        }
        set(v) {
            return try! set_Transport(value: v);
        }
    }
} // ConnectionContext


// type: Microsoft.AspNetCore.Connections.ConnectionDelegate
    /**
    
            A function that can process a connection.
            

    */
public final class ConnectionDelegate
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionDelegate_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.Task Invoke(Microsoft.AspNetCore.Connections.ConnectionContext)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionDelegate.Invoke(Microsoft.AspNetCore.Connections.ConnectionContext)
    public func Invoke(connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionDelegate_Task__Invoke_0__1__ConnectionContext(&__thrown, self.get_handle(), connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(Microsoft.AspNetCore.Connections.ConnectionContext, System.AsyncCallback, System.Object)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionDelegate.BeginInvoke(Microsoft.AspNetCore.Connections.ConnectionContext,System.AsyncCallback,System.Object)
    public func BeginInvoke(connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionDelegate_IAsyncResult__BeginInvoke_0__3__ConnectionContext_AsyncCallback_Object(&__thrown, self.get_handle(), connection.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task EndInvoke(System.IAsyncResult)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionDelegate.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionDelegate_Task__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    public init(_ callback : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext) throws -> dotnet.System.Threading.Tasks.Task) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, connection : NonnullHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext(hndl: connection));
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, connection : NonnullHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle;
            return f(thrown, connection);
        }
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionDelegate_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task Invoke(Microsoft.AspNetCore.Connections.ConnectionContext)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionDelegate.Invoke(Microsoft.AspNetCore.Connections.ConnectionContext)
    public func callAsFunction(connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionDelegate_Task__Invoke_0__1__ConnectionContext(&__thrown, self.get_handle(), connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
} // ConnectionDelegate


// type: Microsoft.AspNetCore.Connections.ConnectionHandler
    /**
    
            Represents an endpoint that multiple connections connect to. For HTTP, endpoints are URLs, for non-HTTP it can be a TCP listener (or similar).
            

    */
open class ConnectionHandler
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionHandler_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.Task OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionHandler.OnConnectedAsync(Microsoft.AspNetCore.Connections.ConnectionContext)
    /**
    
            Called when a new connection is accepted to the endpoint.
            

    - Parameter connection: The new 
    - Returns: A  that represents the connection lifetime. When the task completes, the connection is complete.

    */
    open func OnConnectedAsync(connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionHandler_Task__OnConnectedAsync_0__1__ConnectionContext(&__thrown, self.get_handle(), connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
} // ConnectionHandler


// type: Microsoft.AspNetCore.Connections.ConnectionItems
    /**
    
            The items associated with a given connection.
            

    */
open class ConnectionItems
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionItems_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionItems.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionItems_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IDictionary<System.Object,System.Object>)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionItems.#ctor(System.Collections.Generic.IDictionary{System.Object,System.Object})
    /**
    
            Initializes a new instance of  with .
            

    - Parameter items: The items for the connection.
    */
    public init(items : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionItems_ctor_0__1__System_Collections_Generic_IDictionary_object_object_(&__thrown, items.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_Items()
// docid: M:Microsoft.AspNetCore.Connections.ConnectionItems.get_Items
    open func get_Items() throws -> dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_ConnectionItems_System_Collections_Generic_IDictionary_object_object___get_Items_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IDictionary_2(hndl : __return);
        }
    }
    /**
    
            Gets or sets the items for the connection.
            

    */
    open var Items : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        get {
            return try! get_Items();
        }
    }
} // ConnectionItems


// type: Microsoft.AspNetCore.Connections.ConnectionResetException
    /**
    
            An exception thrown when the connection is reset.
            

    */
open class ConnectionResetException
    :
    dotnet.System.IO.IOException
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_ConnectionResetException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionResetException.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    */
    public init(message : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionResetException_ctor_0__1__String(&__thrown, message.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:Microsoft.AspNetCore.Connections.ConnectionResetException.#ctor(System.String,System.Exception)
    /**
    
            Initializes a new instance of .
            

    - Parameter message: The exception message.
    - Parameter inner: The underlying .
    */
    public init(message : dotnet.System.String, inner : dotnet.System.Exception) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_ConnectionResetException_ctor_0__2__String_Exception(&__thrown, message.get_handle(), inner.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ConnectionResetException


// type: Microsoft.AspNetCore.Connections.DefaultConnectionContext
    /**
    
            The default implementation for the .
            

    */
open class DefaultConnectionContext
    :
    aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,
    Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature,
    Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature,
    Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature,
    Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature,
    Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature,
    Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_DefaultConnectionContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.#ctor
    /**
    
            Creates the  without Pipes to avoid upfront allocations.
            The caller is expected to set the  and  pipes manually.
            

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_DefaultConnectionContext_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.#ctor(System.String)
    /**
    
            Creates the  without Pipes to avoid upfront allocations.
            The caller is expected to set the  and  pipes manually.
            

    - Parameter id: The .
    */
    public init(id : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_DefaultConnectionContext_ctor_0__1__String(&__thrown, id.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipelines.IDuplexPipe, System.IO.Pipelines.IDuplexPipe)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.#ctor(System.String,System.IO.Pipelines.IDuplexPipe,System.IO.Pipelines.IDuplexPipe)
    /**
    
            Creates the DefaultConnectionContext with the given  and  pipes.
            

    - Parameter id: The .
    - Parameter transport: The .
    - Parameter application: The .
    */
    public init(id : dotnet.System.String, transport : aspnetcore.System.IO.Pipelines.IDuplexPipe, application : aspnetcore.System.IO.Pipelines.IDuplexPipe) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_DefaultConnectionContext_ctor_0__3__String_IDuplexPipe_IDuplexPipe(&__thrown, id.get_handle(), transport.get_handle(), application.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.Abort(Microsoft.AspNetCore.Connections.ConnectionAbortedException)
    /**
    */
    open override func Abort(abortReason : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionAbortedException) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__Abort_0__1__ConnectionAbortedException(&__thrown, self.get_handle(), abortReason.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.DisposeAsync
    /**
    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_ConnectionId()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_ConnectionId
    open override func get_ConnectionId() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_String__get_ConnectionId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionId(System.String)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_ConnectionId(System.String)
    open override func set_ConnectionId(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_ConnectionId_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Features.IFeatureCollection get_Features()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_Features
    open override func get_Features() throws -> aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_IFeatureCollection__get_Features_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Claims.ClaimsPrincipal get_User()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_User
    open /* method final */ func get_User() throws -> Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_ClaimsPrincipal__get_User_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.ClaimsPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_User(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_User(System.Security.Claims.ClaimsPrincipal)
    open /* method final */ func set_User(value : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_User_0__1__ClaimsPrincipal(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_Items()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_Items
    open override func get_Items() throws -> dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_System_Collections_Generic_IDictionary_object_object___get_Items_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IDictionary_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Items(System.Collections.Generic.IDictionary<System.Object,System.Object>)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_Items(System.Collections.Generic.IDictionary{System.Object,System.Object})
    open override func set_Items(value : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_Items_0__1__System_Collections_Generic_IDictionary_object_object_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipelines.IDuplexPipe get_Application()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_Application
    open func get_Application() throws -> Optional<aspnetcore.System.IO.Pipelines.IDuplexPipe> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_IDuplexPipe__get_Application_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.System.IO.Pipelines.IDuplexPipe(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Application(System.IO.Pipelines.IDuplexPipe)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_Application(System.IO.Pipelines.IDuplexPipe)
    open func set_Application(value : Optional<aspnetcore.System.IO.Pipelines.IDuplexPipe>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_Application_0__1__IDuplexPipe(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipelines.IDuplexPipe get_Transport()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_Transport
    open override func get_Transport() throws -> aspnetcore.System.IO.Pipelines.IDuplexPipe {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_IDuplexPipe__get_Transport_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.IDuplexPipe(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Transport(System.IO.Pipelines.IDuplexPipe)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_Transport(System.IO.Pipelines.IDuplexPipe)
    open override func set_Transport(value : aspnetcore.System.IO.Pipelines.IDuplexPipe) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_Transport_0__1__IDuplexPipe(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ConnectionClosed()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_ConnectionClosed
    open override func get_ConnectionClosed() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_CancellationToken__get_ConnectionClosed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionClosed(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_ConnectionClosed(System.Threading.CancellationToken)
    open override func set_ConnectionClosed(value : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_ConnectionClosed_0__1__CancellationToken(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_LocalEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_LocalEndPoint
    open override func get_LocalEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_EndPoint__get_LocalEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LocalEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_LocalEndPoint(System.Net.EndPoint)
    open override func set_LocalEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_LocalEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_RemoteEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.get_RemoteEndPoint
    open override func get_RemoteEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_DefaultConnectionContext_EndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.DefaultConnectionContext.set_RemoteEndPoint(System.Net.EndPoint)
    open override func set_RemoteEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_DefaultConnectionContext_void__set_RemoteEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    */
    open var Application : Optional<aspnetcore.System.IO.Pipelines.IDuplexPipe> {
        get {
            return try! get_Application();
        }
        set(v) {
            return try! set_Application(value: v!);
        }
    }
    /**
    */
    open override var ConnectionClosed : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_ConnectionClosed();
        }
        set(v) {
            return try! set_ConnectionClosed(value: v);
        }
    }
    /**
    */
    open override var ConnectionId : dotnet.System.String {
        get {
            return try! get_ConnectionId();
        }
        set(v) {
            return try! set_ConnectionId(value: v);
        }
    }
    /**
    */
    open override var Features : aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection {
        get {
            return try! get_Features();
        }
    }
    /**
    */
    open override var Items : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        get {
            return try! get_Items();
        }
        set(v) {
            return try! set_Items(value: v);
        }
    }
    /**
    */
    open override var LocalEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_LocalEndPoint();
        }
        set(v) {
            return try! set_LocalEndPoint(value: v!);
        }
    }
    /**
    */
    open override var RemoteEndPoint : Optional<dotnet.System.Net.EndPoint> {
        get {
            return try! get_RemoteEndPoint();
        }
        set(v) {
            return try! set_RemoteEndPoint(value: v!);
        }
    }
    /**
    */
    open override var Transport : aspnetcore.System.IO.Pipelines.IDuplexPipe {
        get {
            return try! get_Transport();
        }
        set(v) {
            return try! set_Transport(value: v);
        }
    }
    /**
    */
    public var User : Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        get {
            return try! get_User();
        }
        set(v) {
            return try! set_User(value: v!);
        }
    }
} // DefaultConnectionContext


// type: Microsoft.AspNetCore.Connections.FileHandleEndPoint
    /**
    
            An endpoint backed by an OS file handle.
            

    */
open class FileHandleEndPoint
    :
    dotnet.System.Net.EndPoint
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_FileHandleEndPoint_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.UInt64, Microsoft.AspNetCore.Connections.FileHandleType)
// docid: M:Microsoft.AspNetCore.Connections.FileHandleEndPoint.#ctor(System.UInt64,Microsoft.AspNetCore.Connections.FileHandleType)
    /**
    
            Initializes a new instance of .
            

    - Parameter fileHandle: The file handle.
    - Parameter fileHandleType: The file handle type.
    */
    public init(fileHandle : Swift.UInt64, fileHandleType : aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_FileHandleEndPoint_ctor_0__2__u64_FileHandleType(&__thrown, fileHandle, fileHandleType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.UInt64 get_FileHandle()
// docid: M:Microsoft.AspNetCore.Connections.FileHandleEndPoint.get_FileHandle
    open func get_FileHandle() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_FileHandleEndPoint_u64__get_FileHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Connections.FileHandleType get_FileHandleType()
// docid: M:Microsoft.AspNetCore.Connections.FileHandleEndPoint.get_FileHandleType
    open func get_FileHandleType() throws -> aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_FileHandleEndPoint_FileHandleType__get_FileHandleType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType(val: __return);
        }
    }
    /**
    
            Gets the file handle.
            

    */
    open var FileHandle : Swift.UInt64 {
        get {
            return try! get_FileHandle();
        }
    }
    /**
    
            Gets the file handle type.
            

    */
    open var FileHandleType : aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType {
        get {
            return try! get_FileHandleType();
        }
    }
} // FileHandleEndPoint


// type: Microsoft.AspNetCore.Connections.FileHandleType
    /**
    
            Enumerates the  types.
            

    */
public struct FileHandleType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_FileHandleType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Connections.FileHandleType Auto
    public static var Auto : aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType(val: Microsoft_AspNetCore_Connections_FileHandleType_get_Auto());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Connections.FileHandleType Tcp
    public static var Tcp : aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType(val: Microsoft_AspNetCore_Connections_FileHandleType_get_Tcp());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Connections.FileHandleType Pipe
    public static var Pipe : aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Connections.FileHandleType(val: Microsoft_AspNetCore_Connections_FileHandleType_get_Pipe());
            return __return;
        }
    }
} // FileHandleType


// type: Microsoft.AspNetCore.Connections.IConnectionBuilder
    /**
    
            Defines an interface that provides the mechanisms to configure a connection pipeline.
            

    */
open class IConnectionBuilder
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IConnectionBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IConnectionBuilder_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.Connections.IConnectionBuilder Use(System.Func<Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate>)
// docid: M:Microsoft.AspNetCore.Connections.IConnectionBuilder.Use(System.Func{Microsoft.AspNetCore.Connections.ConnectionDelegate,Microsoft.AspNetCore.Connections.ConnectionDelegate})
    /**
    
            Adds a middleware delegate to the application's connection pipeline.
            

    - Parameter middleware: The middleware delegate.
    - Returns: The .

    */
    open func Use(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionBuilder_IConnectionBuilder__Use_0__1__System_Func_Microsoft_AspNetCore_Connections_ConnectionDelegate_Microsoft_AspNetCore_Connections_ConnectionDelegate_(&__thrown, self.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    open func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate>(middleware);
        return try Use(middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.ConnectionDelegate Build()
// docid: M:Microsoft.AspNetCore.Connections.IConnectionBuilder.Build
    /**
    
            Builds the delegate used by this application to process connections.
            

    - Returns: The connection handling delegate.

    */
    open func Build() throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionBuilder_ConnectionDelegate__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.ConnectionDelegate(hndl : __return);
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Connections.IConnectionBuilder.get_ApplicationServices
    open func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionBuilder_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
} // IConnectionBuilder


// type: Microsoft.AspNetCore.Connections.IConnectionFactory
    /**
    
            A factory abstraction for creating connections to an endpoint.
            

    */
open class IConnectionFactory
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IConnectionFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IConnectionFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext> ConnectAsync(System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IConnectionFactory.ConnectAsync(System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    
            Creates a new connection to an endpoint.
            

    - Parameter endpoint: The  to connect to.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: 
            A  that represents the asynchronous connect, yielding the  for the new connection when completed.
            

    */
    open func ConnectAsync(endpoint : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionFactory_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_ConnectionContext___ConnectAsync_0__2__EndPoint_CancellationToken(&__thrown, self.get_handle(), endpoint.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // IConnectionFactory


// type: Microsoft.AspNetCore.Connections.IConnectionListener
    /**
    
            Defines an interface that represents a listener bound to a specific .
            

    */
open class IConnectionListener
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IConnectionListener,
    System_IAsyncDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IConnectionListener_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext> AcceptAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IConnectionListener.AcceptAsync(System.Threading.CancellationToken)
    /**
    
            Begins an asynchronous operation to accept an incoming connection.
            

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that completes when a connection is accepted, yielding the  representing the connection.

    */
    open func AcceptAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionListener_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_ConnectionContext___AcceptAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask UnbindAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IConnectionListener.UnbindAsync(System.Threading.CancellationToken)
    /**
    
            Stops listening for incoming connections.
            

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that represents the un-bind operation.

    */
    open func UnbindAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionListener_ValueTask__UnbindAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_EndPoint()
// docid: M:Microsoft.AspNetCore.Connections.IConnectionListener.get_EndPoint
    open func get_EndPoint() throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionListener_EndPoint__get_EndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
} // IConnectionListener


// type: Microsoft.AspNetCore.Connections.IConnectionListenerFactory
    /**
    
            Defines an interface that provides the mechanisms for binding to various types of s.
            

    */
open class IConnectionListenerFactory
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IConnectionListenerFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IConnectionListenerFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.IConnectionListener> BindAsync(System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IConnectionListenerFactory.BindAsync(System.Net.EndPoint,System.Threading.CancellationToken)
    /**
    
            Creates an  bound to the specified .
            

    - Parameter endpoint: The  to bind to.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that completes when the listener has been bound, yielding a  representing the new listener.

    */
    open func BindAsync(endpoint : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionListener> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IConnectionListenerFactory_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_IConnectionListener___BindAsync_0__2__EndPoint_CancellationToken(&__thrown, self.get_handle(), endpoint.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // IConnectionListenerFactory


// type: Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder
    /**
    
            Defines an interface that provides the mechanisms to configure a connection pipeline.
            

    */
open class IMultiplexedConnectionBuilder
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder Use(System.Func<Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>)
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder.Use(System.Func{Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate})
    /**
    
            Adds a middleware delegate to the application's connection pipeline.
            

    - Parameter middleware: The middleware delegate.
    - Returns: The .

    */
    open func Use(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder_IMultiplexedConnectionBuilder__Use_0__1__System_Func_Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_(&__thrown, self.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    open func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>(middleware);
        return try Use(middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate Build()
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder.Build
    /**
    
            Builds the delegate used by this application to process connections.
            

    - Returns: The connection handling delegate.

    */
    open func Build() throws -> aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder_MultiplexedConnectionDelegate__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate(hndl : __return);
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder.get_ApplicationServices
    open func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
} // IMultiplexedConnectionBuilder


// type: Microsoft.AspNetCore.Connections.IMultiplexedConnectionFactory
    /**
    
            A factory abstraction for creating connections to an endpoint.
            

    */
open class IMultiplexedConnectionFactory
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IMultiplexedConnectionFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.MultiplexedConnectionContext> ConnectAsync(System.Net.EndPoint, Microsoft.AspNetCore.Http.Features.IFeatureCollection, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionFactory.ConnectAsync(System.Net.EndPoint,Microsoft.AspNetCore.Http.Features.IFeatureCollection,System.Threading.CancellationToken)
    /**
    
            Creates a new connection to an endpoint.
            

    - Parameter endpoint: The  to connect to.
    - Parameter features: A feature collection to pass options when connecting.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: 
            A  that represents the asynchronous connect, yielding the  for the new connection when completed.
            

    */
    open func ConnectAsync(endpoint : dotnet.System.Net.EndPoint, features : Optional<aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection> = nil, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionFactory_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_MultiplexedConnectionContext___ConnectAsync_0__3__EndPoint_IFeatureCollection_CancellationToken(&__thrown, self.get_handle(), endpoint.get_handle(), features?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // IMultiplexedConnectionFactory


// type: Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener
    /**
    
            Defines an interface that represents a listener bound to a specific .
            

    */
open class IMultiplexedConnectionListener
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener,
    System_IAsyncDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask UnbindAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener.UnbindAsync(System.Threading.CancellationToken)
    /**
    
            Stops listening for incoming connections.
            

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that represents the un-bind operation.

    */
    open func UnbindAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener_ValueTask__UnbindAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.MultiplexedConnectionContext> AcceptAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener.AcceptAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection,System.Threading.CancellationToken)
    /**
    
            Begins an asynchronous operation to accept an incoming connection.
            

    - Parameter features: A feature collection to pass options when accepting a connection.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that completes when a connection is accepted, yielding the  representing the connection.

    */
    open func AcceptAsync(features : Optional<aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection> = nil, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_MultiplexedConnectionContext___AcceptAsync_0__2__IFeatureCollection_CancellationToken(&__thrown, self.get_handle(), features?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_EndPoint()
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener.get_EndPoint
    open func get_EndPoint() throws -> dotnet.System.Net.EndPoint {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener_EndPoint__get_EndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.EndPoint(hndl : __return);
        }
    }
} // IMultiplexedConnectionListener


// type: Microsoft.AspNetCore.Connections.IMultiplexedConnectionListenerFactory
    /**
    
            Defines an interface that provides the mechanisms for binding to various types of s.
            

    */
open class IMultiplexedConnectionListenerFactory
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionListenerFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_IMultiplexedConnectionListenerFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener> BindAsync(System.Net.EndPoint, Microsoft.AspNetCore.Http.Features.IFeatureCollection, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.IMultiplexedConnectionListenerFactory.BindAsync(System.Net.EndPoint,Microsoft.AspNetCore.Http.Features.IFeatureCollection,System.Threading.CancellationToken)
    /**
    
            Creates an  bound to the specified .
            

    - Parameter endpoint: The  to bind to.
    - Parameter features: A feature collection to pass options when binding.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that completes when the listener has been bound, yielding a  representing the new listener.

    */
    open func BindAsync(endpoint : dotnet.System.Net.EndPoint, features : Optional<aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection> = nil, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionListener> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_IMultiplexedConnectionListenerFactory_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener___BindAsync_0__3__EndPoint_IFeatureCollection_CancellationToken(&__thrown, self.get_handle(), endpoint.get_handle(), features?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // IMultiplexedConnectionListenerFactory


// type: Microsoft.AspNetCore.Connections.MultiplexedConnectionBuilder
    /**
    
            A default implementation for .
            

    */
open class MultiplexedConnectionBuilder
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_MultiplexedConnectionBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionBuilder.#ctor(System.IServiceProvider)
    /**
    
            Initializes a new instance of .
            

    - Parameter applicationServices: The application services .
    */
    public init(applicationServices : dotnet.System.IServiceProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_MultiplexedConnectionBuilder_ctor_0__1__IServiceProvider(&__thrown, applicationServices.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder Use(System.Func<Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionBuilder.Use(System.Func{Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate})
    /**
    */
    open /* method final */ func Use(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionBuilder_IMultiplexedConnectionBuilder__Use_0__1__System_Func_Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_(&__thrown, self.get_handle(), middleware.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    open /* method final */ func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IMultiplexedConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate,aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate>(middleware);
        return try Use(middleware: del_middleware);
    }
    // Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate Build()
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionBuilder.Build
    /**
    */
    open /* method final */ func Build() throws -> aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionBuilder_MultiplexedConnectionDelegate__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate(hndl : __return);
        }
    }
    // [IsSpecialName] System.IServiceProvider get_ApplicationServices()
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionBuilder.get_ApplicationServices
    open /* method final */ func get_ApplicationServices() throws -> dotnet.System.IServiceProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionBuilder_IServiceProvider__get_ApplicationServices_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IServiceProvider(hndl : __return);
        }
    }
    /**
    */
    public var ApplicationServices : dotnet.System.IServiceProvider {
        get {
            return try! get_ApplicationServices();
        }
    }
} // MultiplexedConnectionBuilder


// type: Microsoft.AspNetCore.Connections.MultiplexedConnectionContext
    /**
    
            Encapsulates all information about a multiplexed connection.
            

    */
open class MultiplexedConnectionContext
    :
    aspnetcore.Microsoft.AspNetCore.Connections.BaseConnectionContext
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_MultiplexedConnectionContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext> AcceptAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.AcceptAsync(System.Threading.CancellationToken)
    /**
    
            Asynchronously accept an incoming stream on the connection.
            

    - Parameter cancellationToken: 
    - Returns: 

    */
    open func AcceptAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionContext_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_ConnectionContext___AcceptAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.ConnectionContext> ConnectAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionContext.ConnectAsync(Microsoft.AspNetCore.Http.Features.IFeatureCollection,System.Threading.CancellationToken)
    /**
    
            Creates an outbound connection
            

    - Parameter features: 
    - Parameter cancellationToken: 
    - Returns: 

    */
    open func ConnectAsync(features : Optional<aspnetcore.Microsoft.AspNetCore.Http.Features.IFeatureCollection> = nil, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionContext_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_ConnectionContext___ConnectAsync_0__2__IFeatureCollection_CancellationToken(&__thrown, self.get_handle(), features?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // MultiplexedConnectionContext


// type: Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate
    /**
    
            A function that can process a connection.
            

    */
public final class MultiplexedConnectionDelegate
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.Task Invoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate.Invoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext)
    public func Invoke(connection : aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_Task__Invoke_0__1__MultiplexedConnectionContext(&__thrown, self.get_handle(), connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext, System.AsyncCallback, System.Object)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate.BeginInvoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext,System.AsyncCallback,System.Object)
    public func BeginInvoke(connection : aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_IAsyncResult__BeginInvoke_0__3__MultiplexedConnectionContext_AsyncCallback_Object(&__thrown, self.get_handle(), connection.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task EndInvoke(System.IAsyncResult)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_Task__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    public init(_ callback : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext) throws -> dotnet.System.Threading.Tasks.Task) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, connection : NonnullHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext(hndl: connection));
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, connection : NonnullHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle;
            return f(thrown, connection);
        }
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task Invoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext)
// docid: M:Microsoft.AspNetCore.Connections.MultiplexedConnectionDelegate.Invoke(Microsoft.AspNetCore.Connections.MultiplexedConnectionContext)
    public func callAsFunction(connection : aspnetcore.Microsoft.AspNetCore.Connections.MultiplexedConnectionContext) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_MultiplexedConnectionDelegate_Task__Invoke_0__1__MultiplexedConnectionContext(&__thrown, self.get_handle(), connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
} // MultiplexedConnectionDelegate


// type: Microsoft.AspNetCore.Connections.TransferFormat
    /**
    
            Represents the possible transfer formats.
            

    */
public struct TransferFormat : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_TransferFormat_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.Connections.TransferFormat Binary
    public static var Binary : aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat(val: Microsoft_AspNetCore_Connections_TransferFormat_get_Binary());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.Connections.TransferFormat Text
    public static var Text : aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat(val: Microsoft_AspNetCore_Connections_TransferFormat_get_Text());
            return __return;
        }
    }
} // TransferFormat


// type: Microsoft.AspNetCore.Connections.UriEndPoint
    /**
    
            An  defined by a .
            

    */
open class UriEndPoint
    :
    dotnet.System.Net.EndPoint
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_UriEndPoint_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Uri)
// docid: M:Microsoft.AspNetCore.Connections.UriEndPoint.#ctor(System.Uri)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter uri: The  defining the .
    */
    public init(uri : dotnet.System.Uri) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Connections_UriEndPoint_ctor_0__1__Uri(&__thrown, uri.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Connections.UriEndPoint.ToString
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_UriEndPoint_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Uri get_Uri()
// docid: M:Microsoft.AspNetCore.Connections.UriEndPoint.get_Uri
    open func get_Uri() throws -> dotnet.System.Uri {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_UriEndPoint_Uri__get_Uri_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Uri(hndl : __return);
        }
    }
    /**
    
            The  defining the .
            

    */
    open var Uri : dotnet.System.Uri {
        get {
            return try! get_Uri();
        }
    }
} // UriEndPoint


}
// Microsoft.AspNetCore.Connections.Features
extension Microsoft.AspNetCore.Connections.Features {
// type: Microsoft.AspNetCore.Connections.Features.IConnectionCompleteFeature
    /**
    
            Represents the completion action for a connection.
            

    */
open class IConnectionCompleteFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionCompleteFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionCompleteFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void OnCompleted(System.Func<System.Object,System.Threading.Tasks.Task>, System.Object)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionCompleteFeature.OnCompleted(System.Func{System.Object,System.Threading.Tasks.Task},System.Object)
    /**
    
            Registers a callback to be invoked after a connection has fully completed processing. This is
            intended for resource cleanup.
            

    - Parameter callback: The callback to invoke after the connection has completed processing.
    - Parameter state: The state to pass into the callback.
    */
    open func OnCompleted(callback : dotnet.System.Func_2<dotnet.System.Object,dotnet.System.Threading.Tasks.Task>, state : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionCompleteFeature_void__OnCompleted_0__2__System_Func_object_Task__Object(&__thrown, self.get_handle(), callback.get_handle(), state.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func OnCompleted(callback : @escaping (Optional<dotnet.System.Object>) throws -> dotnet.System.Threading.Tasks.Task, state : dotnet.System.Object) throws {
        let del_callback = try dotnet.System.Func_2<dotnet.System.Object,dotnet.System.Threading.Tasks.Task>(callback);
        return try OnCompleted(callback: del_callback, state: state);
    }
} // IConnectionCompleteFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionEndPointFeature
    /**
    
            A feature that represents a connection endpoints.
            

    */
open class IConnectionEndPointFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Net.EndPoint get_LocalEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.get_LocalEndPoint
    open func get_LocalEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature_EndPoint__get_LocalEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LocalEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.set_LocalEndPoint(System.Net.EndPoint)
    open func set_LocalEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature_void__set_LocalEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.EndPoint get_RemoteEndPoint()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.get_RemoteEndPoint
    open func get_RemoteEndPoint() throws -> Optional<dotnet.System.Net.EndPoint> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature_EndPoint__get_RemoteEndPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.EndPoint(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteEndPoint(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionEndPointFeature.set_RemoteEndPoint(System.Net.EndPoint)
    open func set_RemoteEndPoint(value : Optional<dotnet.System.Net.EndPoint>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature_void__set_RemoteEndPoint_0__1__EndPoint(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionEndPointFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionHeartbeatFeature
    /**
    
            A feature that represents the connection heartbeat.
            

    */
open class IConnectionHeartbeatFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionHeartbeatFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionHeartbeatFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void OnHeartbeat(System.Action<System.Object>, System.Object)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionHeartbeatFeature.OnHeartbeat(System.Action{System.Object},System.Object)
    /**
    
            Registers the given  to be called with the associated  on each heartbeat of the connection.
            

    - Parameter action: The  to invoke.
    - Parameter state: The state for the .
    */
    open func OnHeartbeat(action : dotnet.System.Action_1<dotnet.System.Object>, state : dotnet.System.Object) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionHeartbeatFeature_void__OnHeartbeat_0__2__System_Action_object__Object(&__thrown, self.get_handle(), action.get_handle(), state.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func OnHeartbeat(action : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : dotnet.System.Object) throws {
        let del_action = try dotnet.System.Action_1<dotnet.System.Object>(action);
        return try OnHeartbeat(action: del_action, state: state);
    }
} // IConnectionHeartbeatFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionIdFeature
    /**
    
            The unique identifier for a given connection.
            

    */
open class IConnectionIdFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.String get_ConnectionId()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionIdFeature.get_ConnectionId
    open func get_ConnectionId() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature_String__get_ConnectionId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionId(System.String)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionIdFeature.set_ConnectionId(System.String)
    open func set_ConnectionId(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature_void__set_ConnectionId_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionIdFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionInherentKeepAliveFeature
    /**
    
            Indicates if the connection transport has an "inherent keep-alive", which means that the transport will automatically
            inform the client that it is still present.
            

    */
open class IConnectionInherentKeepAliveFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionInherentKeepAliveFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionInherentKeepAliveFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] bool get_HasInherentKeepAlive()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionInherentKeepAliveFeature.get_HasInherentKeepAlive
    open func get_HasInherentKeepAlive() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionInherentKeepAliveFeature_bool__get_HasInherentKeepAlive_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IConnectionInherentKeepAliveFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature
    /**
    
            A bag of items associated with a given connection.
            

    */
open class IConnectionItemsFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_Items()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.get_Items
    open func get_Items() throws -> dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature_System_Collections_Generic_IDictionary_object_object___get_Items_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IDictionary_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Items(System.Collections.Generic.IDictionary<System.Object,System.Object>)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionItemsFeature.set_Items(System.Collections.Generic.IDictionary{System.Object,System.Object})
    open func set_Items(value : dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature_void__set_Items_0__1__System_Collections_Generic_IDictionary_object_object_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionItemsFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature
    /**
    
            Represents the lifetime of the connection.
            

    */
open class IConnectionLifetimeFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Abort()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.Abort
    /**
    
            Terminates the current connection.
            

    */
    open func Abort() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature_void__Abort_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ConnectionClosed()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.get_ConnectionClosed
    open func get_ConnectionClosed() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature_CancellationToken__get_ConnectionClosed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionClosed(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeFeature.set_ConnectionClosed(System.Threading.CancellationToken)
    open func set_ConnectionClosed(value : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature_void__set_ConnectionClosed_0__1__CancellationToken(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionLifetimeFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature
    /**
    
            Enables graceful termination of the connection.
            

    */
open class IConnectionLifetimeNotificationFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void RequestClose()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.RequestClose
    /**
    
            Requests the connection to be closed.
            

    */
    open func RequestClose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature_void__RequestClose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ConnectionClosedRequested()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.get_ConnectionClosedRequested
    open func get_ConnectionClosedRequested() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature_CancellationToken__get_ConnectionClosedRequested_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ConnectionClosedRequested(System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionLifetimeNotificationFeature.set_ConnectionClosedRequested(System.Threading.CancellationToken)
    open func set_ConnectionClosedRequested(value : dotnet.System.Threading.CancellationToken) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature_void__set_ConnectionClosedRequested_0__1__CancellationToken(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionLifetimeNotificationFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionSocketFeature
    /**
    
            Provides access to the connection's underlying .
            

    */
open class IConnectionSocketFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionSocketFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionSocketFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Net.Sockets.Socket get_Socket()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionSocketFeature.get_Socket
    open func get_Socket() throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionSocketFeature_Socket__get_Socket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
} // IConnectionSocketFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature
    /**
    
            The transport for the connection.
            

    */
open class IConnectionTransportFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.IO.Pipelines.IDuplexPipe get_Transport()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature.get_Transport
    open func get_Transport() throws -> aspnetcore.System.IO.Pipelines.IDuplexPipe {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature_IDuplexPipe__get_Transport_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.IDuplexPipe(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Transport(System.IO.Pipelines.IDuplexPipe)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionTransportFeature.set_Transport(System.IO.Pipelines.IDuplexPipe)
    open func set_Transport(value : aspnetcore.System.IO.Pipelines.IDuplexPipe) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature_void__set_Transport_0__1__IDuplexPipe(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionTransportFeature


// type: Microsoft.AspNetCore.Connections.Features.IConnectionUserFeature
    /**
    
            The user associated with the connection.
            

    */
open class IConnectionUserFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Security.Claims.ClaimsPrincipal get_User()
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionUserFeature.get_User
    open func get_User() throws -> Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature_ClaimsPrincipal__get_User_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.ClaimsPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_User(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Connections.Features.IConnectionUserFeature.set_User(System.Security.Claims.ClaimsPrincipal)
    open func set_User(value : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature_void__set_User_0__1__ClaimsPrincipal(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IConnectionUserFeature


// type: Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature
    /**
    
            The  used by the connection.
            

    */
open class IMemoryPoolFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IMemoryPoolFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IMemoryPoolFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Buffers.MemoryPool<System.Byte> get_MemoryPool()
// docid: M:Microsoft.AspNetCore.Connections.Features.IMemoryPoolFeature.get_MemoryPool
    open func get_MemoryPool() throws -> dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IMemoryPoolFeature_System_Buffers_MemoryPool_u8___get_MemoryPool_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.MemoryPool_1(hndl : __return);
        }
    }
} // IMemoryPoolFeature


// type: Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature
    /**
    
            Provides access to a key/value collection that can be used to persist state between connections and requests.
            Whether a transport supports persisting state depends on the implementation. The transport must support
            pooling and reusing connection instances for state to be persisted.
            
            Because values added to persistent state can live in memory until a connection is no longer pooled,
            use caution when adding items to this collection to avoid excessive memory use.
            
            

    */
open class IPersistentStateFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IPersistentStateFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IPersistentStateFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_State()
// docid: M:Microsoft.AspNetCore.Connections.Features.IPersistentStateFeature.get_State
    open func get_State() throws -> dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IPersistentStateFeature_System_Collections_Generic_IDictionary_object_object___get_State_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IDictionary_2(hndl : __return);
        }
    }
} // IPersistentStateFeature


// type: Microsoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature
    /**
    
            The error code for the protocol being used.
            

    */
open class IProtocolErrorCodeFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IProtocolErrorCodeFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IProtocolErrorCodeFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Int64 get_Error()
// docid: M:Microsoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature.get_Error
    open func get_Error() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IProtocolErrorCodeFeature_i64__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Error(System.Int64)
// docid: M:Microsoft.AspNetCore.Connections.Features.IProtocolErrorCodeFeature.set_Error(System.Int64)
    open func set_Error(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IProtocolErrorCodeFeature_void__set_Error_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IProtocolErrorCodeFeature


// type: Microsoft.AspNetCore.Connections.Features.IStreamAbortFeature
    /**
    
            Supports aborting individual sides of a connection stream.
            

    */
open class IStreamAbortFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IStreamAbortFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IStreamAbortFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void AbortRead(System.Int64, Microsoft.AspNetCore.Connections.ConnectionAbortedException)
// docid: M:Microsoft.AspNetCore.Connections.Features.IStreamAbortFeature.AbortRead(System.Int64,Microsoft.AspNetCore.Connections.ConnectionAbortedException)
    /**
    
            Abort the read side of the connection stream.
            

    - Parameter errorCode: The error code to send with the abort.
    - Parameter abortReason: A  describing the reason to abort the read side of the connection stream.
    */
    open func AbortRead(errorCode : Swift.Int64, abortReason : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionAbortedException) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IStreamAbortFeature_void__AbortRead_0__2__i64_ConnectionAbortedException(&__thrown, self.get_handle(), errorCode, abortReason.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AbortWrite(System.Int64, Microsoft.AspNetCore.Connections.ConnectionAbortedException)
// docid: M:Microsoft.AspNetCore.Connections.Features.IStreamAbortFeature.AbortWrite(System.Int64,Microsoft.AspNetCore.Connections.ConnectionAbortedException)
    /**
    
            Abort the write side of the connection stream.
            

    - Parameter errorCode: The error code to send with the abort.
    - Parameter abortReason: A  describing the reason to abort the write side of the connection stream.
    */
    open func AbortWrite(errorCode : Swift.Int64, abortReason : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionAbortedException) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_IStreamAbortFeature_void__AbortWrite_0__2__i64_ConnectionAbortedException(&__thrown, self.get_handle(), errorCode, abortReason.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IStreamAbortFeature


// type: Microsoft.AspNetCore.Connections.Features.IStreamDirectionFeature
    /**
    
            The direction of a connection stream
            

    */
open class IStreamDirectionFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IStreamDirectionFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IStreamDirectionFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] bool get_CanRead()
// docid: M:Microsoft.AspNetCore.Connections.Features.IStreamDirectionFeature.get_CanRead
    open func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IStreamDirectionFeature_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:Microsoft.AspNetCore.Connections.Features.IStreamDirectionFeature.get_CanWrite
    open func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IStreamDirectionFeature_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IStreamDirectionFeature


// type: Microsoft.AspNetCore.Connections.Features.IStreamIdFeature
    /**
    
            Represents the identifier for the stream.
            

    */
open class IStreamIdFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_IStreamIdFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_IStreamIdFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Int64 get_StreamId()
// docid: M:Microsoft.AspNetCore.Connections.Features.IStreamIdFeature.get_StreamId
    open func get_StreamId() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_IStreamIdFeature_i64__get_StreamId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // IStreamIdFeature


// type: Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature
    /**
    
            Represents the details about the TLS handshake.
            

    */
open class ITlsHandshakeFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Security.Authentication.SslProtocols get_Protocol()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_Protocol
    open func get_Protocol() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_SslProtocols__get_Protocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Authentication.CipherAlgorithmType get_CipherAlgorithm()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherAlgorithm
    open func get_CipherAlgorithm() throws -> dotnet.System.Security.Authentication.CipherAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_CipherAlgorithmType__get_CipherAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.CipherAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_CipherStrength()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_CipherStrength
    open func get_CipherStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_i32__get_CipherStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Authentication.HashAlgorithmType get_HashAlgorithm()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashAlgorithm
    open func get_HashAlgorithm() throws -> dotnet.System.Security.Authentication.HashAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_HashAlgorithmType__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.HashAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_HashStrength()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_HashStrength
    open func get_HashStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_i32__get_HashStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExchangeAlgorithmType get_KeyExchangeAlgorithm()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeAlgorithm
    open func get_KeyExchangeAlgorithm() throws -> dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_ExchangeAlgorithmType__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_KeyExchangeStrength()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITlsHandshakeFeature.get_KeyExchangeStrength
    open func get_KeyExchangeStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature_i32__get_KeyExchangeStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // ITlsHandshakeFeature


// type: Microsoft.AspNetCore.Connections.Features.ITransferFormatFeature
    /**
    
            Gets the transfer format of the protocol.
            

    */
open class ITransferFormatFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.AspNetCore.Connections.TransferFormat get_SupportedFormats()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITransferFormatFeature.get_SupportedFormats
    open func get_SupportedFormats() throws -> aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature_TransferFormat__get_SupportedFormats_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat(val: __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Connections.TransferFormat get_ActiveFormat()
// docid: M:Microsoft.AspNetCore.Connections.Features.ITransferFormatFeature.get_ActiveFormat
    open func get_ActiveFormat() throws -> aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature_TransferFormat__get_ActiveFormat_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat(val: __return);
        }
    }
    // [IsSpecialName] void set_ActiveFormat(Microsoft.AspNetCore.Connections.TransferFormat)
// docid: M:Microsoft.AspNetCore.Connections.Features.ITransferFormatFeature.set_ActiveFormat(Microsoft.AspNetCore.Connections.TransferFormat)
    open func set_ActiveFormat(value : aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature_void__set_ActiveFormat_0__1__TransferFormat(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ITransferFormatFeature


}




public protocol Microsoft_AspNetCore_Connections_Features_IConnectionCompleteFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionEndPointFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionHeartbeatFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionIdFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionInherentKeepAliveFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionItemsFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionLifetimeNotificationFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionSocketFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionTransportFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IConnectionUserFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IMemoryPoolFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IPersistentStateFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IProtocolErrorCodeFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IStreamAbortFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IStreamDirectionFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_IStreamIdFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_ITlsHandshakeFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_Features_ITransferFormatFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IConnectionBuilder
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IConnectionFactory
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IConnectionListener
    :
    System_IAsyncDisposable
{
}

public protocol Microsoft_AspNetCore_Connections_IConnectionListenerFactory
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IMultiplexedConnectionBuilder
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IMultiplexedConnectionFactory
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Connections_IMultiplexedConnectionListener
    :
    System_IAsyncDisposable
{
}

public protocol Microsoft_AspNetCore_Connections_IMultiplexedConnectionListenerFactory
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Connections.IConnectionBuilder UseConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Connections.IConnectionBuilder)
// TODO COPE extension method (unused generic param) Microsoft.AspNetCore.Connections.IConnectionBuilder UseConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Connections.IConnectionBuilder)

// EXTENSION METHOD Microsoft.AspNetCore.Connections.IConnectionBuilder Use(Microsoft.AspNetCore.Connections.IConnectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.Func<System.Threading.Tasks.Task>,System.Threading.Tasks.Task>)
extension Microsoft_AspNetCore_Connections_IConnectionBuilder {
    public func Use(middleware : dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>,dotnet.System.Threading.Tasks.Task>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(connectionBuilder: aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl: __copy_handle(self.get_handle())), middleware: middleware);
    }
    // delegate closure overload
    public func Use(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>, Optional<dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>>) throws -> dotnet.System.Threading.Tasks.Task) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_3<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Func_1<dotnet.System.Threading.Tasks.Task>,dotnet.System.Threading.Tasks.Task>(middleware);
        return try aspnetcore.Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Use(connectionBuilder: aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl: __copy_handle(self.get_handle())), middleware: del_middleware);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Connections.IConnectionBuilder Run(Microsoft.AspNetCore.Connections.IConnectionBuilder, System.Func<Microsoft.AspNetCore.Connections.ConnectionContext,System.Threading.Tasks.Task>)
extension Microsoft_AspNetCore_Connections_IConnectionBuilder {
    public func Run(middleware : dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Threading.Tasks.Task>) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(connectionBuilder: aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl: __copy_handle(self.get_handle())), middleware: middleware);
    }
    // delegate closure overload
    public func Run(middleware : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext>) throws -> dotnet.System.Threading.Tasks.Task) throws -> aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder {
        let del_middleware = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext,dotnet.System.Threading.Tasks.Task>(middleware);
        return try aspnetcore.Microsoft.AspNetCore.Connections.ConnectionBuilderExtensions.Run(connectionBuilder: aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder(hndl: __copy_handle(self.get_handle())), middleware: del_middleware);
    }
}

