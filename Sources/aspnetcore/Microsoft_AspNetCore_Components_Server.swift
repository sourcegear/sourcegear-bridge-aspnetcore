// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Builder
extension Microsoft.AspNetCore.Builder {
// type: Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder
    /**
    
            Builds conventions that will be used for customization of ComponentHub  instances.
            

    */
public final class ComponentEndpointConventionBuilder
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Builder_IHubEndpointConventionBuilder,
    Microsoft_AspNetCore_Builder_IEndpointConventionBuilder
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Builder_ComponentEndpointConventionBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Add(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder>)
// docid: M:Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder.Add(System.Action{Microsoft.AspNetCore.Builder.EndpointBuilder})
    /**
    
            Adds the specified convention to the builder. Conventions are used to customize  instances.
            

    - Parameter convention: The convention to add to the builder.
    */
    public func Add(convention : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Builder_ComponentEndpointConventionBuilder_void__Add_0__1__System_Action_Microsoft_AspNetCore_Builder_EndpointBuilder_(&__thrown, self.get_handle(), convention.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public func Add(convention : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder>) throws -> Void) throws {
        let del_convention = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder>(convention);
        return try Add(convention: del_convention);
    }
} // ComponentEndpointConventionBuilder


// type: Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions
public struct ComponentEndpointRouteBuilderExtensions {
    // Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder)
// docid: M:Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder)
    /**
    
            Maps the Blazor  to the default path.
            

    - Parameter endpoints: The .
    - Returns: The .

    */
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ComponentEndpointRouteBuilderExtensions_ComponentEndpointConventionBuilder__MapBlazorHub_0__1__IEndpointRouteBuilder(&__thrown, endpoints.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String)
// docid: M:Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.String)
    /**
    
            Maps the Blazor  to the path .
            

    - Parameter endpoints: The .
    - Parameter path: The path to map the Blazor .
    - Returns: The .

    */
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, path : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ComponentEndpointRouteBuilderExtensions_ComponentEndpointConventionBuilder__MapBlazorHub_0__2__IEndpointRouteBuilder_String(&__thrown, endpoints.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
// docid: M:Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.Action{Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions})
    /**
    
            Maps the Blazor  to the default path.
             

    - Parameter endpoints: The .
    - Parameter configureOptions: A callback to configure dispatcher options.
    - Returns: The .

    */
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ComponentEndpointRouteBuilderExtensions_ComponentEndpointConventionBuilder__MapBlazorHub_0__2__IEndpointRouteBuilder_System_Action_Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_(&__thrown, endpoints.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>(configureOptions);
        return try MapBlazorHub(endpoints: endpoints, configureOptions: del_configureOptions);
    }
    // Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
// docid: M:Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.String,System.Action{Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions})
    /**
    
            Maps the Blazor  to the path .
            

    - Parameter endpoints: The .
    - Parameter path: The path to map the Blazor .
    - Parameter configureOptions: A callback to configure dispatcher options.
    - Returns: The .

    */
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, path : dotnet.System.String, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ComponentEndpointRouteBuilderExtensions_ComponentEndpointConventionBuilder__MapBlazorHub_0__3__IEndpointRouteBuilder_String_System_Action_Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_(&__thrown, endpoints.get_handle(), path.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func MapBlazorHub(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, path : dotnet.System.String, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>(configureOptions);
        return try MapBlazorHub(endpoints: endpoints, path: path, configureOptions: del_configureOptions);
    }
} // ComponentEndpointRouteBuilderExtensions


}

// Microsoft.AspNetCore.Components
// Microsoft.AspNetCore.Components.Server
extension Microsoft.AspNetCore.Components.Server {
// type: Microsoft.AspNetCore.Components.Server.CircuitOptions
    /**
    
            Options to configure circuit handler for server-side Blazor
            

    */
public final class CircuitOptions
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_CircuitOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_CircuitOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_DisconnectedCircuitMaxRetained()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_DisconnectedCircuitMaxRetained
    public func get_DisconnectedCircuitMaxRetained() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_i32__get_DisconnectedCircuitMaxRetained_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_DisconnectedCircuitMaxRetained(System.Int32)
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.set_DisconnectedCircuitMaxRetained(System.Int32)
    public func set_DisconnectedCircuitMaxRetained(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Components_Server_CircuitOptions_void__set_DisconnectedCircuitMaxRetained_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_DisconnectedCircuitRetentionPeriod()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_DisconnectedCircuitRetentionPeriod
    public func get_DisconnectedCircuitRetentionPeriod() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_TimeSpan__get_DisconnectedCircuitRetentionPeriod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_DisconnectedCircuitRetentionPeriod(System.TimeSpan)
    // [IsSpecialName] bool get_DetailedErrors()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_DetailedErrors
    public func get_DetailedErrors() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_bool__get_DetailedErrors_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_DetailedErrors(bool)
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.set_DetailedErrors(System.Boolean)
    public func set_DetailedErrors(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Components_Server_CircuitOptions_void__set_DetailedErrors_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_JSInteropDefaultCallTimeout()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_JSInteropDefaultCallTimeout
    public func get_JSInteropDefaultCallTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_TimeSpan__get_JSInteropDefaultCallTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_JSInteropDefaultCallTimeout(System.TimeSpan)
    // [IsSpecialName] System.Int32 get_MaxBufferedUnacknowledgedRenderBatches()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_MaxBufferedUnacknowledgedRenderBatches
    public func get_MaxBufferedUnacknowledgedRenderBatches() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_i32__get_MaxBufferedUnacknowledgedRenderBatches_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxBufferedUnacknowledgedRenderBatches(System.Int32)
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.set_MaxBufferedUnacknowledgedRenderBatches(System.Int32)
    public func set_MaxBufferedUnacknowledgedRenderBatches(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Components_Server_CircuitOptions_void__set_MaxBufferedUnacknowledgedRenderBatches_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions get_RootComponents()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitOptions.get_RootComponents
    public func get_RootComponents() throws -> aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitOptions_CircuitRootComponentOptions__get_RootComponents_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions(hndl : __return);
        }
    }
    /**
    
            Gets or sets a value that determines whether or not to send detailed exception messages to JavaScript when an unhandled exception
            happens on the circuit or when a .NET method invocation through JS interop results in an exception.
            

    */
    public var DetailedErrors : Bool {
        get {
            return try! get_DetailedErrors();
        }
        set(v) {
            return try! set_DetailedErrors(value: v);
        }
    }
    /**
    
            Gets or sets a value that determines the maximum number of disconnected circuit state details
            are retained by the server.
            
            When a client disconnects, ASP.NET Core Components attempts to retain state on the server for an
            interval. This allows the client to re-establish a connection to the existing circuit on the server
            without losing any state in the event of transient connection issues.
            
            
            This value determines the maximum number of circuit states retained by the server.
            
            
            

    */
    public var DisconnectedCircuitMaxRetained : Swift.Int32 {
        get {
            return try! get_DisconnectedCircuitMaxRetained();
        }
        set(v) {
            return try! set_DisconnectedCircuitMaxRetained(value: v);
        }
    }
    /**
    
            Gets or sets a value that determines the maximum duration state for a disconnected circuit is
            retained on the server.
            
            When a client disconnects, ASP.NET Core Components attempts to retain state on the server for an
            interval. This allows the client to re-establish a connection to the existing circuit on the server
            without losing any state in the event of transient connection issues.
            
            
            This value determines the maximum duration circuit state is retained by the server before being evicted.
            
            
            

    */
    public var DisconnectedCircuitRetentionPeriod : dotnet.System.TimeSpan {
        get {
            return try! get_DisconnectedCircuitRetentionPeriod();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_DisconnectedCircuitRetentionPeriod(System.TimeSpan)
    }
    /**
    
            Gets or sets a value that indicates how long the server will wait before timing out an asynchronous JavaScript function invocation.
            

    */
    public var JSInteropDefaultCallTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_JSInteropDefaultCallTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_JSInteropDefaultCallTimeout(System.TimeSpan)
    }
    /**
    
            Gets or sets the maximum number of render batches that a circuit will buffer until an acknowledgement for the batch is
            received.
            

    */
    public var MaxBufferedUnacknowledgedRenderBatches : Swift.Int32 {
        get {
            return try! get_MaxBufferedUnacknowledgedRenderBatches();
        }
        set(v) {
            return try! set_MaxBufferedUnacknowledgedRenderBatches(value: v);
        }
    }
    /**
    
            Gets options for root components within the circuit.
            

    */
    public var RootComponents : aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions {
        get {
            return try! get_RootComponents();
        }
    }
} // CircuitOptions


// type: Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions
    /**
    
            Options for root components within the circuit.
            

    */
open class CircuitRootComponentOptions
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Components_Web_IJSComponentConfiguration
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_CircuitRootComponentOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_CircuitRootComponentOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore get_JSComponents()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions.get_JSComponents
    open /* method final */ func get_JSComponents() throws -> aspnetcore.Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitRootComponentOptions_JSComponentConfigurationStore__get_JSComponents_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxJSRootComponents()
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions.get_MaxJSRootComponents
    open func get_MaxJSRootComponents() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_CircuitRootComponentOptions_i32__get_MaxJSRootComponents_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MaxJSRootComponents(System.Int32)
// docid: M:Microsoft.AspNetCore.Components.Server.CircuitRootComponentOptions.set_MaxJSRootComponents(System.Int32)
    open func set_MaxJSRootComponents(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Components_Server_CircuitRootComponentOptions_void__set_MaxJSRootComponents_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    */
    public var JSComponents : aspnetcore.Microsoft.AspNetCore.Components.Web.JSComponentConfigurationStore {
        get {
            return try! get_JSComponents();
        }
    }
    /**
    
            Gets or sets the maximum number of root components added from JavaScript.
            

    */
    open var MaxJSRootComponents : Swift.Int32 {
        get {
            return try! get_MaxJSRootComponents();
        }
        set(v) {
            return try! set_MaxJSRootComponents(value: v);
        }
    }
} // CircuitRootComponentOptions


// type: Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider
    /**
    
            A base class for  services that receive an
            authentication state from the host environment, and revalidate it at regular intervals.
            

    */
open class RevalidatingServerAuthenticationStateProvider
    :
    aspnetcore.Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_RevalidatingServerAuthenticationStateProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.Components.Server.RevalidatingServerAuthenticationStateProvider.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Constructs an instance of .
            

    - Parameter loggerFactory: A logger factory.
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_RevalidatingServerAuthenticationStateProvider_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // RevalidatingServerAuthenticationStateProvider


// type: Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider
    /**
    
            An  intended for use in server-side Blazor.
            

    */
open class ServerAuthenticationStateProvider
    :
    aspnetcore.Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider,
    Microsoft_AspNetCore_Components_Authorization_IHostEnvironmentAuthenticationStateProvider
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_ServerAuthenticationStateProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_ServerAuthenticationStateProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState> GetAuthenticationStateAsync()
// docid: M:Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider.GetAuthenticationStateAsync
    /**
    */
    open override func GetAuthenticationStateAsync() throws -> dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Components.Authorization.AuthenticationState> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ServerAuthenticationStateProvider_System_Threading_Tasks_Task_Microsoft_AspNetCore_Components_Authorization_AuthenticationState___GetAuthenticationStateAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // void SetAuthenticationState(System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState>)
// docid: M:Microsoft.AspNetCore.Components.Server.ServerAuthenticationStateProvider.SetAuthenticationState(System.Threading.Tasks.Task{Microsoft.AspNetCore.Components.Authorization.AuthenticationState})
    /**
    */
    open /* method final */ func SetAuthenticationState(authenticationStateTask : dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Components.Authorization.AuthenticationState>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Components_Server_ServerAuthenticationStateProvider_void__SetAuthenticationState_0__1__System_Threading_Tasks_Task_Microsoft_AspNetCore_Components_Authorization_AuthenticationState_(&__thrown, self.get_handle(), authenticationStateTask.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ServerAuthenticationStateProvider


}
// Microsoft.AspNetCore.Components.Server.Circuits
extension Microsoft.AspNetCore.Components.Server.Circuits {
// type: Microsoft.AspNetCore.Components.Server.Circuits.Circuit
    /**
    
            Represents a link between a ASP.NET Core Component on the server and a client.
            

    */
public final class Circuit
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_Circuits_Circuit_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.String get_Id()
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.Circuit.get_Id
    public func get_Id() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_Circuit_String__get_Id_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    
            Gets the identifier for the .
            

    */
    public var Id : dotnet.System.String {
        get {
            return try! get_Id();
        }
    }
} // Circuit


// type: Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler
    /**
    
            A  allows running code during specific lifetime events of a .
            
            
             is invoked after an initial circuit to the client
            has been established.
            
            
             is invoked immediately after the completion of
            . In addition, the method is invoked each time a connection is re-established
            with a client after it's been dropped.  is invoked each time a connection
            is dropped.
            
            
             is invoked prior to the server evicting the circuit to the client.
            Application users may use this event to save state for a client that can be later rehydrated.
            
            
            

    */
open class CircuitHandler
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.Task OnCircuitOpenedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnCircuitOpenedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit,System.Threading.CancellationToken)
    /**
    
            Invoked when a new circuit was established.
            

    - Parameter circuit: The .
    - Parameter cancellationToken: A  that notifies when the client connection is aborted.
    - Returns:  that represents the asynchronous execution operation.

    */
    open func OnCircuitOpenedAsync(circuit : aspnetcore.Microsoft.AspNetCore.Components.Server.Circuits.Circuit, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_Task__OnCircuitOpenedAsync_0__2__Circuit_CancellationToken(&__thrown, self.get_handle(), circuit.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task OnConnectionUpAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnConnectionUpAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit,System.Threading.CancellationToken)
    /**
    
            Invoked when a connection to the client was established.
            
            This method is executed once initially after 
            and once each for each reconnect during the lifetime of a circuit.
            
            

    - Parameter circuit: The .
    - Parameter cancellationToken: A  that notifies when the client connection is aborted.
    - Returns:  that represents the asynchronous execution operation.

    */
    open func OnConnectionUpAsync(circuit : aspnetcore.Microsoft.AspNetCore.Components.Server.Circuits.Circuit, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_Task__OnConnectionUpAsync_0__2__Circuit_CancellationToken(&__thrown, self.get_handle(), circuit.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task OnConnectionDownAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnConnectionDownAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit,System.Threading.CancellationToken)
    /**
    
            Invoked when a connection to the client was dropped.
            

    - Parameter circuit: The .
    - Parameter cancellationToken: The .
    - Returns:  that represents the asynchronous execution operation.

    */
    open func OnConnectionDownAsync(circuit : aspnetcore.Microsoft.AspNetCore.Components.Server.Circuits.Circuit, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_Task__OnConnectionDownAsync_0__2__Circuit_CancellationToken(&__thrown, self.get_handle(), circuit.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task OnCircuitClosedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.OnCircuitClosedAsync(Microsoft.AspNetCore.Components.Server.Circuits.Circuit,System.Threading.CancellationToken)
    /**
    
            Invoked when a new circuit is being discarded.
            

    - Parameter circuit: The .
    - Parameter cancellationToken: The .
    - Returns:  that represents the asynchronous execution operation.

    */
    open func OnCircuitClosedAsync(circuit : aspnetcore.Microsoft.AspNetCore.Components.Server.Circuits.Circuit, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_Task__OnCircuitClosedAsync_0__2__Circuit_CancellationToken(&__thrown, self.get_handle(), circuit.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Order()
// docid: M:Microsoft.AspNetCore.Components.Server.Circuits.CircuitHandler.get_Order
    open func get_Order() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_Circuits_CircuitHandler_i32__get_Order_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    
            Gets the execution order for the current instance of .
            
            When multiple  instances are registered, the 
            property is used to determine the order in which instances are executed. When two handlers
            have the same value for , their execution order is non-deterministic.
            
            

    */
    open var Order : Swift.Int32 {
        get {
            return try! get_Order();
        }
    }
} // CircuitHandler


}

// Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
extension Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage {
// type: Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage
    /**
    
            Provides mechanisms for storing and retrieving data in the browser storage.
            

    */
open class ProtectedBrowserStorage
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorage_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.ValueTask SetAsync(System.String, System.Object)
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.SetAsync(System.String,System.Object)
    /**
    
            
            Asynchronously stores the specified data.
            
            
            Since no data protection purpose is specified with this overload, the purpose is derived from
             and the store name. This is a good default purpose to use if the keys come from a
            fixed set known at compile-time.
            
            

    - Parameter key: A  value specifying the name of the storage slot to use.
    - Parameter value: A JSON-serializable value to be stored.
    - Returns: A  representing the completion of the operation.

    */
    open func SetAsync(key : dotnet.System.String, value : dotnet.System.Object) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorage_ValueTask__SetAsync_0__2__String_Object(&__thrown, self.get_handle(), key.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask SetAsync(System.String, System.String, System.Object)
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.SetAsync(System.String,System.String,System.Object)
    /**
    
            Asynchronously stores the supplied data.
            

    - Parameter purpose: 
            A string that defines a scope for the data protection. The protected data can only
            be unprotected by code that specifies the same purpose.
            
    - Parameter key: A  value specifying the name of the storage slot to use.
    - Parameter value: A JSON-serializable value to be stored.
    - Returns: A  representing the completion of the operation.

    */
    open func SetAsync(purpose : dotnet.System.String, key : dotnet.System.String, value : dotnet.System.Object) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorage_ValueTask__SetAsync_0__3__String_String_Object(&__thrown, self.get_handle(), purpose.get_handle(), key.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult<TValue>> GetAsync<TValue>(System.String)
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult<TValue>> GetAsync<TValue>(System.String, System.String)
    // System.Threading.Tasks.ValueTask DeleteAsync(System.String)
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage.DeleteAsync(System.String)
    /**
    
            Asynchronously deletes any data stored for the specified key.
            

    - Parameter key: 
            A  value specifying the name of the storage slot whose value should be deleted.
            
    - Returns: A  representing the completion of the operation.

    */
    open func DeleteAsync(key : dotnet.System.String) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorage_ValueTask__DeleteAsync_0__1__String(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
} // ProtectedBrowserStorage


// type: Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult`1
// boxed value type
    /**
    
            Contains the result of a protected browser storage operation.
            

    */
public final class ProtectedBrowserStorageResult_1<TValue : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorageResult_1_get_type_handle(TValue.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    
            Gets whether the operation succeeded.
            

    */
    public var Success : Bool {
        get {
            return try! get_Success();
        }
    }
    /**
    
            Gets the result value of the operation.
            

    */
    public var Value : TValue {
        get {
            return try! get_Value();
        }
    }
    public override init() {
        let h = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorageResult_1_implicit_ctor(TValue.get_type_handle());
            super.init(hndl: h);
    }
    // [IsSpecialName] bool get_Success()
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult`1.get_Success
    public func get_Success() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorageResult_1_bool__get_Success_0__0(TValue.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] TValue get_Value()
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorageResult`1.get_Value
    public func get_Value() throws -> TValue {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedBrowserStorageResult_1_TValue__get_Value_0__0(TValue.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TValue(gval: __return);
        }
    }
} // ProtectedBrowserStorageResult_1


// type: Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage
    /**
    
             Provides mechanisms for storing and retrieving data in the browser's
             'localStorage' collection.
            
             This data will be scoped to the current user's browser, shared across
             all tabs. The data will persist across browser restarts.
            
             See: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage
             

    */
public final class ProtectedLocalStorage
    :
    aspnetcore.Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedLocalStorage_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.JSInterop.IJSRuntime, Microsoft.AspNetCore.DataProtection.IDataProtectionProvider)
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage.#ctor(Microsoft.JSInterop.IJSRuntime,Microsoft.AspNetCore.DataProtection.IDataProtectionProvider)
    /**
    
            Constructs an instance of .
            

    - Parameter jsRuntime: The .
    - Parameter dataProtectionProvider: The .
    */
    public init(jsRuntime : aspnetcore.Microsoft.JSInterop.IJSRuntime, dataProtectionProvider : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedLocalStorage_ctor_0__2__IJSRuntime_IDataProtectionProvider(&__thrown, jsRuntime.get_handle(), dataProtectionProvider.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ProtectedLocalStorage


// type: Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedSessionStorage
    /**
    
             Provides mechanisms for storing and retrieving data in the browser's
             'sessionStorage' collection.
            
             This data will be scoped to the current browser tab. The data will be
             discarded if the user closes the browser tab or closes the browser itself.
            
             See: https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
             

    */
public final class ProtectedSessionStorage
    :
    aspnetcore.Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedBrowserStorage
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedSessionStorage_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.JSInterop.IJSRuntime, Microsoft.AspNetCore.DataProtection.IDataProtectionProvider)
// docid: M:Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedSessionStorage.#ctor(Microsoft.JSInterop.IJSRuntime,Microsoft.AspNetCore.DataProtection.IDataProtectionProvider)
    /**
    
            Constructs an instance of .
            

    - Parameter jsRuntime: The .
    - Parameter dataProtectionProvider: The .
    */
    public init(jsRuntime : aspnetcore.Microsoft.JSInterop.IJSRuntime, dataProtectionProvider : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Components_Server_ProtectedBrowserStorage_ProtectedSessionStorage_ctor_0__2__IJSRuntime_IDataProtectionProvider(&__thrown, jsRuntime.get_handle(), dataProtectionProvider.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ProtectedSessionStorage


}




// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions
public struct ComponentServiceCollectionExtensions {
    // Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddServerSideBlazor(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions.AddServerSideBlazor(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.AspNetCore.Components.Server.CircuitOptions})
    /**
    
            Adds Server-Side Blazor services to the service collection.
            

    - Parameter services: The .
    - Parameter configure: A callback to configure .
    - Returns: An  that can be used to further customize the configuration.

    */
    public static func AddServerSideBlazor(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>> = nil) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ComponentServiceCollectionExtensions_IServerSideBlazorBuilder__AddServerSideBlazor_0__2__IServiceCollection_System_Action_Microsoft_AspNetCore_Components_Server_CircuitOptions_(&__thrown, services.get_handle(), (configure?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddServerSideBlazor(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>(configure);
        return try AddServerSideBlazor(services: services, configure: del_configure);
    }
} // ComponentServiceCollectionExtensions


// type: Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder
    /**
    
            A builder that can be used to configure Server-Side Blazor.
            

    */
open class IServerSideBlazorBuilder
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.IServiceCollection get_Services()
// docid: M:Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder.get_Services
    open func get_Services() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder_IServiceCollection__get_Services_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
} // IServerSideBlazorBuilder


// type: Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions
public struct ServerSideBlazorBuilderExtensions {
    // Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddCircuitOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddCircuitOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder,System.Action{Microsoft.AspNetCore.Components.Server.CircuitOptions})
    /**
    
            Adds options to configure circuits.
            

    - Parameter builder: The .
    - Parameter configure: A callback to configure .
    - Returns: The .

    */
    public static func AddCircuitOptions(builder : aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServerSideBlazorBuilderExtensions_IServerSideBlazorBuilder__AddCircuitOptions_0__2__IServerSideBlazorBuilder_System_Action_Microsoft_AspNetCore_Components_Server_CircuitOptions_(&__thrown, builder.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddCircuitOptions(builder : aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>(configure);
        return try AddCircuitOptions(builder: builder, configure: del_configure);
    }
    // Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddHubOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, System.Action<Microsoft.AspNetCore.SignalR.HubOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddHubOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder,System.Action{Microsoft.AspNetCore.SignalR.HubOptions})
    /**
    
            Adds hub options for the configuration of the SignalR Hub used by Server-Side Blazor.
            

    - Parameter builder: The .
    - Parameter configure: A callback to configure the hub options.
    - Returns: The .

    */
    public static func AddHubOptions(builder : aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ServerSideBlazorBuilderExtensions_IServerSideBlazorBuilder__AddHubOptions_0__2__IServerSideBlazorBuilder_System_Action_Microsoft_AspNetCore_SignalR_HubOptions_(&__thrown, builder.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddHubOptions(builder : aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>(configure);
        return try AddHubOptions(builder: builder, configure: del_configure);
    }
} // ServerSideBlazorBuilderExtensions


}



public protocol Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapBlazorHub() throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapBlazorHub(path : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), path: path);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapBlazorHub(configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions);
    }
    // delegate closure overload
    public func MapBlazorHub(configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder MapBlazorHub(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapBlazorHub(path : dotnet.System.String, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), path: path, configureOptions: configureOptions);
    }
    // delegate closure overload
    public func MapBlazorHub(path : dotnet.System.String, configureOptions : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointConventionBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Builder.ComponentEndpointRouteBuilderExtensions.MapBlazorHub(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), path: path, configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddServerSideBlazor(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddServerSideBlazor(configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>> = nil) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions.AddServerSideBlazor(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func AddServerSideBlazor(configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>(configure);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ComponentServiceCollectionExtensions.AddServerSideBlazor(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddCircuitOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, System.Action<Microsoft.AspNetCore.Components.Server.CircuitOptions>)
extension Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder {
    public func AddCircuitOptions(configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddCircuitOptions(builder: aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func AddCircuitOptions(configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Components.Server.CircuitOptions>(configure);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddCircuitOptions(builder: aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder AddHubOptions(Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder, System.Action<Microsoft.AspNetCore.SignalR.HubOptions>)
extension Microsoft_Extensions_DependencyInjection_IServerSideBlazorBuilder {
    public func AddHubOptions(configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddHubOptions(builder: aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func AddHubOptions(configure : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.SignalR.HubOptions>(configure);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ServerSideBlazorBuilderExtensions.AddHubOptions(builder: aspnetcore.Microsoft.Extensions.DependencyInjection.IServerSideBlazorBuilder(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

