// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Identity
extension Microsoft.AspNetCore.Identity {
// type: Microsoft.AspNetCore.Identity.IdentityRole
    /**
    
            The default implementation of  which uses a string as the primary key.
            

    */
open class IdentityRole
    :
    aspnetcore.Microsoft.AspNetCore.Identity.IdentityRole_1<dotnet.System.String>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityRole_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityRole_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter roleName: The role name.
    */
    public override init(roleName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityRole_ctor_0__1__String(&__thrown, roleName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // IdentityRole


// type: Microsoft.AspNetCore.Identity.IdentityRoleClaim`1
    /**
    
            Represents a claim that is granted to all users within a role.
            

    */
open class IdentityRoleClaim_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Claims.Claim ToClaim()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.ToClaim
    /**
    
            Constructs a new claim with the type and value.
            

    - Returns: The  that was produced.

    */
    open func ToClaim() throws -> Optional<dotnet.System.Security.Claims.Claim> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_Claim__ToClaim_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.Claim(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void InitializeFromClaim(System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.InitializeFromClaim(System.Security.Claims.Claim)
    /**
    
            Initializes by copying ClaimType and ClaimValue from the other claim.
            

    - Parameter other: The claim to initialize from.
    */
    open func InitializeFromClaim(other : Optional<dotnet.System.Security.Claims.Claim>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_void__InitializeFromClaim_0__1__Claim(TKey.get_type_handle(), &__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Id()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.get_Id
    open func get_Id() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_i32__get_Id_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Id(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.set_Id(System.Int32)
    open func set_Id(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_void__set_Id_0__1__i32(TKey.get_type_handle(), &__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] TKey get_RoleId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.get_RoleId
    open func get_RoleId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_TKey__get_RoleId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_RoleId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.set_RoleId(`0)
    open func set_RoleId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_void__set_RoleId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ClaimType()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.get_ClaimType
    open func get_ClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_String__get_ClaimType_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.set_ClaimType(System.String)
    open func set_ClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_void__set_ClaimType_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ClaimValue()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.get_ClaimValue
    open func get_ClaimValue() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_String__get_ClaimValue_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimValue(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRoleClaim`1.set_ClaimValue(System.String)
    open func set_ClaimValue(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRoleClaim_1_void__set_ClaimValue_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the claim type for this claim.
            

    */
    open var ClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_ClaimType();
        }
        set(v) {
            return try! set_ClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the claim value for this claim.
            

    */
    open var ClaimValue : Optional<dotnet.System.String> {
        get {
            return try! get_ClaimValue();
        }
        set(v) {
            return try! set_ClaimValue(value: v!);
        }
    }
    /**
    
            Gets or sets the identifier for this role claim.
            

    */
    open var Id : Swift.Int32 {
        get {
            return try! get_Id();
        }
        set(v) {
            return try! set_Id(value: v);
        }
    }
    /**
    
            Gets or sets the of the primary key of the role associated with this claim.
            

    */
    open var RoleId : TKey {
        get {
            return try! get_RoleId();
        }
        set(v) {
            return try! set_RoleId(value: v);
        }
    }
} // IdentityRoleClaim_1


// type: Microsoft.AspNetCore.Identity.IdentityRole`1
    /**
    
            Represents a role in the identity system
            

    */
open class IdentityRole_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityRole_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityRole_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter roleName: The role name.
    */
    public init(roleName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityRole_1_ctor_0__1__String(TKey.get_type_handle(), &__thrown, roleName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.ToString
    /**
    
            Returns the name of the role.
            

    - Returns: The name of the role.

    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRole_1_String__ToString_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] TKey get_Id()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.get_Id
    open func get_Id() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRole_1_TKey__get_Id_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_Id(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.set_Id(`0)
    open func set_Id(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRole_1_void__set_Id_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRole_1_String__get_Name_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Name(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.set_Name(System.String)
    open func set_Name(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRole_1_void__set_Name_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_NormalizedName()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.get_NormalizedName
    open func get_NormalizedName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRole_1_String__get_NormalizedName_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_NormalizedName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.set_NormalizedName(System.String)
    open func set_NormalizedName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRole_1_void__set_NormalizedName_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ConcurrencyStamp()
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.get_ConcurrencyStamp
    open func get_ConcurrencyStamp() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityRole_1_String__get_ConcurrencyStamp_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ConcurrencyStamp(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityRole`1.set_ConcurrencyStamp(System.String)
    open func set_ConcurrencyStamp(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityRole_1_void__set_ConcurrencyStamp_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            A random value that should change whenever a role is persisted to the store
            

    */
    open var ConcurrencyStamp : Optional<dotnet.System.String> {
        get {
            return try! get_ConcurrencyStamp();
        }
        set(v) {
            return try! set_ConcurrencyStamp(value: v!);
        }
    }
    /**
    
            Gets or sets the primary key for this role.
            

    */
    open var Id : TKey {
        get {
            return try! get_Id();
        }
        set(v) {
            return try! set_Id(value: v);
        }
    }
    /**
    
            Gets or sets the name for this role.
            

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
        set(v) {
            return try! set_Name(value: v!);
        }
    }
    /**
    
            Gets or sets the normalized name for this role.
            

    */
    open var NormalizedName : Optional<dotnet.System.String> {
        get {
            return try! get_NormalizedName();
        }
        set(v) {
            return try! set_NormalizedName(value: v!);
        }
    }
} // IdentityRole_1


// type: Microsoft.AspNetCore.Identity.IdentityUser
    /**
    
            The default implementation of  which uses a string as a primary key.
            

    */
open class IdentityUser
    :
    aspnetcore.Microsoft.AspNetCore.Identity.IdentityUser_1<dotnet.System.String>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUser_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUser_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter userName: The user name.
    */
    public override init(userName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUser_ctor_0__1__String(&__thrown, userName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // IdentityUser


// type: Microsoft.AspNetCore.Identity.IdentityUserClaim`1
    /**
    
            Represents a claim that a user possesses.
            

    */
open class IdentityUserClaim_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUserClaim_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Claims.Claim ToClaim()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.ToClaim
    /**
    
            Converts the entity into a Claim instance.
            

    - Returns: 

    */
    open func ToClaim() throws -> Optional<dotnet.System.Security.Claims.Claim> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_Claim__ToClaim_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.Claim(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void InitializeFromClaim(System.Security.Claims.Claim)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.InitializeFromClaim(System.Security.Claims.Claim)
    /**
    
            Reads the type and value from the Claim.
            

    - Parameter claim: 
    */
    open func InitializeFromClaim(claim : Optional<dotnet.System.Security.Claims.Claim>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserClaim_1_void__InitializeFromClaim_0__1__Claim(TKey.get_type_handle(), &__thrown, self.get_handle(), claim?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Id()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.get_Id
    open func get_Id() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_i32__get_Id_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Id(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.set_Id(System.Int32)
    open func set_Id(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserClaim_1_void__set_Id_0__1__i32(TKey.get_type_handle(), &__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] TKey get_UserId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.get_UserId
    open func get_UserId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_TKey__get_UserId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_UserId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.set_UserId(`0)
    open func set_UserId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserClaim_1_void__set_UserId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ClaimType()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.get_ClaimType
    open func get_ClaimType() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_String__get_ClaimType_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimType(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.set_ClaimType(System.String)
    open func set_ClaimType(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserClaim_1_void__set_ClaimType_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ClaimValue()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.get_ClaimValue
    open func get_ClaimValue() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserClaim_1_String__get_ClaimValue_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimValue(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserClaim`1.set_ClaimValue(System.String)
    open func set_ClaimValue(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserClaim_1_void__set_ClaimValue_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the claim type for this claim.
            

    */
    open var ClaimType : Optional<dotnet.System.String> {
        get {
            return try! get_ClaimType();
        }
        set(v) {
            return try! set_ClaimType(value: v!);
        }
    }
    /**
    
            Gets or sets the claim value for this claim.
            

    */
    open var ClaimValue : Optional<dotnet.System.String> {
        get {
            return try! get_ClaimValue();
        }
        set(v) {
            return try! set_ClaimValue(value: v!);
        }
    }
    /**
    
            Gets or sets the identifier for this user claim.
            

    */
    open var Id : Swift.Int32 {
        get {
            return try! get_Id();
        }
        set(v) {
            return try! set_Id(value: v);
        }
    }
    /**
    
            Gets or sets the primary key of the user associated with this claim.
            

    */
    open var UserId : TKey {
        get {
            return try! get_UserId();
        }
        set(v) {
            return try! set_UserId(value: v);
        }
    }
} // IdentityUserClaim_1


// type: Microsoft.AspNetCore.Identity.IdentityUserLogin`1
    /**
    
            Represents a login and its associated provider for a user.
            

    */
open class IdentityUserLogin_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUserLogin_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUserLogin_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_LoginProvider()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.get_LoginProvider
    open func get_LoginProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserLogin_1_String__get_LoginProvider_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LoginProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.set_LoginProvider(System.String)
    open func set_LoginProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserLogin_1_void__set_LoginProvider_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ProviderKey()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.get_ProviderKey
    open func get_ProviderKey() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserLogin_1_String__get_ProviderKey_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderKey(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.set_ProviderKey(System.String)
    open func set_ProviderKey(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserLogin_1_void__set_ProviderKey_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ProviderDisplayName()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.get_ProviderDisplayName
    open func get_ProviderDisplayName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserLogin_1_String__get_ProviderDisplayName_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ProviderDisplayName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.set_ProviderDisplayName(System.String)
    open func set_ProviderDisplayName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserLogin_1_void__set_ProviderDisplayName_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] TKey get_UserId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.get_UserId
    open func get_UserId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserLogin_1_TKey__get_UserId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_UserId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserLogin`1.set_UserId(`0)
    open func set_UserId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserLogin_1_void__set_UserId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the login provider for the login (e.g. facebook, google)
            

    */
    open var LoginProvider : Optional<dotnet.System.String> {
        get {
            return try! get_LoginProvider();
        }
        set(v) {
            return try! set_LoginProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the friendly name used in a UI for this login.
            

    */
    open var ProviderDisplayName : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderDisplayName();
        }
        set(v) {
            return try! set_ProviderDisplayName(value: v!);
        }
    }
    /**
    
            Gets or sets the unique provider identifier for this login.
            

    */
    open var ProviderKey : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderKey();
        }
        set(v) {
            return try! set_ProviderKey(value: v!);
        }
    }
    /**
    
            Gets or sets the primary key of the user associated with this login.
            

    */
    open var UserId : TKey {
        get {
            return try! get_UserId();
        }
        set(v) {
            return try! set_UserId(value: v);
        }
    }
} // IdentityUserLogin_1


// type: Microsoft.AspNetCore.Identity.IdentityUserRole`1
    /**
    
            Represents the link between a user and a role.
            

    */
open class IdentityUserRole_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUserRole_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserRole`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUserRole_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] TKey get_UserId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserRole`1.get_UserId
    open func get_UserId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserRole_1_TKey__get_UserId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_UserId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserRole`1.set_UserId(`0)
    open func set_UserId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserRole_1_void__set_UserId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] TKey get_RoleId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserRole`1.get_RoleId
    open func get_RoleId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserRole_1_TKey__get_RoleId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_RoleId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserRole`1.set_RoleId(`0)
    open func set_RoleId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserRole_1_void__set_RoleId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the primary key of the role that is linked to the user.
            

    */
    open var RoleId : TKey {
        get {
            return try! get_RoleId();
        }
        set(v) {
            return try! set_RoleId(value: v);
        }
    }
    /**
    
            Gets or sets the primary key of the user that is linked to a role.
            

    */
    open var UserId : TKey {
        get {
            return try! get_UserId();
        }
        set(v) {
            return try! set_UserId(value: v);
        }
    }
} // IdentityUserRole_1


// type: Microsoft.AspNetCore.Identity.IdentityUserToken`1
    /**
    
            Represents an authentication token for a user.
            

    */
open class IdentityUserToken_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUserToken_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUserToken_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] TKey get_UserId()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.get_UserId
    open func get_UserId() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserToken_1_TKey__get_UserId_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_UserId(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.set_UserId(`0)
    open func set_UserId(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserToken_1_void__set_UserId_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_LoginProvider()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.get_LoginProvider
    open func get_LoginProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserToken_1_String__get_LoginProvider_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LoginProvider(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.set_LoginProvider(System.String)
    open func set_LoginProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserToken_1_void__set_LoginProvider_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserToken_1_String__get_Name_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Name(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.set_Name(System.String)
    open func set_Name(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserToken_1_void__set_Name_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Value()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.get_Value
    open func get_Value() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUserToken_1_String__get_Value_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Value(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUserToken`1.set_Value(System.String)
    open func set_Value(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUserToken_1_void__set_Value_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the LoginProvider this token is from.
            

    */
    open var LoginProvider : Optional<dotnet.System.String> {
        get {
            return try! get_LoginProvider();
        }
        set(v) {
            return try! set_LoginProvider(value: v!);
        }
    }
    /**
    
            Gets or sets the name of the token.
            

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
        set(v) {
            return try! set_Name(value: v!);
        }
    }
    /**
    
            Gets or sets the primary key of the user that the token belongs to.
            

    */
    open var UserId : TKey {
        get {
            return try! get_UserId();
        }
        set(v) {
            return try! set_UserId(value: v);
        }
    }
    /**
    
            Gets or sets the token value.
            

    */
    open var Value : Optional<dotnet.System.String> {
        get {
            return try! get_Value();
        }
        set(v) {
            return try! set_Value(value: v!);
        }
    }
} // IdentityUserToken_1


// type: Microsoft.AspNetCore.Identity.IdentityUser`1
    /**
    
            Represents a user in the identity system
            

    */
open class IdentityUser_1<TKey : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityUser_1_get_type_handle(TKey.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUser_1_ctor_0__0(TKey.get_type_handle(), &__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.#ctor(System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter userName: The user name.
    */
    public init(userName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityUser_1_ctor_0__1__String(TKey.get_type_handle(), &__thrown, userName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.ToString
    /**
    
            Returns the username for this user.
            

    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__ToString_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] TKey get_Id()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_Id
    open func get_Id() throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_TKey__get_Id_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // [IsSpecialName] void set_Id(TKey)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_Id(`0)
    open func set_Id(value : TKey) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_Id_0__1__TKey(TKey.get_type_handle(), &__thrown, self.get_handle(), value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_UserName()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_UserName
    open func get_UserName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_UserName_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UserName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_UserName(System.String)
    open func set_UserName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_UserName_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_NormalizedUserName()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_NormalizedUserName
    open func get_NormalizedUserName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_NormalizedUserName_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_NormalizedUserName(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_NormalizedUserName(System.String)
    open func set_NormalizedUserName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_NormalizedUserName_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Email()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_Email
    open func get_Email() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_Email_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Email(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_Email(System.String)
    open func set_Email(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_Email_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_NormalizedEmail()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_NormalizedEmail
    open func get_NormalizedEmail() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_NormalizedEmail_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_NormalizedEmail(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_NormalizedEmail(System.String)
    open func set_NormalizedEmail(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_NormalizedEmail_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_EmailConfirmed()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_EmailConfirmed
    open func get_EmailConfirmed() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_bool__get_EmailConfirmed_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_EmailConfirmed(bool)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_EmailConfirmed(System.Boolean)
    open func set_EmailConfirmed(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_EmailConfirmed_0__1__bool(TKey.get_type_handle(), &__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_PasswordHash()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_PasswordHash
    open func get_PasswordHash() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_PasswordHash_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_PasswordHash(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_PasswordHash(System.String)
    open func set_PasswordHash(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_PasswordHash_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_SecurityStamp()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_SecurityStamp
    open func get_SecurityStamp() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_SecurityStamp_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SecurityStamp(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_SecurityStamp(System.String)
    open func set_SecurityStamp(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_SecurityStamp_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ConcurrencyStamp()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_ConcurrencyStamp
    open func get_ConcurrencyStamp() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_ConcurrencyStamp_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ConcurrencyStamp(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_ConcurrencyStamp(System.String)
    open func set_ConcurrencyStamp(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_ConcurrencyStamp_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_PhoneNumber()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_PhoneNumber
    open func get_PhoneNumber() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_String__get_PhoneNumber_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_PhoneNumber(System.String)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_PhoneNumber(System.String)
    open func set_PhoneNumber(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_PhoneNumber_0__1__String(TKey.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_PhoneNumberConfirmed()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_PhoneNumberConfirmed
    open func get_PhoneNumberConfirmed() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_bool__get_PhoneNumberConfirmed_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_PhoneNumberConfirmed(bool)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_PhoneNumberConfirmed(System.Boolean)
    open func set_PhoneNumberConfirmed(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_PhoneNumberConfirmed_0__1__bool(TKey.get_type_handle(), &__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_TwoFactorEnabled()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_TwoFactorEnabled
    open func get_TwoFactorEnabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_bool__get_TwoFactorEnabled_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_TwoFactorEnabled(bool)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_TwoFactorEnabled(System.Boolean)
    open func set_TwoFactorEnabled(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_TwoFactorEnabled_0__1__bool(TKey.get_type_handle(), &__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.DateTimeOffset> get_LockoutEnd()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_LockoutEnd
    open func get_LockoutEnd() throws -> Optional<dotnet.System.DateTimeOffset> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_System_Nullable_System_DateTimeOffset___get_LockoutEnd_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.DateTimeOffset(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_LockoutEnd(System.Nullable<System.DateTimeOffset>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_LockoutEnd(System.Nullable{System.DateTimeOffset})
    open func set_LockoutEnd(value : Optional<dotnet.System.DateTimeOffset>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_LockoutEnd_0__1__System_Nullable_System_DateTimeOffset_(TKey.get_type_handle(), &__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_LockoutEnabled()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_LockoutEnabled
    open func get_LockoutEnabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_bool__get_LockoutEnabled_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_LockoutEnabled(bool)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_LockoutEnabled(System.Boolean)
    open func set_LockoutEnabled(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_LockoutEnabled_0__1__bool(TKey.get_type_handle(), &__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_AccessFailedCount()
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.get_AccessFailedCount
    open func get_AccessFailedCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityUser_1_i32__get_AccessFailedCount_0__0(TKey.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_AccessFailedCount(System.Int32)
// docid: M:Microsoft.AspNetCore.Identity.IdentityUser`1.set_AccessFailedCount(System.Int32)
    open func set_AccessFailedCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityUser_1_void__set_AccessFailedCount_0__1__i32(TKey.get_type_handle(), &__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the number of failed login attempts for the current user.
            

    */
    open var AccessFailedCount : Swift.Int32 {
        get {
            return try! get_AccessFailedCount();
        }
        set(v) {
            return try! set_AccessFailedCount(value: v);
        }
    }
    /**
    
            A random value that must change whenever a user is persisted to the store
            

    */
    open var ConcurrencyStamp : Optional<dotnet.System.String> {
        get {
            return try! get_ConcurrencyStamp();
        }
        set(v) {
            return try! set_ConcurrencyStamp(value: v!);
        }
    }
    /**
    
            Gets or sets the email address for this user.
            

    */
    open var Email : Optional<dotnet.System.String> {
        get {
            return try! get_Email();
        }
        set(v) {
            return try! set_Email(value: v!);
        }
    }
    /**
    
            Gets or sets a flag indicating if a user has confirmed their email address.
            

    */
    open var EmailConfirmed : Bool {
        get {
            return try! get_EmailConfirmed();
        }
        set(v) {
            return try! set_EmailConfirmed(value: v);
        }
    }
    /**
    
            Gets or sets the primary key for this user.
            

    */
    open var Id : TKey {
        get {
            return try! get_Id();
        }
        set(v) {
            return try! set_Id(value: v);
        }
    }
    /**
    
            Gets or sets a flag indicating if the user could be locked out.
            

    */
    open var LockoutEnabled : Bool {
        get {
            return try! get_LockoutEnabled();
        }
        set(v) {
            return try! set_LockoutEnabled(value: v);
        }
    }
    /**
    
            Gets or sets the date and time, in UTC, when any user lockout ends.
            

    */
    open var LockoutEnd : Optional<dotnet.System.DateTimeOffset> {
        get {
            return try! get_LockoutEnd();
        }
        set(v) {
            return try! set_LockoutEnd(value: v!);
        }
    }
    /**
    
            Gets or sets the normalized email address for this user.
            

    */
    open var NormalizedEmail : Optional<dotnet.System.String> {
        get {
            return try! get_NormalizedEmail();
        }
        set(v) {
            return try! set_NormalizedEmail(value: v!);
        }
    }
    /**
    
            Gets or sets the normalized user name for this user.
            

    */
    open var NormalizedUserName : Optional<dotnet.System.String> {
        get {
            return try! get_NormalizedUserName();
        }
        set(v) {
            return try! set_NormalizedUserName(value: v!);
        }
    }
    /**
    
            Gets or sets a salted and hashed representation of the password for this user.
            

    */
    open var PasswordHash : Optional<dotnet.System.String> {
        get {
            return try! get_PasswordHash();
        }
        set(v) {
            return try! set_PasswordHash(value: v!);
        }
    }
    /**
    
            Gets or sets a telephone number for the user.
            

    */
    open var PhoneNumber : Optional<dotnet.System.String> {
        get {
            return try! get_PhoneNumber();
        }
        set(v) {
            return try! set_PhoneNumber(value: v!);
        }
    }
    /**
    
            Gets or sets a flag indicating if a user has confirmed their telephone address.
            

    */
    open var PhoneNumberConfirmed : Bool {
        get {
            return try! get_PhoneNumberConfirmed();
        }
        set(v) {
            return try! set_PhoneNumberConfirmed(value: v);
        }
    }
    /**
    
            A random value that must change whenever a users credentials change (password changed, login removed)
            

    */
    open var SecurityStamp : Optional<dotnet.System.String> {
        get {
            return try! get_SecurityStamp();
        }
        set(v) {
            return try! set_SecurityStamp(value: v!);
        }
    }
    /**
    
            Gets or sets a flag indicating if two factor authentication is enabled for this user.
            

    */
    open var TwoFactorEnabled : Bool {
        get {
            return try! get_TwoFactorEnabled();
        }
        set(v) {
            return try! set_TwoFactorEnabled(value: v);
        }
    }
    /**
    
            Gets or sets the user name for this user.
            

    */
    open var UserName : Optional<dotnet.System.String> {
        get {
            return try! get_UserName();
        }
        set(v) {
            return try! set_UserName(value: v!);
        }
    }
} // IdentityUser_1


// type: Microsoft.AspNetCore.Identity.RoleStoreBase`4
    /**
    
            Creates a new instance of a persistence store for roles.
            

    */
open class RoleStoreBase_4<TRole : SGBridgeGenericValue,TKey : SGBridgeGenericValue,TUserRole : SGBridgeGenericValue,TRoleClaim : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_RoleStoreBase_4_get_type_handle(TRole.get_type_handle(),TKey.get_type_handle(),TUserRole.get_type_handle(),TRoleClaim.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Constructs a new instance of .
            

    - Parameter describer: The .
    */
    public init(describer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_RoleStoreBase_4_ctor_0__1__IdentityErrorDescriber(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, describer?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.CreateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Creates a new role in a store as an asynchronous operation.
            

    - Parameter role: The role to create in the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func CreateAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.UpdateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Updates a role in a store as an asynchronous operation.
            

    - Parameter role: The role to update in the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func UpdateAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.DeleteAsync(`0,System.Threading.CancellationToken)
    /**
    
            Deletes a role from the store as an asynchronous operation.
            

    - Parameter role: The role to delete from the store.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that represents the  of the asynchronous query.

    */
    open func DeleteAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleIdAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.GetRoleIdAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the ID for a role from the store as an asynchronous operation.
            

    - Parameter role: The role whose ID should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the ID of the role.

    */
    open func GetRoleIdAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_string___GetRoleIdAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetRoleNameAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.GetRoleNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the name of a role from the store as an asynchronous operation.
            

    - Parameter role: The role whose name should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the name of the role.

    */
    open func GetRoleNameAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_string___GetRoleNameAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetRoleNameAsync(TRole, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.SetRoleNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the name of a role in the store as an asynchronous operation.
            

    - Parameter role: The role whose name should be set.
    - Parameter roleName: The name of the role.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetRoleNameAsync(role : TRole, roleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_Task__SetRoleNameAsync_0__3__TRole_String_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), roleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // TKey ConvertIdFromString(System.String)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.ConvertIdFromString(System.String)
    /**
    
            Converts the provided  to a strongly typed key object.
            

    - Parameter id: The id to convert.
    - Returns: An instance of  representing the provided .

    */
    open func ConvertIdFromString(id : Optional<dotnet.System.String>) throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_TKey__ConvertIdFromString_0__1__String(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), id?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // System.String ConvertIdToString(TKey)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.ConvertIdToString(`1)
    /**
    
            Converts the provided  to its string representation.
            

    - Parameter id: The id to convert.
    - Returns: An  representation of the provided .

    */
    open func ConvertIdToString(id : TKey) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_String__ConvertIdToString_0__1__TKey(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), id.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByIdAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.FindByIdAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds the role who has the specified ID as an asynchronous operation.
            

    - Parameter id: The role ID to look for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that result of the look up.

    */
    open func FindByIdAsync(id : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_TRole___FindByIdAsync_0__2__String_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), id?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TRole> FindByNameAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.FindByNameAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds the role who has the specified normalized name as an asynchronous operation.
            

    - Parameter normalizedName: The normalized role name to look for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that result of the look up.

    */
    open func FindByNameAsync(normalizedName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_TRole___FindByNameAsync_0__2__String_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), normalizedName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedRoleNameAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.GetNormalizedRoleNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get a role's normalized name as an asynchronous operation.
            

    - Parameter role: The role whose normalized name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the name of the role.

    */
    open func GetNormalizedRoleNameAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_string___GetNormalizedRoleNameAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedRoleNameAsync(TRole, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.SetNormalizedRoleNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Set a role's normalized name as an asynchronous operation.
            

    - Parameter role: The role whose normalized name should be set.
    - Parameter normalizedName: The normalized name to set
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetNormalizedRoleNameAsync(role : TRole, normalizedName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_Task__SetNormalizedRoleNameAsync_0__3__TRole_String_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), normalizedName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.Dispose
    /**
    
            Dispose the stores
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleStoreBase_4_void__Dispose_0__0(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TRole, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.GetClaimsAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the claims associated with the specified  as an asynchronous operation.
            

    - Parameter role: The role whose claims should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the claims granted to a role.

    */
    open func GetClaimsAsync(role : TRole, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__2__TRole_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddClaimAsync(TRole, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.AddClaimAsync(`0,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Adds the  given to the specified .
            

    - Parameter role: The role to add the claim to.
    - Parameter claim: The claim to add to the role.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_Task__AddClaimAsync_0__3__TRole_Claim_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveClaimAsync(TRole, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.RemoveClaimAsync(`0,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Removes the  given from the specified .
            

    - Parameter role: The role to remove the claim from.
    - Parameter claim: The claim to remove from the role.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveClaimAsync(role : TRole, claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_Task__RemoveClaimAsync_0__3__TRole_Claim_CancellationToken(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), role.to_gval(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_ErrorDescriber()
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.get_ErrorDescriber
    open func get_ErrorDescriber() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_IdentityErrorDescriber__get_ErrorDescriber_0__0(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    open func set_ErrorDescriber(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_RoleStoreBase_4_void__set_ErrorDescriber_0__1__IdentityErrorDescriber(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Linq.IQueryable<TRole> get_Roles()
// docid: M:Microsoft.AspNetCore.Identity.RoleStoreBase`4.get_Roles
    open func get_Roles() throws -> Optional<dotnet.System.Linq.IQueryable_1<TRole>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_RoleStoreBase_4_System_Linq_IQueryable_TRole___get_Roles_0__0(TRole.get_type_handle(), TKey.get_type_handle(), TUserRole.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets or sets the  for any error that occurred with the current operation.
            

    */
    open var ErrorDescriber : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_ErrorDescriber();
        }
        set(v) {
            return try! set_ErrorDescriber(value: v!);
        }
    }
    /**
    
            A navigation property for the roles the store contains.
            

    */
    open var Roles : Optional<dotnet.System.Linq.IQueryable_1<TRole>> {
        get {
            return try! get_Roles();
        }
    }
} // RoleStoreBase_4


// type: Microsoft.AspNetCore.Identity.UserStoreBase`5
    /**
    
            Represents a new instance of a persistence store for the specified user type.
            

    */
open class UserStoreBase_5<TUser : SGBridgeGenericValue,TKey : SGBridgeGenericValue,TUserClaim : SGBridgeGenericValue,TUserLogin : SGBridgeGenericValue,TUserToken : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserStoreBase_5_get_type_handle(TUser.get_type_handle(),TKey.get_type_handle(),TUserClaim.get_type_handle(),TUserLogin.get_type_handle(),TUserToken.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Creates a new instance.
            

    - Parameter describer: The  used to describe store errors.
    */
    public init(describer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserStoreBase_5_ctor_0__1__IdentityErrorDescriber(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, describer?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserIdAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetUserIdAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the user identifier for the specified .
            

    - Parameter user: The user whose identifier should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the identifier for the specified .

    */
    open func GetUserIdAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetUserIdAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetUserNameAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetUserNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the user name for the specified .
            

    - Parameter user: The user whose name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the name for the specified .

    */
    open func GetUserNameAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetUserNameAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetUserNameAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetUserNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the given  for the specified .
            

    - Parameter user: The user whose name should be set.
    - Parameter userName: The user name to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetUserNameAsync(user : TUser, userName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetUserNameAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), userName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedUserNameAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetNormalizedUserNameAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the normalized user name for the specified .
            

    - Parameter user: The user whose normalized name should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the normalized user name for the specified .

    */
    open func GetNormalizedUserNameAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetNormalizedUserNameAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedUserNameAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetNormalizedUserNameAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the given normalized name for the specified .
            

    - Parameter user: The user whose name should be set.
    - Parameter normalizedName: The normalized name to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetNormalizedUserNameAsync(user : TUser, normalizedName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetNormalizedUserNameAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> CreateAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.CreateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Creates the specified  in the user store.
            

    - Parameter user: The user to create.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the creation operation.

    */
    open func CreateAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___CreateAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.UpdateAsync(`0,System.Threading.CancellationToken)
    /**
    
            Updates the specified  in the user store.
            

    - Parameter user: The user to update.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the update operation.

    */
    open func UpdateAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> DeleteAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.DeleteAsync(`0,System.Threading.CancellationToken)
    /**
    
            Deletes the specified  from the user store.
            

    - Parameter user: The user to delete.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the  of the update operation.

    */
    open func DeleteAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___DeleteAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByIdAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.FindByIdAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds and returns a user, if any, who has the specified .
            

    - Parameter userId: The user ID to search for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByIdAsync(userId : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_TUser___FindByIdAsync_0__2__String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), userId?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // TKey ConvertIdFromString(System.String)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.ConvertIdFromString(System.String)
    /**
    
            Converts the provided  to a strongly typed key object.
            

    - Parameter id: The id to convert.
    - Returns: An instance of  representing the provided .

    */
    open func ConvertIdFromString(id : Optional<dotnet.System.String>) throws -> TKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_TKey__ConvertIdFromString_0__1__String(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), id?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return TKey(gval: __return);
        }
    }
    // System.String ConvertIdToString(TKey)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.ConvertIdToString(`1)
    /**
    
            Converts the provided  to its string representation.
            

    - Parameter id: The id to convert.
    - Returns: An  representation of the provided .

    */
    open func ConvertIdToString(id : TKey) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_String__ConvertIdToString_0__1__TKey(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), id.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByNameAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.FindByNameAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Finds and returns a user, if any, who has the specified normalized user name.
            

    - Parameter normalizedUserName: The normalized user name to search for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing the user matching the specified  if it exists.
            

    */
    open func FindByNameAsync(normalizedUserName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_TUser___FindByNameAsync_0__2__String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), normalizedUserName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetPasswordHashAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetPasswordHashAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the password hash for a user.
            

    - Parameter user: The user to set the password hash for.
    - Parameter passwordHash: The password hash to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPasswordHashAsync(user : TUser, passwordHash : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetPasswordHashAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), passwordHash?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetPasswordHashAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetPasswordHashAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the password hash for a user.
            

    - Parameter user: The user to retrieve the password hash for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the password hash for the user.

    */
    open func GetPasswordHashAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetPasswordHashAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> HasPasswordAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.HasPasswordAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns a flag indicating if the specified user has a password.
            

    - Parameter user: The user to retrieve the password hash for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  containing a flag indicating if the specified user has a password. If the
            user has a password the returned value with be true, otherwise it will be false.

    */
    open func HasPasswordAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___HasPasswordAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.Dispose
    /**
    
            Dispose the store
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserStoreBase_5_void__Dispose_0__0(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.Security.Claims.Claim>> GetClaimsAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetClaimsAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the claims associated with the specified  as an asynchronous operation.
            

    - Parameter user: The user whose claims should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the claims granted to a user.

    */
    open func GetClaimsAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.Security.Claims.Claim>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_System_Security_Claims_Claim____GetClaimsAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.AddClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim},System.Threading.CancellationToken)
    /**
    
            Adds the  given to the specified .
            

    - Parameter user: The user to add the claim to.
    - Parameter claims: The claim to add to the user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__AddClaimsAsync_0__3__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim__CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ReplaceClaimAsync(TUser, System.Security.Claims.Claim, System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.ReplaceClaimAsync(`0,System.Security.Claims.Claim,System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Replaces the  on the specified , with the .
            

    - Parameter user: The user to replace the claim on.
    - Parameter claim: The claim replace.
    - Parameter newClaim: The new claim replacing the .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func ReplaceClaimAsync(user : TUser, claim : Optional<dotnet.System.Security.Claims.Claim>, newClaim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__ReplaceClaimAsync_0__4__TUser_Claim_Claim_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), claim?.get_handle() ?? nil, newClaim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveClaimsAsync(TUser, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.RemoveClaimsAsync(`0,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim},System.Threading.CancellationToken)
    /**
    
            Removes the  given from the specified .
            

    - Parameter user: The user to remove the claims from.
    - Parameter claims: The claim to remove.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveClaimsAsync(user : TUser, claims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__RemoveClaimsAsync_0__3__TUser_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim__CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (claims?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddLoginAsync(TUser, Microsoft.AspNetCore.Identity.UserLoginInfo, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.AddLoginAsync(`0,Microsoft.AspNetCore.Identity.UserLoginInfo,System.Threading.CancellationToken)
    /**
    
            Adds the  given to the specified .
            

    - Parameter user: The user to add the login to.
    - Parameter login: The login to add to the user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddLoginAsync(user : TUser, login : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__AddLoginAsync_0__3__TUser_UserLoginInfo_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), login?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveLoginAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.RemoveLoginAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Removes the  given from the specified .
            

    - Parameter user: The user to remove the login from.
    - Parameter loginProvider: The login to remove from the user.
    - Parameter providerKey: The key provided by the  to identify a user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveLoginAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__RemoveLoginAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<Microsoft.AspNetCore.Identity.UserLoginInfo>> GetLoginsAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetLoginsAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves the associated logins for the specified .
            

    - Parameter user: The user whose associated logins to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  for the asynchronous operation, containing a list of  for the specified , if any.
            

    */
    open func GetLoginsAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_Microsoft_AspNetCore_Identity_UserLoginInfo____GetLoginsAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByLoginAsync(System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.FindByLoginAsync(System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Retrieves the user associated with the specified login provider and login provider key..
            

    - Parameter loginProvider: The login provider who provided the .
    - Parameter providerKey: The key provided by the  to identify a user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
            

    */
    open func FindByLoginAsync(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_TUser___FindByLoginAsync_0__3__String_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetEmailConfirmedAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetEmailConfirmedAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a flag indicating whether the email address for the specified  has been verified, true if the email address is verified otherwise
            false.
            

    - Parameter user: The user whose email confirmation status should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous operation, a flag indicating whether the email address for the specified 
            has been confirmed or not.
            

    */
    open func GetEmailConfirmedAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___GetEmailConfirmedAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetEmailConfirmedAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetEmailConfirmedAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets the flag indicating whether the specified 's email address has been confirmed or not.
            

    - Parameter user: The user whose email confirmation status should be set.
    - Parameter confirmed: A flag indicating if the email address has been confirmed, true if the address is confirmed otherwise false.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetEmailConfirmedAsync(user : TUser, confirmed : Bool, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetEmailConfirmedAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(confirmed ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetEmailAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetEmailAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the  address for a .
            

    - Parameter user: The user whose email should be set.
    - Parameter email: The email to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetEmailAsync(user : TUser, email : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetEmailAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), email?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetEmailAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetEmailAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the email address for the specified .
            

    - Parameter user: The user whose email should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object containing the results of the asynchronous operation, the email address for the specified .

    */
    open func GetEmailAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetEmailAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetNormalizedEmailAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetNormalizedEmailAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns the normalized email for the specified .
            

    - Parameter user: The user whose email address to retrieve.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous lookup operation, the normalized email address if any associated with the specified user.
            

    */
    open func GetNormalizedEmailAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetNormalizedEmailAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetNormalizedEmailAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetNormalizedEmailAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the normalized email for the specified .
            

    - Parameter user: The user whose email address to set.
    - Parameter normalizedEmail: The normalized email to set for the specified .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SetNormalizedEmailAsync(user : TUser, normalizedEmail : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetNormalizedEmailAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedEmail?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> FindByEmailAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.FindByEmailAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Gets the user, if any, associated with the specified, normalized email address.
            

    - Parameter normalizedEmail: The normalized email address to return the user for.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
            

    */
    open func FindByEmailAsync(normalizedEmail : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_TUser___FindByEmailAsync_0__2__String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), normalizedEmail?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (returns closedgeneric of nullable): System.Threading.Tasks.Task<System.Nullable<System.DateTimeOffset>> GetLockoutEndDateAsync(TUser, System.Threading.CancellationToken)
    // System.Threading.Tasks.Task SetLockoutEndDateAsync(TUser, System.Nullable<System.DateTimeOffset>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetLockoutEndDateAsync(`0,System.Nullable{System.DateTimeOffset},System.Threading.CancellationToken)
    /**
    
            Locks out a user until the specified end date has passed. Setting a end date in the past immediately unlocks a user.
            

    - Parameter user: The user whose lockout date should be set.
    - Parameter lockoutEnd: The  after which the 's lockout should end.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetLockoutEndDateAsync(user : TUser, lockoutEnd : Optional<dotnet.System.DateTimeOffset>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetLockoutEndDateAsync_0__3__TUser_System_Nullable_System_DateTimeOffset__CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (lockoutEnd != nil) ? lockoutEnd!.get_handle() : nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> IncrementAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.IncrementAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Records that a failed access has occurred, incrementing the failed access count.
            

    - Parameter user: The user whose cancellation count should be incremented.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the incremented failed access count.

    */
    open func IncrementAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_i32___IncrementAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ResetAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.ResetAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Resets a user's failed access count.
            

    - Parameter user: The user whose failed access count should be reset.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func ResetAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__ResetAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> GetAccessFailedCountAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetAccessFailedCountAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves the current failed access count for the specified ..
            

    - Parameter user: The user whose failed access count should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the failed access count.

    */
    open func GetAccessFailedCountAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_i32___GetAccessFailedCountAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetLockoutEnabledAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetLockoutEnabledAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves a flag indicating whether user lockout can enabled for the specified user.
            

    - Parameter user: The user whose ability to be locked out should be returned.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, true if a user can be locked out, otherwise false.
            

    */
    open func GetLockoutEnabledAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___GetLockoutEnabledAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetLockoutEnabledAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetLockoutEnabledAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Set the flag indicating if the specified  can be locked out..
            

    - Parameter user: The user whose ability to be locked out should be set.
    - Parameter enabled: A flag indicating if lock out can be enabled for the specified .
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetLockoutEnabledAsync(user : TUser, enabled : Bool, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetLockoutEnabledAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetPhoneNumberAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetPhoneNumberAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the telephone number for the specified .
            

    - Parameter user: The user whose telephone number should be set.
    - Parameter phoneNumber: The telephone number to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPhoneNumberAsync(user : TUser, phoneNumber : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetPhoneNumberAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), phoneNumber?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetPhoneNumberAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetPhoneNumberAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets the telephone number, if any, for the specified .
            

    - Parameter user: The user whose telephone number should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the user's telephone number, if any.

    */
    open func GetPhoneNumberAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetPhoneNumberAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetPhoneNumberConfirmedAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetPhoneNumberConfirmedAsync(`0,System.Threading.CancellationToken)
    /**
    
            Gets a flag indicating whether the specified 's telephone number has been confirmed.
            

    - Parameter user: The user to return a flag for, indicating whether their telephone number is confirmed.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, returning true if the specified  has a confirmed
            telephone number otherwise false.
            

    */
    open func GetPhoneNumberConfirmedAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___GetPhoneNumberConfirmedAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetPhoneNumberConfirmedAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetPhoneNumberConfirmedAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets a flag indicating if the specified 's phone number has been confirmed..
            

    - Parameter user: The user whose telephone number confirmation status should be set.
    - Parameter confirmed: A flag indicating whether the user's telephone number has been confirmed.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetPhoneNumberConfirmedAsync(user : TUser, confirmed : Bool, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetPhoneNumberConfirmedAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(confirmed ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetSecurityStampAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetSecurityStampAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the provided security  for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter stamp: The security stamp to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetSecurityStampAsync(user : TUser, stamp : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetSecurityStampAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), stamp?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetSecurityStampAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetSecurityStampAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the security stamp for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the security stamp for the specified .

    */
    open func GetSecurityStampAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetSecurityStampAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetTwoFactorEnabledAsync(TUser, bool, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetTwoFactorEnabledAsync(`0,System.Boolean,System.Threading.CancellationToken)
    /**
    
            Sets a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be set.
    - Parameter enabled: A flag indicating whether the specified  has two factor authentication enabled.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetTwoFactorEnabledAsync(user : TUser, enabled : Bool, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetTwoFactorEnabledAsync_0__3__TUser_bool_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(enabled ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> GetTwoFactorEnabledAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetTwoFactorEnabledAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns a flag indicating whether the specified  has two factor authentication enabled or not,
            as an asynchronous operation.
            

    - Parameter user: The user whose two factor authentication enabled status should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  that represents the asynchronous operation, containing a flag indicating whether the specified
             has two factor authentication enabled or not.
            

    */
    open func GetTwoFactorEnabledAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___GetTwoFactorEnabledAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersForClaimAsync(System.Security.Claims.Claim, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetUsersForClaimAsync(System.Security.Claims.Claim,System.Threading.CancellationToken)
    /**
    
            Retrieves all users with the specified claim.
            

    - Parameter claim: The claim whose users should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  contains a list of users, if any, that contain the specified claim.
            

    */
    open func GetUsersForClaimAsync(claim : Optional<dotnet.System.Security.Claims.Claim>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersForClaimAsync_0__2__Claim_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), claim?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetTokenAsync(TUser, System.String, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetTokenAsync(`0,System.String,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the token value for a particular user.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter value: The value of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, value : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetTokenAsync_0__5__TUser_String_String_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, value?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveTokenAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.RemoveTokenAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Deletes a token for a user.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__RemoveTokenAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetTokenAsync(TUser, System.String, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetTokenAsync(`0,System.String,System.String,System.Threading.CancellationToken)
    /**
    
            Returns the token value.
            

    - Parameter user: The user.
    - Parameter loginProvider: The authentication provider for the token.
    - Parameter name: The name of the token.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func GetTokenAsync(user : TUser, loginProvider : Optional<dotnet.System.String>, name : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetTokenAsync_0__4__TUser_String_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), loginProvider?.get_handle() ?? nil, name?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SetAuthenticatorKeyAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.SetAuthenticatorKeyAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Sets the authenticator key for the specified .
            

    - Parameter user: The user whose authenticator key should be set.
    - Parameter key: The authenticator key to set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func SetAuthenticatorKeyAsync(user : TUser, key : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__SetAuthenticatorKeyAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), key?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.String> GetAuthenticatorKeyAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.GetAuthenticatorKeyAsync(`0,System.Threading.CancellationToken)
    /**
    
            Get the authenticator key for the specified .
            

    - Parameter user: The user whose security stamp should be set.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation, containing the security stamp for the specified .

    */
    open func GetAuthenticatorKeyAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_string___GetAuthenticatorKeyAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Int32> CountCodesAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.CountCodesAsync(`0,System.Threading.CancellationToken)
    /**
    
            Returns how many recovery code are still valid for a user.
            

    - Parameter user: The user who owns the recovery code.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The number of valid recovery codes for the user..

    */
    open func CountCodesAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Swift.Int32>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_i32___CountCodesAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ReplaceCodesAsync(TUser, System.Collections.Generic.IEnumerable<System.String>, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.ReplaceCodesAsync(`0,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)
    /**
    
            Updates the recovery codes for the user while invalidating any previous recovery codes.
            

    - Parameter user: The user to store new recovery codes for.
    - Parameter recoveryCodes: The new recovery codes for the user.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The new recovery codes for the user.

    */
    open func ReplaceCodesAsync(user : TUser, recoveryCodes : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_Task__ReplaceCodesAsync_0__3__TUser_System_Collections_Generic_IEnumerable_string__CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), (recoveryCodes?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> RedeemCodeAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.RedeemCodeAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Returns whether a recovery code is valid for a user. Note: recovery codes are only valid
            once, and will be invalid after use.
            

    - Parameter user: The user who owns the recovery code.
    - Parameter code: The recovery code to use.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: True if the recovery code was found for the user.

    */
    open func RedeemCodeAsync(user : TUser, code : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Threading_Tasks_Task_bool___RedeemCodeAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), code?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityErrorDescriber get_ErrorDescriber()
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.get_ErrorDescriber
    open func get_ErrorDescriber() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_IdentityErrorDescriber__get_ErrorDescriber_0__0(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.set_ErrorDescriber(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    open func set_ErrorDescriber(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_UserStoreBase_5_void__set_ErrorDescriber_0__1__IdentityErrorDescriber(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Linq.IQueryable<TUser> get_Users()
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`5.get_Users
    open func get_Users() throws -> Optional<dotnet.System.Linq.IQueryable_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_5_System_Linq_IQueryable_TUser___get_Users_0__0(TUser.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Linq.IQueryable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets or sets the  for any error that occurred with the current operation.
            

    */
    open var ErrorDescriber : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber> {
        get {
            return try! get_ErrorDescriber();
        }
        set(v) {
            return try! set_ErrorDescriber(value: v!);
        }
    }
    /**
    
            A navigation property for the users the store contains.
            

    */
    open var Users : Optional<dotnet.System.Linq.IQueryable_1<TUser>> {
        get {
            return try! get_Users();
        }
    }
} // UserStoreBase_5


// type: Microsoft.AspNetCore.Identity.UserStoreBase`8
    /**
    
            Represents a new instance of a persistence store for the specified user and role types.
            

    */
open class UserStoreBase_8<TUser : SGBridgeGenericValue,TRole : SGBridgeGenericValue,TKey : SGBridgeGenericValue,TUserClaim : SGBridgeGenericValue,TUserRole : SGBridgeGenericValue,TUserLogin : SGBridgeGenericValue,TUserToken : SGBridgeGenericValue,TRoleClaim : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.UserStoreBase_5<TUser,TKey,TUserClaim,TUserLogin,TUserToken>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_UserStoreBase_8_get_type_handle(TUser.get_type_handle(),TRole.get_type_handle(),TKey.get_type_handle(),TUserClaim.get_type_handle(),TUserRole.get_type_handle(),TUserLogin.get_type_handle(),TUserToken.get_type_handle(),TRoleClaim.get_type_handle());
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.#ctor(Microsoft.AspNetCore.Identity.IdentityErrorDescriber)
    /**
    
            Creates a new instance.
            

    - Parameter describer: The  used to describe store errors.
    */
    public override init(describer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_UserStoreBase_8_ctor_0__1__IdentityErrorDescriber(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, describer?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<TUser>> GetUsersInRoleAsync(System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.GetUsersInRoleAsync(System.String,System.Threading.CancellationToken)
    /**
    
            Retrieves all users in the specified role.
            

    - Parameter normalizedRoleName: The role whose users should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: 
            The  contains a list of users, if any, that are in the specified role.
            

    */
    open func GetUsersInRoleAsync(normalizedRoleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_8_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_TUser____GetUsersInRoleAsync_0__2__String_CancellationToken(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), normalizedRoleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task AddToRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.AddToRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Adds the given  to the specified .
            

    - Parameter user: The user to add the role to.
    - Parameter normalizedRoleName: The role to add.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func AddToRoleAsync(user : TUser, normalizedRoleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_8_Task__AddToRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedRoleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RemoveFromRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.RemoveFromRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Removes the given  from the specified .
            

    - Parameter user: The user to remove the role from.
    - Parameter normalizedRoleName: The role to remove.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: The  that represents the asynchronous operation.

    */
    open func RemoveFromRoleAsync(user : TUser, normalizedRoleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_8_Task__RemoveFromRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedRoleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IList<System.String>> GetRolesAsync(TUser, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.GetRolesAsync(`0,System.Threading.CancellationToken)
    /**
    
            Retrieves the roles the specified  is a member of.
            

    - Parameter user: The user whose roles should be retrieved.
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  that contains the roles the user is a member of.

    */
    open func GetRolesAsync(user : TUser, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_8_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IList_string____GetRolesAsync_0__2__TUser_CancellationToken(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsInRoleAsync(TUser, System.String, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Identity.UserStoreBase`8.IsInRoleAsync(`0,System.String,System.Threading.CancellationToken)
    /**
    
            Returns a flag indicating if the specified user is a member of the give .
            

    - Parameter user: The user whose role membership should be checked.
    - Parameter normalizedRoleName: The role to check membership of
    - Parameter cancellationToken: The  used to propagate notifications that the operation should be canceled.
    - Returns: A  containing a flag indicating if the specified user is a member of the given group. If the
            user is a member of the group the returned value with be true, otherwise it will be false.

    */
    open func IsInRoleAsync(user : TUser, normalizedRoleName : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_UserStoreBase_8_System_Threading_Tasks_Task_bool___IsInRoleAsync_0__3__TUser_String_CancellationToken(TUser.get_type_handle(), TRole.get_type_handle(), TKey.get_type_handle(), TUserClaim.get_type_handle(), TUserRole.get_type_handle(), TUserLogin.get_type_handle(), TUserToken.get_type_handle(), TRoleClaim.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), normalizedRoleName?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // UserStoreBase_8


}



