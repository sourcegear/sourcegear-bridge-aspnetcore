// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// System
// System.IO
// System.IO.Pipelines
extension System.IO.Pipelines {
// type: System.IO.Pipelines.FlushResult
// boxed value type
    /**
    Result returned by  call.

    */
public final class FlushResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_FlushResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets a value that indicates whether the current  operation was canceled by .

    */
    public var IsCanceled : Bool {
        get {
            return try! get_IsCanceled();
        }
    }
    /**
    Gets a value that indicates the reader is no longer reading data written to the .

    */
    public var IsCompleted : Bool {
        get {
            return try! get_IsCompleted();
        }
    }
    // .ctor(bool, bool)
// docid: M:System.IO.Pipelines.FlushResult.#ctor(System.Boolean,System.Boolean)
    /**
    Initializes a new instance of  struct setting the  and  flags.

    - Parameter isCanceled:  to indicate the current  operation that produced this  was canceled by ; otherwise, .
    - Parameter isCompleted:  to indicate the reader is no longer reading data written to the .
    */
    public init(isCanceled : Bool, isCompleted : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_FlushResult_ctor_0__2__bool_bool(&__thrown, Swift.Int32(isCanceled ? 1 : 0), Swift.Int32(isCompleted ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_IO_Pipelines_FlushResult_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] bool get_IsCanceled()
// docid: M:System.IO.Pipelines.FlushResult.get_IsCanceled
    public func get_IsCanceled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_FlushResult_bool__get_IsCanceled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsCompleted()
// docid: M:System.IO.Pipelines.FlushResult.get_IsCompleted
    public func get_IsCompleted() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_FlushResult_bool__get_IsCompleted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // FlushResult


// type: System.IO.Pipelines.IDuplexPipe
    /**
    Defines a class that provides a duplex pipe from which data can be read from and written to.

    */
open class IDuplexPipe
    :
    SGBridgeGenericValue,
    System_IO_Pipelines_IDuplexPipe
{
    open class func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_IDuplexPipe_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.IO.Pipelines.PipeReader get_Input()
// docid: M:System.IO.Pipelines.IDuplexPipe.get_Input
    open func get_Input() throws -> aspnetcore.System.IO.Pipelines.PipeReader {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_IDuplexPipe_PipeReader__get_Input_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeReader(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeWriter get_Output()
// docid: M:System.IO.Pipelines.IDuplexPipe.get_Output
    open func get_Output() throws -> aspnetcore.System.IO.Pipelines.PipeWriter {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_IDuplexPipe_PipeWriter__get_Output_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeWriter(hndl : __return);
        }
    }
} // IDuplexPipe


// type: System.IO.Pipelines.Pipe
    /**
    The default  and  implementation.

    */
public final class Pipe
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_Pipe_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.IO.Pipelines.Pipe.#ctor
    /**
    Initializes a new instance of the  class using  as options.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_Pipe_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipelines.PipeOptions)
// docid: M:System.IO.Pipelines.Pipe.#ctor(System.IO.Pipelines.PipeOptions)
    /**
    Initializes a new instance of the  class with the specified options.

    - Parameter options: The set of options for this pipe.
    */
    public init(options : aspnetcore.System.IO.Pipelines.PipeOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_Pipe_ctor_0__1__PipeOptions(&__thrown, options.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Reset()
// docid: M:System.IO.Pipelines.Pipe.Reset
    /**
    Resets the pipe.

    */
    public func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_Pipe_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeReader get_Reader()
// docid: M:System.IO.Pipelines.Pipe.get_Reader
    public func get_Reader() throws -> aspnetcore.System.IO.Pipelines.PipeReader {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_Pipe_PipeReader__get_Reader_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeReader(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeWriter get_Writer()
// docid: M:System.IO.Pipelines.Pipe.get_Writer
    public func get_Writer() throws -> aspnetcore.System.IO.Pipelines.PipeWriter {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_Pipe_PipeWriter__get_Writer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeWriter(hndl : __return);
        }
    }
    /**
    Gets the  for this pipe.

    */
    public var Reader : aspnetcore.System.IO.Pipelines.PipeReader {
        get {
            return try! get_Reader();
        }
    }
    /**
    Gets the  for this pipe.

    */
    public var Writer : aspnetcore.System.IO.Pipelines.PipeWriter {
        get {
            return try! get_Writer();
        }
    }
} // Pipe


// type: System.IO.Pipelines.PipeOptions
    /**
    Represents a set of  options.

    */
open class PipeOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_PipeOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Buffers.MemoryPool<System.Byte>, System.IO.Pipelines.PipeScheduler, System.IO.Pipelines.PipeScheduler, System.Int64, System.Int64, System.Int32, bool)
// docid: M:System.IO.Pipelines.PipeOptions.#ctor(System.Buffers.MemoryPool{System.Byte},System.IO.Pipelines.PipeScheduler,System.IO.Pipelines.PipeScheduler,System.Int64,System.Int64,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class with the specified parameters.

    - Parameter pool: The pool of memory blocks to be used for buffer management.
    - Parameter readerScheduler: The  to be used to execute  callbacks and async continuations.
    - Parameter writerScheduler: The  used to execute  callbacks and async continuations.
    - Parameter pauseWriterThreshold: The number of bytes in the  before  starts blocking. A value of zero prevents  from ever blocking, effectively making the number of bytes in the  unlimited.
    - Parameter resumeWriterThreshold: The number of bytes in the  when  stops blocking.
    - Parameter minimumSegmentSize: The minimum size of the segment requested from .
    - Parameter useSynchronizationContext:  if asynchronous continuations should be executed on the  they were captured on;  otherwise. This takes precedence over the schedulers specified in  and .
    */
    public init(pool : Optional<dotnet.System.Buffers.MemoryPool_1<Swift.UInt8>>, readerScheduler : Optional<aspnetcore.System.IO.Pipelines.PipeScheduler>, writerScheduler : Optional<aspnetcore.System.IO.Pipelines.PipeScheduler>, pauseWriterThreshold : Swift.Int64, resumeWriterThreshold : Swift.Int64, minimumSegmentSize : Swift.Int32, useSynchronizationContext : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_PipeOptions_ctor_0__7__System_Buffers_MemoryPool_u8__PipeScheduler_PipeScheduler_i64_i64_i32_bool(&__thrown, (pool?.get_handle()), readerScheduler?.get_handle() ?? nil, writerScheduler?.get_handle() ?? nil, pauseWriterThreshold, resumeWriterThreshold, minimumSegmentSize, Swift.Int32(useSynchronizationContext ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeOptions get_Default()
// docid: M:System.IO.Pipelines.PipeOptions.get_Default
    open class func get_Default() throws -> aspnetcore.System.IO.Pipelines.PipeOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_PipeOptions__get_Default_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeOptions(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_MinimumSegmentSize()
// docid: M:System.IO.Pipelines.PipeOptions.get_MinimumSegmentSize
    open func get_MinimumSegmentSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_i32__get_MinimumSegmentSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_PauseWriterThreshold()
// docid: M:System.IO.Pipelines.PipeOptions.get_PauseWriterThreshold
    open func get_PauseWriterThreshold() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_i64__get_PauseWriterThreshold_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Buffers.MemoryPool<System.Byte> get_Pool()
// docid: M:System.IO.Pipelines.PipeOptions.get_Pool
    open func get_Pool() throws -> dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_System_Buffers_MemoryPool_u8___get_Pool_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.MemoryPool_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeScheduler get_ReaderScheduler()
// docid: M:System.IO.Pipelines.PipeOptions.get_ReaderScheduler
    open func get_ReaderScheduler() throws -> aspnetcore.System.IO.Pipelines.PipeScheduler {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_PipeScheduler__get_ReaderScheduler_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeScheduler(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_ResumeWriterThreshold()
// docid: M:System.IO.Pipelines.PipeOptions.get_ResumeWriterThreshold
    open func get_ResumeWriterThreshold() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_i64__get_ResumeWriterThreshold_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_UseSynchronizationContext()
// docid: M:System.IO.Pipelines.PipeOptions.get_UseSynchronizationContext
    open func get_UseSynchronizationContext() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_bool__get_UseSynchronizationContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeScheduler get_WriterScheduler()
// docid: M:System.IO.Pipelines.PipeOptions.get_WriterScheduler
    open func get_WriterScheduler() throws -> aspnetcore.System.IO.Pipelines.PipeScheduler {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeOptions_PipeScheduler__get_WriterScheduler_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeScheduler(hndl : __return);
        }
    }
    /**
    Gets the default instance of .

    */
    public static var Default : aspnetcore.System.IO.Pipelines.PipeOptions {
        get {
            return try! get_Default();
        }
    }
    /**
    Gets the minimum size of the segment requested from the .

    */
    open var MinimumSegmentSize : Swift.Int32 {
        get {
            return try! get_MinimumSegmentSize();
        }
    }
    /**
    Gets the number of bytes in the  when  starts blocking.

    */
    open var PauseWriterThreshold : Swift.Int64 {
        get {
            return try! get_PauseWriterThreshold();
        }
    }
    /**
    Gets the  object used for buffer management.

    */
    open var Pool : dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        get {
            return try! get_Pool();
        }
    }
    /**
    Gets the  used to execute  callbacks and async continuations.

    */
    open var ReaderScheduler : aspnetcore.System.IO.Pipelines.PipeScheduler {
        get {
            return try! get_ReaderScheduler();
        }
    }
    /**
    Gets the number of bytes in the  when  stops blocking.

    */
    open var ResumeWriterThreshold : Swift.Int64 {
        get {
            return try! get_ResumeWriterThreshold();
        }
    }
    /**
    Gets a value that determines if asynchronous callbacks and continuations should be executed on the  they were captured on. This takes precedence over the schedulers specified in  and .

    */
    open var UseSynchronizationContext : Bool {
        get {
            return try! get_UseSynchronizationContext();
        }
    }
    /**
    Gets the  used to execute  callbacks and async continuations.

    */
    open var WriterScheduler : aspnetcore.System.IO.Pipelines.PipeScheduler {
        get {
            return try! get_WriterScheduler();
        }
    }
} // PipeOptions


// type: System.IO.Pipelines.PipeReader
    /**
    Defines a class that provides access to a read side of pipe.

    */
open class PipeReader
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_PipeReader_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void AdvanceTo(System.SequencePosition)
// docid: M:System.IO.Pipelines.PipeReader.AdvanceTo(System.SequencePosition)
    /**
    Moves forward the pipeline's read cursor to after the consumed data, marking the data as processed.

    - Parameter consumed: Marks the extent of the data that has been successfully processed.
    */
    open func AdvanceTo(consumed : dotnet.System.SequencePosition) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeReader_void__AdvanceTo_0__1__SequencePosition(&__thrown, self.get_handle(), consumed.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AdvanceTo(System.SequencePosition, System.SequencePosition)
// docid: M:System.IO.Pipelines.PipeReader.AdvanceTo(System.SequencePosition,System.SequencePosition)
    /**
    Moves forward the pipeline's read cursor to after the consumed data, marking the data as processed, read and examined.

    - Parameter consumed: Marks the extent of the data that has been successfully processed.
    - Parameter examined: Marks the extent of the data that has been read and examined.
    */
    open func AdvanceTo(consumed : dotnet.System.SequencePosition, examined : dotnet.System.SequencePosition) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeReader_void__AdvanceTo_0__2__SequencePosition_SequencePosition(&__thrown, self.get_handle(), consumed.get_handle(), examined.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.Stream AsStream(bool)
// docid: M:System.IO.Pipelines.PipeReader.AsStream(System.Boolean)
    /**
    Returns a  representation of the .

    - Parameter leaveOpen: An optional flag that indicates whether disposing the returned  leaves  open () or completes  ().
    - Returns: A stream that represents the .

    */
    open func AsStream(leaveOpen : Bool = false) throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_Stream__AsStream_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // void CancelPendingRead()
// docid: M:System.IO.Pipelines.PipeReader.CancelPendingRead
    /**
    Cancels the pending  operation without causing it to throw and without completing the . If there is no pending operation, this cancels the next operation.

    */
    open func CancelPendingRead() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeReader_void__CancelPendingRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Complete(System.Exception)
// docid: M:System.IO.Pipelines.PipeReader.Complete(System.Exception)
    /**
    Signals to the producer that the consumer is done reading.

    - Parameter exception: Optional  indicating a failure that's causing the pipeline to complete.
    */
    open func Complete(exception : Optional<dotnet.System.Exception> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeReader_void__Complete_0__1__Exception(&__thrown, self.get_handle(), exception?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask CompleteAsync(System.Exception)
// docid: M:System.IO.Pipelines.PipeReader.CompleteAsync(System.Exception)
    /**
    Marks the current pipe reader instance as being complete, meaning no more data will be read from it.

    - Parameter exception: An optional exception that indicates the failure that caused the reader to complete.
    - Returns: A value task that represents the asynchronous complete operation.

    */
    open func CompleteAsync(exception : Optional<dotnet.System.Exception> = nil) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_ValueTask__CompleteAsync_0__1__Exception(&__thrown, self.get_handle(), exception?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Pipelines.PipeWriter, System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeReader.CopyToAsync(System.IO.Pipelines.PipeWriter,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the  and writes them to the specified , using a specified buffer size and cancellation token.

    - Parameter destination: The pipe writer to which the contents of the current stream will be copied.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous copy operation.

    */
    open func CopyToAsync(destination : aspnetcore.System.IO.Pipelines.PipeWriter, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_Task__CopyToAsync_0__2__PipeWriter_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeReader.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the  and writes them to the specified stream, using a specified cancellation token.

    - Parameter destination: The stream to which the contents of the current stream will be copied.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous copy operation.

    */
    open func CopyToAsync(destination : dotnet.System.IO.Stream, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_Task__CopyToAsync_0__2__Stream_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
    // System.IO.Pipelines.PipeReader Create(System.Buffers.ReadOnlySequence<System.Byte>)
// docid: M:System.IO.Pipelines.PipeReader.Create(System.Buffers.ReadOnlySequence{System.Byte})
    /**
    
            Creates a  wrapping the specified .
            

    - Parameter sequence: The sequence.
    - Returns: A  that wraps the .

    */
    open class func Create(sequence : dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>) throws -> aspnetcore.System.IO.Pipelines.PipeReader {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_PipeReader__Create_0__1__System_Buffers_ReadOnlySequence_u8_(&__thrown, sequence.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeReader(hndl : __return);
        }
    }
    // System.IO.Pipelines.PipeReader Create(System.IO.Stream, System.IO.Pipelines.StreamPipeReaderOptions)
// docid: M:System.IO.Pipelines.PipeReader.Create(System.IO.Stream,System.IO.Pipelines.StreamPipeReaderOptions)
    /**
    Creates a  wrapping the specified .

    - Parameter stream: The stream that the pipe reader will wrap.
    - Parameter readerOptions: The options to configure the pipe reader.
    - Returns: A  that wraps the .

    */
    open class func Create(stream : dotnet.System.IO.Stream, readerOptions : Optional<aspnetcore.System.IO.Pipelines.StreamPipeReaderOptions> = nil) throws -> aspnetcore.System.IO.Pipelines.PipeReader {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_PipeReader__Create_0__2__Stream_StreamPipeReaderOptions(&__thrown, stream.get_handle(), readerOptions?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeReader(hndl : __return);
        }
    }
    // void OnWriterCompleted(System.Action<System.Exception,System.Object>, System.Object)
// docid: M:System.IO.Pipelines.PipeReader.OnWriterCompleted(System.Action{System.Exception,System.Object},System.Object)
    /**
    Registers a callback that executes when the  side of the pipe is completed.

    - Parameter callback: The callback to register.
    - Parameter state: The state object to pass to  when it's invoked.
    */
    open func OnWriterCompleted(callback : dotnet.System.Action_2<dotnet.System.Exception,dotnet.System.Object>, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeReader_void__OnWriterCompleted_0__2__System_Action_System_Exception_object__Object(&__thrown, self.get_handle(), callback.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func OnWriterCompleted(callback : @escaping (Optional<dotnet.System.Exception>, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_callback = try dotnet.System.Action_2<dotnet.System.Exception,dotnet.System.Object>(callback);
        return try OnWriterCompleted(callback: del_callback, state: state);
    }
    // System.Threading.Tasks.ValueTask<System.IO.Pipelines.ReadResult> ReadAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeReader.ReadAsync(System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current .

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A  representing the asynchronous read operation.

    */
    open func ReadAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.System.IO.Pipelines.ReadResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_System_Threading_Tasks_ValueTask_System_IO_Pipelines_ReadResult___ReadAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.IO.Pipelines.ReadResult> ReadAtLeastAsync(System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeReader.ReadAtLeastAsync(System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current .

    - Parameter minimumSize: The minimum length that needs to be buffered in order to for the call to return.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A  representing the asynchronous read operation.

    */
    open func ReadAtLeastAsync(minimumSize : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.System.IO.Pipelines.ReadResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeReader_System_Threading_Tasks_ValueTask_System_IO_Pipelines_ReadResult___ReadAtLeastAsync_0__2__i32_CancellationToken(&__thrown, self.get_handle(), minimumSize, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool TryRead(ref System.IO.Pipelines.ReadResult)
// docid: M:System.IO.Pipelines.PipeReader.TryRead(System.IO.Pipelines.ReadResult@)
    /**
    Attempts to synchronously read data from the .

    - Parameter result: When this method returns , this value is set to a  instance that represents the result of the read call; otherwise, this value is set to .
    - Returns:  if data was available, or if the call was canceled or the writer was completed; otherwise, .

    */
    open func TryRead(result : inout Optional<aspnetcore.System.IO.Pipelines.ReadResult>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_result = (result != nil) ? (result!.get_handle()) : nil;
        let __return = System_IO_Pipelines_PipeReader_bool__TryRead_0__1__outReadResult(&__thrown, self.get_handle(), &_tmp_out_result);
        let __h__tmp2_result = _tmp_out_result;
        let _tmp2_result = (__h__tmp2_result != nil) ? aspnetcore.System.IO.Pipelines.ReadResult(hndl: __h__tmp2_result!) : nil;
            result = _tmp2_result;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // PipeReader


// type: System.IO.Pipelines.PipeScheduler
    /**
    Abstraction for running  and  callbacks and continuations.

    */
open class PipeScheduler
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_PipeScheduler_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Schedule(System.Action<System.Object>, System.Object)
// docid: M:System.IO.Pipelines.PipeScheduler.Schedule(System.Action{System.Object},System.Object)
    /**
    Requests  to be run on scheduler with  being passed in.

    - Parameter action: The single-parameter action delegate to schedule.
    - Parameter state: The parameter to pass to the  delegate.
    */
    open func Schedule(action : dotnet.System.Action_1<dotnet.System.Object>, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeScheduler_void__Schedule_0__2__System_Action_object__Object(&__thrown, self.get_handle(), action.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Schedule(action : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_action = try dotnet.System.Action_1<dotnet.System.Object>(action);
        return try Schedule(action: del_action, state: state);
    }
    // [IsSpecialName] System.IO.Pipelines.PipeScheduler get_Inline()
// docid: M:System.IO.Pipelines.PipeScheduler.get_Inline
    open class func get_Inline() throws -> aspnetcore.System.IO.Pipelines.PipeScheduler {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeScheduler_PipeScheduler__get_Inline_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeScheduler(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Pipelines.PipeScheduler get_ThreadPool()
// docid: M:System.IO.Pipelines.PipeScheduler.get_ThreadPool
    open class func get_ThreadPool() throws -> aspnetcore.System.IO.Pipelines.PipeScheduler {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeScheduler_PipeScheduler__get_ThreadPool_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeScheduler(hndl : __return);
        }
    }
    /**
    The  implementation that runs callbacks inline.

    */
    public static var Inline : aspnetcore.System.IO.Pipelines.PipeScheduler {
        get {
            return try! get_Inline();
        }
    }
    /**
    The  implementation that queues callbacks to the thread pool.

    */
    public static var ThreadPool : aspnetcore.System.IO.Pipelines.PipeScheduler {
        get {
            return try! get_ThreadPool();
        }
    }
} // PipeScheduler


// type: System.IO.Pipelines.PipeWriter
    /**
    Defines a class that provides a pipeline to which data can be written.

    */
open class PipeWriter
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_PipeWriter_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Advance(System.Int32)
// docid: M:System.IO.Pipelines.PipeWriter.Advance(System.Int32)
    /**
    Notifies the  that  bytes were written to the output  or . You must request a new buffer after calling  to continue writing more data; you cannot write to a previously acquired buffer.

    - Parameter bytes: The number of bytes written to the  or .
    */
    open func Advance(bytes : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeWriter_void__Advance_0__1__i32(&__thrown, self.get_handle(), bytes);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.Stream AsStream(bool)
// docid: M:System.IO.Pipelines.PipeWriter.AsStream(System.Boolean)
    /**
    Returns a  representation of the .

    - Parameter leaveOpen: An optional flag that indicates whether disposing the returned  leaves  open () or completes  ().
    - Returns: A stream that represents the .

    */
    open func AsStream(leaveOpen : Bool = false) throws -> dotnet.System.IO.Stream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_Stream__AsStream_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Stream(hndl : __return);
        }
    }
    // void CancelPendingFlush()
// docid: M:System.IO.Pipelines.PipeWriter.CancelPendingFlush
    /**
    Cancels the pending  or  operation without causing the operation to throw and without completing the . If there is no pending operation, this cancels the next operation.

    */
    open func CancelPendingFlush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeWriter_void__CancelPendingFlush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Complete(System.Exception)
// docid: M:System.IO.Pipelines.PipeWriter.Complete(System.Exception)
    /**
    Marks the  as being complete, meaning no more items will be written to it.

    - Parameter exception: Optional  indicating a failure that's causing the pipeline to complete.
    */
    open func Complete(exception : Optional<dotnet.System.Exception> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeWriter_void__Complete_0__1__Exception(&__thrown, self.get_handle(), exception?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask CompleteAsync(System.Exception)
// docid: M:System.IO.Pipelines.PipeWriter.CompleteAsync(System.Exception)
    /**
    Marks the current pipe writer instance as being complete, meaning no more data will be written to it.

    - Parameter exception: An optional exception that indicates the failure that caused the pipeline to complete.
    - Returns: A value task that represents the asynchronous complete operation.

    */
    open func CompleteAsync(exception : Optional<dotnet.System.Exception> = nil) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_ValueTask__CompleteAsync_0__1__Exception(&__thrown, self.get_handle(), exception?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.IO.Pipelines.PipeWriter Create(System.IO.Stream, System.IO.Pipelines.StreamPipeWriterOptions)
// docid: M:System.IO.Pipelines.PipeWriter.Create(System.IO.Stream,System.IO.Pipelines.StreamPipeWriterOptions)
    /**
    Creates a  wrapping the specified .

    - Parameter stream: The stream that the pipe writer will wrap.
    - Parameter writerOptions: The options to configure the pipe writer.
    - Returns: A  that wraps the .

    */
    open class func Create(stream : dotnet.System.IO.Stream, writerOptions : Optional<aspnetcore.System.IO.Pipelines.StreamPipeWriterOptions> = nil) throws -> aspnetcore.System.IO.Pipelines.PipeWriter {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_PipeWriter__Create_0__2__Stream_StreamPipeWriterOptions(&__thrown, stream.get_handle(), writerOptions?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.System.IO.Pipelines.PipeWriter(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.IO.Pipelines.FlushResult> FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeWriter.FlushAsync(System.Threading.CancellationToken)
    /**
    Makes bytes written available to  and runs  continuation.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents and wraps the asynchronous flush operation.

    */
    open func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.System.IO.Pipelines.FlushResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_System_Threading_Tasks_ValueTask_System_IO_Pipelines_FlushResult___FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Memory<System.Byte> GetMemory(System.Int32)
// docid: M:System.IO.Pipelines.PipeWriter.GetMemory(System.Int32)
    /**
    Returns a  to write to that is at least the requested size, as specified by the  parameter.

    - Parameter sizeHint: The minimum length of the returned . If 0, a non-empty memory buffer of arbitrary size is returned.
    - Returns: A memory buffer of at least  bytes. If  is 0, returns a non-empty buffer of arbitrary size.

    */
    open func GetMemory(sizeHint : Swift.Int32 = 0) throws -> dotnet.System.Memory_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_System_Memory_u8___GetMemory_0__1__i32(&__thrown, self.get_handle(), sizeHint);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Memory_1(hndl : __return);
        }
    }
// TODO COPE (returns byreflike): System.Span<System.Byte> GetSpan(System.Int32)
    // void OnReaderCompleted(System.Action<System.Exception,System.Object>, System.Object)
// docid: M:System.IO.Pipelines.PipeWriter.OnReaderCompleted(System.Action{System.Exception,System.Object},System.Object)
    /**
    Registers a callback that executes when the  side of the pipe is completed.

    - Parameter callback: The callback to register.
    - Parameter state: The state object to pass to  when it's invoked.
    */
    open func OnReaderCompleted(callback : dotnet.System.Action_2<dotnet.System.Exception,dotnet.System.Object>, state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipelines_PipeWriter_void__OnReaderCompleted_0__2__System_Action_System_Exception_object__Object(&__thrown, self.get_handle(), callback.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func OnReaderCompleted(callback : @escaping (Optional<dotnet.System.Exception>, Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws {
        let del_callback = try dotnet.System.Action_2<dotnet.System.Exception,dotnet.System.Object>(callback);
        return try OnReaderCompleted(callback: del_callback, state: state);
    }
    // System.Threading.Tasks.ValueTask<System.IO.Pipelines.FlushResult> WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.PipeWriter.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Writes the specified byte memory range to the pipe and makes data accessible to the .

    - Parameter source: The read-only byte memory region to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation, and wraps the flush asynchronous operation.

    */
    open func WriteAsync(source : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.System.IO.Pipelines.FlushResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_System_Threading_Tasks_ValueTask_System_IO_Pipelines_FlushResult___WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), source.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanGetUnflushedBytes()
// docid: M:System.IO.Pipelines.PipeWriter.get_CanGetUnflushedBytes
    open func get_CanGetUnflushedBytes() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_bool__get_CanGetUnflushedBytes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_UnflushedBytes()
// docid: M:System.IO.Pipelines.PipeWriter.get_UnflushedBytes
    open func get_UnflushedBytes() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_PipeWriter_i64__get_UnflushedBytes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value that indicates whether the current  supports reporting the count of unflushed bytes.

    */
    open var CanGetUnflushedBytes : Bool {
        get {
            return try! get_CanGetUnflushedBytes();
        }
    }
    /**
    
            When overridden in a derived class, gets the count of unflushed bytes within the current writer.
            

    */
    open var UnflushedBytes : Swift.Int64 {
        get {
            return try! get_UnflushedBytes();
        }
    }
} // PipeWriter


// type: System.IO.Pipelines.ReadResult
// boxed value type
    /**
    Represents the result of a  call.

    */
public final class ReadResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_ReadResult_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the  that was read.

    */
    public var Buffer : dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8> {
        get {
            return try! get_Buffer();
        }
    }
    /**
    Gets a value that indicates whether the current  operation was canceled by .

    */
    public var IsCanceled : Bool {
        get {
            return try! get_IsCanceled();
        }
    }
    /**
    Gets a value that indicates whether the end of the data stream has been reached.

    */
    public var IsCompleted : Bool {
        get {
            return try! get_IsCompleted();
        }
    }
    // .ctor(System.Buffers.ReadOnlySequence<System.Byte>, bool, bool)
// docid: M:System.IO.Pipelines.ReadResult.#ctor(System.Buffers.ReadOnlySequence{System.Byte},System.Boolean,System.Boolean)
    /**
    Creates a new instance of  setting  and  flags.

    - Parameter buffer: The read-only sequence containing the bytes of data that were read in the  call.
    - Parameter isCanceled: A flag that indicates if the  operation that produced this  was canceled by .
    - Parameter isCompleted: A flag that indicates whether the end of the data stream has been reached.
    */
    public init(buffer : dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>, isCanceled : Bool, isCompleted : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_ReadResult_ctor_0__3__System_Buffers_ReadOnlySequence_u8__bool_bool(&__thrown, buffer.get_handle(), Swift.Int32(isCanceled ? 1 : 0), Swift.Int32(isCompleted ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_IO_Pipelines_ReadResult_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.Buffers.ReadOnlySequence<System.Byte> get_Buffer()
// docid: M:System.IO.Pipelines.ReadResult.get_Buffer
    public func get_Buffer() throws -> dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_ReadResult_System_Buffers_ReadOnlySequence_u8___get_Buffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.ReadOnlySequence_1(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsCanceled()
// docid: M:System.IO.Pipelines.ReadResult.get_IsCanceled
    public func get_IsCanceled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_ReadResult_bool__get_IsCanceled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsCompleted()
// docid: M:System.IO.Pipelines.ReadResult.get_IsCompleted
    public func get_IsCompleted() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_ReadResult_bool__get_IsCompleted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // ReadResult


// type: System.IO.Pipelines.StreamPipeExtensions
public struct StreamPipeExtensions {
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.IO.Pipelines.PipeWriter, System.Threading.CancellationToken)
// docid: M:System.IO.Pipelines.StreamPipeExtensions.CopyToAsync(System.IO.Stream,System.IO.Pipelines.PipeWriter,System.Threading.CancellationToken)
    /**
    Asynchronously reads the bytes from the  and writes them to the specified , using a cancellation token.

    - Parameter source: The stream from which the contents of the current stream will be copied.
    - Parameter destination: The writer to which the contents of the source stream will be copied.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous copy operation.

    */
    public static func CopyToAsync(source : dotnet.System.IO.Stream, destination : aspnetcore.System.IO.Pipelines.PipeWriter, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) async throws {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeExtensions_Task__CopyToAsync_0__3__Stream_PipeWriter_CancellationToken(&__thrown, source.get_handle(), destination.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return try await dotnet.System.Threading.Tasks.Task(hndl: __return).ToAsync();
        }
    }
} // StreamPipeExtensions


// type: System.IO.Pipelines.StreamPipeReaderOptions
    /**
    Represents a set of options for controlling the creation of the .

    */
open class StreamPipeReaderOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_StreamPipeReaderOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Buffers.MemoryPool<System.Byte>, System.Int32, System.Int32, bool)
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.#ctor(System.Buffers.MemoryPool{System.Byte},System.Int32,System.Int32,System.Boolean)
    /**
    Initializes a  instance, optionally specifying a memory pool, a minimum buffer size, a minimum read size, and whether the underlying stream should be left open after the  completes.

    - Parameter pool: The memory pool to use when allocating memory. The default value is .
    - Parameter bufferSize: The minimum buffer size to use when renting memory from the . The default value is 4096.
    - Parameter minimumReadSize: The threshold of remaining bytes in the buffer before a new buffer is allocated. The default value is 1024.
    - Parameter leaveOpen:  to leave the underlying stream open after the  completes;  to close it. The default is .
    */
    public init(pool : Optional<dotnet.System.Buffers.MemoryPool_1<Swift.UInt8>>, bufferSize : Swift.Int32, minimumReadSize : Swift.Int32, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_StreamPipeReaderOptions_ctor_0__4__System_Buffers_MemoryPool_u8__i32_i32_bool(&__thrown, (pool?.get_handle()), bufferSize, minimumReadSize, Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Buffers.MemoryPool<System.Byte>, System.Int32, System.Int32, bool, bool)
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.#ctor(System.Buffers.MemoryPool{System.Byte},System.Int32,System.Int32,System.Boolean,System.Boolean)
    /**
    Initializes a  instance, optionally specifying a memory pool, a minimum buffer size, a minimum read size, and whether the underlying stream should be left open after the  completes.

    - Parameter pool: The memory pool to use when allocating memory. The default value is .
    - Parameter bufferSize: The minimum buffer size to use when renting memory from the . The default value is 4096.
    - Parameter minimumReadSize: The threshold of remaining bytes in the buffer before a new buffer is allocated. The default value is 1024.
    - Parameter leaveOpen:  to leave the underlying stream open after the  completes;  to close it. The default is .
    - Parameter useZeroByteReads:  if reads with an empty buffer should be issued to the underlying stream before allocating memory; otherwise, .
    */
    public init(pool : Optional<dotnet.System.Buffers.MemoryPool_1<Swift.UInt8>>, bufferSize : Swift.Int32, minimumReadSize : Swift.Int32, leaveOpen : Bool, useZeroByteReads : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_StreamPipeReaderOptions_ctor_0__5__System_Buffers_MemoryPool_u8__i32_i32_bool_bool(&__thrown, (pool?.get_handle()), bufferSize, minimumReadSize, Swift.Int32(leaveOpen ? 1 : 0), Swift.Int32(useZeroByteReads ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_BufferSize()
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.get_BufferSize
    open func get_BufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeReaderOptions_i32__get_BufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_LeaveOpen()
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.get_LeaveOpen
    open func get_LeaveOpen() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeReaderOptions_bool__get_LeaveOpen_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_MinimumReadSize()
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.get_MinimumReadSize
    open func get_MinimumReadSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeReaderOptions_i32__get_MinimumReadSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Buffers.MemoryPool<System.Byte> get_Pool()
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.get_Pool
    open func get_Pool() throws -> dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeReaderOptions_System_Buffers_MemoryPool_u8___get_Pool_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.MemoryPool_1(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_UseZeroByteReads()
// docid: M:System.IO.Pipelines.StreamPipeReaderOptions.get_UseZeroByteReads
    open func get_UseZeroByteReads() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeReaderOptions_bool__get_UseZeroByteReads_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets the minimum buffer size to use when renting memory from the .

    */
    open var BufferSize : Swift.Int32 {
        get {
            return try! get_BufferSize();
        }
    }
    /**
    Gets the value that indicates if the underlying stream should be left open after the  completes.

    */
    open var LeaveOpen : Bool {
        get {
            return try! get_LeaveOpen();
        }
    }
    /**
    Gets the threshold of remaining bytes in the buffer before a new buffer is allocated.

    */
    open var MinimumReadSize : Swift.Int32 {
        get {
            return try! get_MinimumReadSize();
        }
    }
    /**
    Gets the  to use when allocating memory.

    */
    open var Pool : dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        get {
            return try! get_Pool();
        }
    }
    /**
    Gets the value that indicates if reads with an empty buffer should be issued to the underlying stream, in order to wait for data to arrive before allocating memory.

    */
    open var UseZeroByteReads : Bool {
        get {
            return try! get_UseZeroByteReads();
        }
    }
} // StreamPipeReaderOptions


// type: System.IO.Pipelines.StreamPipeWriterOptions
    /**
    Represents a set of options for controlling the creation of the .

    */
open class StreamPipeWriterOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipelines_StreamPipeWriterOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Buffers.MemoryPool<System.Byte>, System.Int32, bool)
// docid: M:System.IO.Pipelines.StreamPipeWriterOptions.#ctor(System.Buffers.MemoryPool{System.Byte},System.Int32,System.Boolean)
    /**
    Initializes a  instance, optionally specifying a memory pool, a minimum buffer size, and whether the underlying stream should be left open after the  completes.

    - Parameter pool: The memory pool to use when allocating memory. The default value is .
    - Parameter minimumBufferSize: The minimum buffer size to use when renting memory from the . The default value is 4096.
    - Parameter leaveOpen:  to leave the underlying stream open after the  completes;  to close it. The default is .
    */
    public init(pool : Optional<dotnet.System.Buffers.MemoryPool_1<Swift.UInt8>>, minimumBufferSize : Swift.Int32, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipelines_StreamPipeWriterOptions_ctor_0__3__System_Buffers_MemoryPool_u8__i32_bool(&__thrown, (pool?.get_handle()), minimumBufferSize, Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_LeaveOpen()
// docid: M:System.IO.Pipelines.StreamPipeWriterOptions.get_LeaveOpen
    open func get_LeaveOpen() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeWriterOptions_bool__get_LeaveOpen_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_MinimumBufferSize()
// docid: M:System.IO.Pipelines.StreamPipeWriterOptions.get_MinimumBufferSize
    open func get_MinimumBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeWriterOptions_i32__get_MinimumBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Buffers.MemoryPool<System.Byte> get_Pool()
// docid: M:System.IO.Pipelines.StreamPipeWriterOptions.get_Pool
    open func get_Pool() throws -> dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipelines_StreamPipeWriterOptions_System_Buffers_MemoryPool_u8___get_Pool_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Buffers.MemoryPool_1(hndl : __return);
        }
    }
    /**
    Gets the value that indicates if the underlying stream should be left open after the  completes.

    */
    open var LeaveOpen : Bool {
        get {
            return try! get_LeaveOpen();
        }
    }
    /**
    Gets the minimum buffer size to use when renting memory from the .

    */
    open var MinimumBufferSize : Swift.Int32 {
        get {
            return try! get_MinimumBufferSize();
        }
    }
    /**
    Gets the  to use when allocating memory.

    */
    open var Pool : dotnet.System.Buffers.MemoryPool_1<Swift.UInt8> {
        get {
            return try! get_Pool();
        }
    }
} // StreamPipeWriterOptions


}



public protocol System_IO_Pipelines_IDuplexPipe
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.IO.Pipelines.PipeWriter, System.Threading.CancellationToken)
extension dotnet.System.IO.Stream {
    public func CopyToAsync(destination : aspnetcore.System.IO.Pipelines.PipeWriter, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) async throws {
        return try await aspnetcore.System.IO.Pipelines.StreamPipeExtensions.CopyToAsync(source: self, destination: destination, cancellationToken: cancellationToken);
    }
}

