// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Builder
extension Microsoft.AspNetCore.Builder {
// type: Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder
    /**
    
            Builds conventions that will be used for customization of Connection  instances.
            

    */
public final class ConnectionEndpointRouteBuilder
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Builder_IEndpointConventionBuilder
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Builder_ConnectionEndpointRouteBuilder_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Builder_ConnectionEndpointRouteBuilder_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // void Add(System.Action<Microsoft.AspNetCore.Builder.EndpointBuilder>)
// docid: M:Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder.Add(System.Action{Microsoft.AspNetCore.Builder.EndpointBuilder})
    /**
    
            Adds the specified convention to the builder. Conventions are used to customize  instances.
            

    - Parameter convention: The convention to add to the builder.
    */
    public func Add(convention : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Builder_ConnectionEndpointRouteBuilder_void__Add_0__1__System_Action_Microsoft_AspNetCore_Builder_EndpointBuilder_(&__thrown, self.get_handle(), convention.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public func Add(convention : @escaping (aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder) throws -> Void) throws {
        let del_convention = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Builder.EndpointBuilder>(convention);
        return try Add(convention: del_convention);
    }
} // ConnectionEndpointRouteBuilder


// type: Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions
public struct ConnectionEndpointRouteBuilderExtensions {
    // Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder>)
// docid: M:Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.String,System.Action{Microsoft.AspNetCore.Connections.IConnectionBuilder})
    /**
    
            Maps incoming requests with the specified path to the provided connection pipeline.
            

    - Parameter endpoints: The  to add the route to.
    - Parameter pattern: The route pattern.
    - Parameter configure: A callback to configure the connection.
    - Returns: An  for endpoints associated with the connections.

    */
    public static func MapConnections(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, pattern : dotnet.System.String, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ConnectionEndpointRouteBuilderExtensions_ConnectionEndpointRouteBuilder__MapConnections_0__3__IEndpointRouteBuilder_String_System_Action_Microsoft_AspNetCore_Connections_IConnectionBuilder_(&__thrown, endpoints.get_handle(), pattern.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func MapConnections(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, pattern : dotnet.System.String, configure : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>(configure);
        return try MapConnections(endpoints: endpoints, pattern: pattern, configure: del_configure);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
    // Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder>)
// docid: M:Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder,System.String,Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions,System.Action{Microsoft.AspNetCore.Connections.IConnectionBuilder})
    /**
    
            Maps incoming requests with the specified path to the provided connection pipeline.
            

    - Parameter endpoints: The  to add the route to.
    - Parameter pattern: The route pattern.
    - Parameter options: Options used to configure the connection.
    - Parameter configure: A callback to configure the connection.
    - Returns: An  for endpoints associated with the connections.

    */
    public static func MapConnections(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, pattern : dotnet.System.String, options : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Builder_ConnectionEndpointRouteBuilderExtensions_ConnectionEndpointRouteBuilder__MapConnections_0__4__IEndpointRouteBuilder_String_HttpConnectionDispatcherOptions_System_Action_Microsoft_AspNetCore_Connections_IConnectionBuilder_(&__thrown, endpoints.get_handle(), pattern.get_handle(), options.get_handle(), configure.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func MapConnections(endpoints : aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, pattern : dotnet.System.String, options : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, configure : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>(configure);
        return try MapConnections(endpoints: endpoints, pattern: pattern, options: options, configure: del_configure);
    }
} // ConnectionEndpointRouteBuilderExtensions


}

// Microsoft.AspNetCore.Http
// Microsoft.AspNetCore.Http.Connections
extension Microsoft.AspNetCore.Http.Connections {
// type: Microsoft.AspNetCore.Http.Connections.ConnectionOptions
    /**
    
            Options used to change behavior of how connections are handled.
            

    */
open class ConnectionOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_ConnectionOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_ConnectionOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.ConnectionOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_ConnectionOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Nullable<System.TimeSpan> get_DisconnectTimeout()
// docid: M:Microsoft.AspNetCore.Http.Connections.ConnectionOptions.get_DisconnectTimeout
    open func get_DisconnectTimeout() throws -> Optional<dotnet.System.TimeSpan> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_ConnectionOptions_System_Nullable_System_TimeSpan___get_DisconnectTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return != nil) ? (dotnet.System.TimeSpan(hndl: __return!)) : nil;
        }
    }
    // [IsSpecialName] void set_DisconnectTimeout(System.Nullable<System.TimeSpan>)
// docid: M:Microsoft.AspNetCore.Http.Connections.ConnectionOptions.set_DisconnectTimeout(System.Nullable{System.TimeSpan})
    open func set_DisconnectTimeout(value : Optional<dotnet.System.TimeSpan>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_ConnectionOptions_void__set_DisconnectTimeout_0__1__System_Nullable_System_TimeSpan_(&__thrown, self.get_handle(), (value != nil) ? value!.get_handle() : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the interval used by the server to timeout idle connections.
            

    */
    open var DisconnectTimeout : Optional<dotnet.System.TimeSpan> {
        get {
            return try! get_DisconnectTimeout();
        }
        set(v) {
            return try! set_DisconnectTimeout(value: v!);
        }
    }
} // ConnectionOptions


// type: Microsoft.AspNetCore.Http.Connections.ConnectionOptionsSetup
    /**
    
            Sets up .
            

    */
open class ConnectionOptionsSetup
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_ConnectionOptionsSetup_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_ConnectionOptionsSetup_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // static field: System.TimeSpan DefaultDisconectTimeout
    /**
    
            Default timeout value for disconnecting idle connections.
            

    */
    open class var DefaultDisconectTimeout : dotnet.System.TimeSpan {
        get {
        let __return = dotnet.System.TimeSpan(hndl: Microsoft_AspNetCore_Http_Connections_ConnectionOptionsSetup_get_DefaultDisconectTimeout());
            return __return;
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.ConnectionOptionsSetup.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_ConnectionOptionsSetup_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Configure(Microsoft.AspNetCore.Http.Connections.ConnectionOptions)
// docid: M:Microsoft.AspNetCore.Http.Connections.ConnectionOptionsSetup.Configure(Microsoft.AspNetCore.Http.Connections.ConnectionOptions)
    /**
    
            Sets default values for options if they have not been set yet.
            

    - Parameter options: The .
    */
    open /* method final */ func Configure(options : aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_ConnectionOptionsSetup_void__Configure_0__1__ConnectionOptions(&__thrown, self.get_handle(), options.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ConnectionOptionsSetup


// type: Microsoft.AspNetCore.Http.Connections.HttpConnectionContextExtensions
public struct HttpConnectionContextExtensions {
    // Microsoft.AspNetCore.Http.HttpContext GetHttpContext(Microsoft.AspNetCore.Connections.ConnectionContext)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionContextExtensions.GetHttpContext(Microsoft.AspNetCore.Connections.ConnectionContext)
    /**
    
            Gets the  associated with the connection, if there is one.
            

    - Parameter connection: The  representing the connection.
    - Returns: The  associated with the connection, or  if the connection is not HTTP-based.

    */
    public static func GetHttpContext(connection : aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionContextExtensions_HttpContext__GetHttpContext_0__1__ConnectionContext(&__thrown, connection.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Http.HttpContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // HttpConnectionContextExtensions


// type: Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions
    /**
    
            Options used to configure the HTTP connection dispatcher.
            

    */
open class HttpConnectionDispatcherOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.#ctor
    /**
    
            Initializes a new instance of the  class.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.Authorization.IAuthorizeData> get_AuthorizationData()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_AuthorizationData
    open func get_AuthorizationData() throws -> dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Authorization.IAuthorizeData> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_System_Collections_Generic_IList_Microsoft_AspNetCore_Authorization_IAuthorizeData___get_AuthorizationData_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IList_1(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Connections.HttpTransportType get_Transports()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_Transports
    open func get_Transports() throws -> aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_HttpTransportType__get_Transports_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: __return);
        }
    }
    // [IsSpecialName] void set_Transports(Microsoft.AspNetCore.Http.Connections.HttpTransportType)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_Transports(Microsoft.AspNetCore.Http.Connections.HttpTransportType)
    open func set_Transports(value : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_Transports_0__1__HttpTransportType(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Connections.WebSocketOptions get_WebSockets()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_WebSockets
    open func get_WebSockets() throws -> aspnetcore.Microsoft.AspNetCore.Http.Connections.WebSocketOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_WebSocketOptions__get_WebSockets_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Connections.WebSocketOptions(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Connections.LongPollingOptions get_LongPolling()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_LongPolling
    open func get_LongPolling() throws -> aspnetcore.Microsoft.AspNetCore.Http.Connections.LongPollingOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_LongPollingOptions__get_LongPolling_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Connections.LongPollingOptions(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_TransportMaxBufferSize()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_TransportMaxBufferSize
    open func get_TransportMaxBufferSize() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_i64__get_TransportMaxBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_TransportMaxBufferSize(System.Int64)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_TransportMaxBufferSize(System.Int64)
    open func set_TransportMaxBufferSize(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_TransportMaxBufferSize_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_ApplicationMaxBufferSize()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_ApplicationMaxBufferSize
    open func get_ApplicationMaxBufferSize() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_i64__get_ApplicationMaxBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ApplicationMaxBufferSize(System.Int64)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_ApplicationMaxBufferSize(System.Int64)
    open func set_ApplicationMaxBufferSize(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_ApplicationMaxBufferSize_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_MinimumProtocolVersion()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_MinimumProtocolVersion
    open func get_MinimumProtocolVersion() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_i32__get_MinimumProtocolVersion_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_MinimumProtocolVersion(System.Int32)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_MinimumProtocolVersion(System.Int32)
    open func set_MinimumProtocolVersion(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_MinimumProtocolVersion_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_TransportSendTimeout()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_TransportSendTimeout
    open func get_TransportSendTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_TimeSpan__get_TransportSendTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_TransportSendTimeout(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_TransportSendTimeout(System.TimeSpan)
    open func set_TransportSendTimeout(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_TransportSendTimeout_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CloseOnAuthenticationExpiration()
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.get_CloseOnAuthenticationExpiration
    open func get_CloseOnAuthenticationExpiration() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_bool__get_CloseOnAuthenticationExpiration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_CloseOnAuthenticationExpiration(bool)
// docid: M:Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions.set_CloseOnAuthenticationExpiration(System.Boolean)
    open func set_CloseOnAuthenticationExpiration(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_HttpConnectionDispatcherOptions_void__set_CloseOnAuthenticationExpiration_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the maximum buffer size for data written by the application before backpressure is applied.
            

    */
    open var ApplicationMaxBufferSize : Swift.Int64 {
        get {
            return try! get_ApplicationMaxBufferSize();
        }
        set(v) {
            return try! set_ApplicationMaxBufferSize(value: v);
        }
    }
    /**
    
            Gets a collection of  used during HTTP connection pipeline.
            

    */
    open var AuthorizationData : dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.Authorization.IAuthorizeData> {
        get {
            return try! get_AuthorizationData();
        }
    }
    /**
    
            Authenticated connections whose token sets the  value will be closed
            and allowed to reconnect when the token expires.
            

    */
    open var CloseOnAuthenticationExpiration : Bool {
        get {
            return try! get_CloseOnAuthenticationExpiration();
        }
        set(v) {
            return try! set_CloseOnAuthenticationExpiration(value: v);
        }
    }
    /**
    
            Gets the  used by the long polling transport.
            

    */
    open var LongPolling : aspnetcore.Microsoft.AspNetCore.Http.Connections.LongPollingOptions {
        get {
            return try! get_LongPolling();
        }
    }
    /**
    
            Gets or sets the minimum protocol verison supported by the server.
            The default value is 0, the lowest possible protocol version.
            

    */
    open var MinimumProtocolVersion : Swift.Int32 {
        get {
            return try! get_MinimumProtocolVersion();
        }
        set(v) {
            return try! set_MinimumProtocolVersion(value: v);
        }
    }
    /**
    
            Gets or sets the maximum buffer size for data read by the application before backpressure is applied.
            

    */
    open var TransportMaxBufferSize : Swift.Int64 {
        get {
            return try! get_TransportMaxBufferSize();
        }
        set(v) {
            return try! set_TransportMaxBufferSize(value: v);
        }
    }
    /**
    
            Gets or sets the amount of time the transport will wait for a send to complete. If a single send exceeds this timeout
            the connection is closed.
            

    */
    open var TransportSendTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_TransportSendTimeout();
        }
        set(v) {
            return try! set_TransportSendTimeout(value: v);
        }
    }
    /**
    
            Gets or sets a bitmask combining one or more  values that specify what transports the server should use to receive HTTP requests.
            

    */
    open var Transports : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        get {
            return try! get_Transports();
        }
        set(v) {
            return try! set_Transports(value: v);
        }
    }
    /**
    
            Gets the  used by the web sockets transport.
            

    */
    open var WebSockets : aspnetcore.Microsoft.AspNetCore.Http.Connections.WebSocketOptions {
        get {
            return try! get_WebSockets();
        }
    }
} // HttpConnectionDispatcherOptions


// type: Microsoft.AspNetCore.Http.Connections.LongPollingOptions
    /**
    
            Options used to configure the long polling transport.
            

    */
open class LongPollingOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_LongPollingOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_LongPollingOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.LongPollingOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_LongPollingOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.TimeSpan get_PollTimeout()
// docid: M:Microsoft.AspNetCore.Http.Connections.LongPollingOptions.get_PollTimeout
    open func get_PollTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_LongPollingOptions_TimeSpan__get_PollTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_PollTimeout(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Http.Connections.LongPollingOptions.set_PollTimeout(System.TimeSpan)
    open func set_PollTimeout(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_LongPollingOptions_void__set_PollTimeout_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets the poll timeout.
            

    */
    open var PollTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_PollTimeout();
        }
        set(v) {
            return try! set_PollTimeout(value: v);
        }
    }
} // LongPollingOptions


// type: Microsoft.AspNetCore.Http.Connections.NegotiateMetadata
    /**
    
            Metadata to identify the /negotiate endpoint for HTTP connections
            

    */
open class NegotiateMetadata
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_NegotiateMetadata_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_NegotiateMetadata_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.NegotiateMetadata.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_NegotiateMetadata_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // NegotiateMetadata


// type: Microsoft.AspNetCore.Http.Connections.WebSocketOptions
    /**
    
            Options used by the WebSockets transport to modify the transports behavior.
            

    */
open class WebSocketOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_WebSocketOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_WebSocketOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Http.Connections.WebSocketOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Http_Connections_WebSocketOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.TimeSpan get_CloseTimeout()
// docid: M:Microsoft.AspNetCore.Http.Connections.WebSocketOptions.get_CloseTimeout
    open func get_CloseTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_WebSocketOptions_TimeSpan__get_CloseTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void set_CloseTimeout(System.TimeSpan)
// docid: M:Microsoft.AspNetCore.Http.Connections.WebSocketOptions.set_CloseTimeout(System.TimeSpan)
    open func set_CloseTimeout(value : dotnet.System.TimeSpan) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_WebSocketOptions_void__set_CloseTimeout_0__1__TimeSpan(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Func<System.Collections.Generic.IList<System.String>,System.String> get_SubProtocolSelector()
// docid: M:Microsoft.AspNetCore.Http.Connections.WebSocketOptions.get_SubProtocolSelector
    open func get_SubProtocolSelector() throws -> Optional<dotnet.System.Func_2<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>,dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_WebSocketOptions_System_Func_System_Collections_Generic_System_Collections_Generic_IList_string__string___get_SubProtocolSelector_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_SubProtocolSelector(System.Func<System.Collections.Generic.IList<System.String>,System.String>)
// docid: M:Microsoft.AspNetCore.Http.Connections.WebSocketOptions.set_SubProtocolSelector(System.Func{System.Collections.Generic.IList{System.String},System.String})
    open func set_SubProtocolSelector(value : Optional<dotnet.System.Func_2<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>,dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_WebSocketOptions_void__set_SubProtocolSelector_0__1__System_Func_System_Collections_Generic_System_Collections_Generic_IList_string__string_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_SubProtocolSelector(value : @escaping (dotnet.System.Collections.Generic.IList_1<dotnet.System.String>) throws -> dotnet.System.String) throws {
        let del_value = try dotnet.System.Func_2<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>,dotnet.System.String>(value);
        return try set_SubProtocolSelector(value: del_value);
    }
    /**
    
            Gets or sets the amount of time the WebSocket transport will wait for a graceful close before starting an ungraceful close.
            

    */
    open var CloseTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_CloseTimeout();
        }
        set(v) {
            return try! set_CloseTimeout(value: v);
        }
    }
    /**
    
            Gets or sets a delegate that will be called when a new WebSocket is established to select the value
            for the 'Sec-WebSocket-Protocol' response header. The delegate will be called with a list of the protocols provided
            by the client in the 'Sec-WebSocket-Protocol' request header.
            

    */
    open var SubProtocolSelector : Optional<dotnet.System.Func_2<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>,dotnet.System.String>> {
        get {
            return try! get_SubProtocolSelector();
        }
        set(v) {
            return try! set_SubProtocolSelector(value: v!);
        }
    }
} // WebSocketOptions


}
// Microsoft.AspNetCore.Http.Connections.Features
extension Microsoft.AspNetCore.Http.Connections.Features {
// type: Microsoft.AspNetCore.Http.Connections.Features.IHttpContextFeature
    /**
    
            Feature set on the  that provides access to the underlying 
            associated with the connection if there is one.
            

    */
open class IHttpContextFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.HttpContext get_HttpContext()
// docid: M:Microsoft.AspNetCore.Http.Connections.Features.IHttpContextFeature.get_HttpContext
    open func get_HttpContext() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature_HttpContext__get_HttpContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Http.HttpContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_HttpContext(Microsoft.AspNetCore.Http.HttpContext)
// docid: M:Microsoft.AspNetCore.Http.Connections.Features.IHttpContextFeature.set_HttpContext(Microsoft.AspNetCore.Http.HttpContext)
    open func set_HttpContext(value : Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature_void__set_HttpContext_0__1__HttpContext(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IHttpContextFeature


// type: Microsoft.AspNetCore.Http.Connections.Features.IHttpTransportFeature
    /**
    
            Feature set on the  that exposes the 
            the connection is using.
            

    */
open class IHttpTransportFeature
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Http_Connections_Features_IHttpTransportFeature
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Http_Connections_Features_IHttpTransportFeature_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Http_Connections_Features_IHttpTransportFeature_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.Connections.HttpTransportType get_TransportType()
// docid: M:Microsoft.AspNetCore.Http.Connections.Features.IHttpTransportFeature.get_TransportType
    open func get_TransportType() throws -> aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Http_Connections_Features_IHttpTransportFeature_HttpTransportType__get_TransportType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpTransportType(val: __return);
        }
    }
} // IHttpTransportFeature


}




// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions
public struct ConnectionsDependencyInjectionExtensions {
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Adds required services for ASP.NET Core Connection Handlers to the specified .
            

    - Parameter services: The  to add services to.
    - Returns: The same instance of the  for chaining.

    */
    public static func AddConnections(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ConnectionsDependencyInjectionExtensions_IServiceCollection__AddConnections_0__1__IServiceCollection(&__thrown, services.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.Http.Connections.ConnectionOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.AspNetCore.Http.Connections.ConnectionOptions})
    /**
    
            Adds required services for ASP.NET Core Connection Handlers to the specified .
            

    - Parameter services: The  to add services to.
    - Parameter options: A callback to configure  
    - Returns: The same instance of the  for chaining.

    */
    public static func AddConnections(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, options : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_ConnectionsDependencyInjectionExtensions_IServiceCollection__AddConnections_0__2__IServiceCollection_System_Action_Microsoft_AspNetCore_Http_Connections_ConnectionOptions_(&__thrown, services.get_handle(), options.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddConnections(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, options : @escaping (aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_options = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions>(options);
        return try AddConnections(services: services, options: del_options);
    }
} // ConnectionsDependencyInjectionExtensions


}



public protocol Microsoft_AspNetCore_Http_Connections_Features_IHttpContextFeature
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Http_Connections_Features_IHttpTransportFeature
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder>)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapConnections(pattern : dotnet.System.String, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), pattern: pattern, configure: configure);
    }
    // delegate closure overload
    public func MapConnections(pattern : dotnet.System.String, configure : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>(configure);
        return try aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), pattern: pattern, configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String)
// TODO COPE extension method (unused generic param) Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String)

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)
// TODO COPE extension method (unused generic param) Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnectionHandler<TConnectionHandler>(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, System.Action<Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions>)

// EXTENSION METHOD Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder MapConnections(Microsoft.AspNetCore.Routing.IEndpointRouteBuilder, System.String, Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, System.Action<Microsoft.AspNetCore.Connections.IConnectionBuilder>)
extension Microsoft_AspNetCore_Routing_IEndpointRouteBuilder {
    public func MapConnections(pattern : dotnet.System.String, options : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, configure : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), pattern: pattern, options: options, configure: configure);
    }
    // delegate closure overload
    public func MapConnections(pattern : dotnet.System.String, options : aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionDispatcherOptions, configure : @escaping (aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilder {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionBuilder>(configure);
        return try aspnetcore.Microsoft.AspNetCore.Builder.ConnectionEndpointRouteBuilderExtensions.MapConnections(endpoints: aspnetcore.Microsoft.AspNetCore.Routing.IEndpointRouteBuilder(hndl: __copy_handle(self.get_handle())), pattern: pattern, options: options, configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Http.HttpContext GetHttpContext(Microsoft.AspNetCore.Connections.ConnectionContext)
extension aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext {
    public func GetHttpContext() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext> {
        return try aspnetcore.Microsoft.AspNetCore.Http.Connections.HttpConnectionContextExtensions.GetHttpContext(connection: self);
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddConnections() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddConnections(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.Http.Connections.ConnectionOptions>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddConnections(options : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), options: options);
    }
    // delegate closure overload
    public func AddConnections(options : @escaping (aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions) throws -> Void) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        let del_options = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Http.Connections.ConnectionOptions>(options);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.ConnectionsDependencyInjectionExtensions.AddConnections(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), options: del_options);
    }
}

