// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.FileProviders
extension Microsoft.Extensions.FileProviders {
// type: Microsoft.Extensions.FileProviders.PhysicalFileProvider
    /**
    
            Looks up files using the on-disk file system
            

    */
open class PhysicalFileProvider
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileProviders_IFileProvider,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_PhysicalFileProvider_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_PhysicalFileProvider_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.#ctor(System.String)
    /**
    
            Initializes a new instance of a PhysicalFileProvider at the given root directory.
            

    - Parameter root: The root directory. This should be an absolute path.
    */
    public init(root : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_PhysicalFileProvider_ctor_0__1__String(&__thrown, root?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.#ctor(System.String,Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
    /**
    
            Initializes a new instance of a PhysicalFileProvider at the given root directory.
            

    - Parameter root: The root directory. This should be an absolute path.
    - Parameter filters: Specifies which files or directories are excluded.
    */
    public init(root : Optional<dotnet.System.String>, filters : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_PhysicalFileProvider_ctor_0__2__String_ExclusionFilters(&__thrown, root?.get_handle() ?? nil, filters.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.Dispose
    /**
    
            Disposes the provider. Change tokens may not trigger after the provider is disposed.
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileProviders_PhysicalFileProvider_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.Extensions.FileProviders.IDirectoryContents GetDirectoryContents(System.String)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.GetDirectoryContents(System.String)
    /**
    
            Enumerate a directory at the given path, if any.
            

    - Parameter subpath: A path under the root directory. Leading slashes are ignored.
    - Returns: 
            Contents of the directory. Caller must check  property.  if
             is absolute, if the directory does not exist, or  has invalid
            characters.
            

    */
    open /* method final */ func GetDirectoryContents(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_IDirectoryContents__GetDirectoryContents_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileProviders.IFileInfo GetFileInfo(System.String)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.GetFileInfo(System.String)
    /**
    
            Locate a file at the given path by directly mapping path segments to physical directories.
            

    - Parameter subpath: A path under the root directory
    - Returns: The file information. Caller must check  property. 

    */
    open /* method final */ func GetFileInfo(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_IFileInfo__GetFileInfo_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Primitives.IChangeToken Watch(System.String)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.Watch(System.String)
    /**
    
                Creates a  for the specified .
                Globbing patterns are interpreted by .
            

    - Parameter filter: 
            Filter string used to determine what files or folders to monitor. Example: (ASTERISK)(ASTERISK)/(ASTERISK).cs, (ASTERISK).(ASTERISK),
            subFolder/(ASTERISK)(ASTERISK)/(ASTERISK).cshtml.
            
    - Returns: 
            An  that is notified when a file matching  is added,
            modified or deleted. Returns a  if  has invalid filter
            characters or if  is an absolute path or outside the root directory specified in the
            constructor .
            

    */
    open /* method final */ func Watch(filter : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_IChangeToken__Watch_0__1__String(&__thrown, self.get_handle(), filter?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Primitives.IChangeToken(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Root()
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.get_Root
    open func get_Root() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_String__get_Root_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_UseActivePolling()
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.get_UseActivePolling
    open func get_UseActivePolling() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_bool__get_UseActivePolling_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseActivePolling(bool)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.set_UseActivePolling(System.Boolean)
    open func set_UseActivePolling(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileProviders_PhysicalFileProvider_void__set_UseActivePolling_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UsePollingFileWatcher()
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.get_UsePollingFileWatcher
    open func get_UsePollingFileWatcher() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_PhysicalFileProvider_bool__get_UsePollingFileWatcher_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UsePollingFileWatcher(bool)
// docid: M:Microsoft.Extensions.FileProviders.PhysicalFileProvider.set_UsePollingFileWatcher(System.Boolean)
    open func set_UsePollingFileWatcher(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileProviders_PhysicalFileProvider_void__set_UsePollingFileWatcher_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The root directory for this instance.
            

    */
    open var Root : Optional<dotnet.System.String> {
        get {
            return try! get_Root();
        }
    }
    /**
    
            Gets or sets a value that determines if this instance of 
            actively polls for file changes.
            
            When ,  returned by  will actively poll for file changes
            ( will be ) instead of being passive.
            
            
            This property is only effective when  is set.
            
            

    */
    open var UseActivePolling : Bool {
        get {
            return try! get_UseActivePolling();
        }
        set(v) {
            return try! set_UseActivePolling(value: v);
        }
    }
    /**
    
            Gets or sets a value that determines if this instance of 
            uses polling to determine file changes.
            
            By default,   uses  to listen to file change events
            for .  is ineffective in some scenarios such as mounted drives.
            Polling is required to effectively watch for file changes.
            
            .
            

    */
    open var UsePollingFileWatcher : Bool {
        get {
            return try! get_UsePollingFileWatcher();
        }
        set(v) {
            return try! set_UsePollingFileWatcher(value: v);
        }
    }
} // PhysicalFileProvider


}
// Microsoft.Extensions.FileProviders.Internal
extension Microsoft.Extensions.FileProviders.Internal {
// type: Microsoft.Extensions.FileProviders.Internal.PhysicalDirectoryContents
    /**
    
            Represents the contents of a physical file directory
            

    */
open class PhysicalDirectoryContents
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.Extensions.FileProviders.Internal.PhysicalDirectoryContents.#ctor(System.String)
    /**
    
            Initializes an instance of 
            

    - Parameter directory: The directory
    */
    public init(directory : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_ctor_0__1__String(&__thrown, directory?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
// docid: M:Microsoft.Extensions.FileProviders.Internal.PhysicalDirectoryContents.#ctor(System.String,Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
    /**
    
            Initializes an instance of 
            

    - Parameter directory: The directory
    - Parameter filters: Specifies which files or directories are excluded from enumeration.
    */
    public init(directory : Optional<dotnet.System.String>, filters : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_ctor_0__2__String_ExclusionFilters(&__thrown, directory?.get_handle() ?? nil, filters.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IEnumerator<Microsoft.Extensions.FileProviders.IFileInfo> GetEnumerator()
// docid: M:Microsoft.Extensions.FileProviders.Internal.PhysicalDirectoryContents.GetEnumerator
    /**
    */
    open /* method final */ func GetEnumerator() throws -> Optional<dotnet.System.Collections.Generic.IEnumerator_1<aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_System_Collections_Generic_IEnumerator_Microsoft_Extensions_FileProviders_IFileInfo___GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerator_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.Internal.PhysicalDirectoryContents.get_Exists
    open /* method final */ func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Internal_PhysicalDirectoryContents_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    */
    public var Exists : Bool {
        get {
            return try! get_Exists();
        }
    }
} // PhysicalDirectoryContents


}

// Microsoft.Extensions.FileProviders.Physical
extension Microsoft.Extensions.FileProviders.Physical {
// type: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters
    /**
    
            Specifies filtering behavior for files or directories.
            

    */
public struct ExclusionFilters : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters None
    /**
    
            Do not exclude any files.
            

    */
    public static var None : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters(val: Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_None());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters DotPrefixed
    /**
    
            Exclude files and directories when the name begins with period.
            

    */
    public static var DotPrefixed : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters(val: Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_DotPrefixed());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters Hidden
    /**
    
            Exclude files and directories when  is set on .
            

    */
    public static var Hidden : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters(val: Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_Hidden());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters System
    /**
    
            Exclude files and directories when  is set on .
            

    */
    public static var System : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters(val: Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_System());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.FileProviders.Physical.ExclusionFilters Sensitive
    /**
    
            Equivalent to DotPrefixed | Hidden | System. Exclude files and directories when the name begins with a period, or has either  or  is set on .
            

    */
    public static var Sensitive : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters(val: Microsoft_Extensions_FileProviders_Physical_ExclusionFilters_get_Sensitive());
            return __return;
        }
    }
} // ExclusionFilters


// type: Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo
    /**
    
            Represents a directory on a physical filesystem
            

    */
open class PhysicalDirectoryInfo
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileProviders_IFileInfo
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.IO.DirectoryInfo)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.#ctor(System.IO.DirectoryInfo)
    /**
    
            Initializes an instance of  that wraps an instance of 
            

    - Parameter info: The directory
    */
    public init(info : Optional<dotnet.System.IO.DirectoryInfo>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_ctor_0__1__DirectoryInfo(&__thrown, info?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IO.Stream CreateReadStream()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.CreateReadStream
    /**
    
            Always throws an exception because read streams are not support on directories.
            

    - Returns: Never returns

    */
    open /* method final */ func CreateReadStream() throws -> Optional<dotnet.System.IO.Stream> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_Stream__CreateReadStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.Stream(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_Exists
    open /* method final */ func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsDirectory()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_IsDirectory
    open /* method final */ func get_IsDirectory() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_bool__get_IsDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_LastModified()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_LastModified
    open /* method final */ func get_LastModified() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_DateTimeOffset__get_LastModified_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_Length
    open /* method final */ func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_Name
    open /* method final */ func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_PhysicalPath()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalDirectoryInfo.get_PhysicalPath
    open /* method final */ func get_PhysicalPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalDirectoryInfo_String__get_PhysicalPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    */
    public var Exists : Bool {
        get {
            return try! get_Exists();
        }
    }
    /**
    
            Always true.
            

    */
    public var IsDirectory : Bool {
        get {
            return try! get_IsDirectory();
        }
    }
    /**
    
            The time when the directory was last written to.
            

    */
    public var LastModified : dotnet.System.DateTimeOffset {
        get {
            return try! get_LastModified();
        }
    }
    /**
    
            Always equals -1.
            

    */
    public var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    */
    public var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    */
    public var PhysicalPath : Optional<dotnet.System.String> {
        get {
            return try! get_PhysicalPath();
        }
    }
} // PhysicalDirectoryInfo


// type: Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo
    /**
    
            Represents a file on a physical filesystem
            

    */
open class PhysicalFileInfo
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileProviders_IFileInfo
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.IO.FileInfo)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.#ctor(System.IO.FileInfo)
    /**
    
            Initializes an instance of  that wraps an instance of 
            

    - Parameter info: The 
    */
    public init(info : Optional<dotnet.System.IO.FileInfo>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_ctor_0__1__FileInfo(&__thrown, info?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IO.Stream CreateReadStream()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.CreateReadStream
    /**
    */
    open /* method final */ func CreateReadStream() throws -> Optional<dotnet.System.IO.Stream> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_Stream__CreateReadStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.Stream(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_Exists
    open /* method final */ func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsDirectory()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_IsDirectory
    open /* method final */ func get_IsDirectory() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_bool__get_IsDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_LastModified()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_LastModified
    open /* method final */ func get_LastModified() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_DateTimeOffset__get_LastModified_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_Length
    open /* method final */ func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_Name
    open /* method final */ func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_PhysicalPath()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFileInfo.get_PhysicalPath
    open /* method final */ func get_PhysicalPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFileInfo_String__get_PhysicalPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    */
    public var Exists : Bool {
        get {
            return try! get_Exists();
        }
    }
    /**
    
            Always false.
            

    */
    public var IsDirectory : Bool {
        get {
            return try! get_IsDirectory();
        }
    }
    /**
    */
    public var LastModified : dotnet.System.DateTimeOffset {
        get {
            return try! get_LastModified();
        }
    }
    /**
    */
    public var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    */
    public var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    */
    public var PhysicalPath : Optional<dotnet.System.String> {
        get {
            return try! get_PhysicalPath();
        }
    }
} // PhysicalFileInfo


// type: Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher
    /**
    
                
                A file watcher that watches a physical filesystem for changes.
                
                
                Triggers events on  when files are created, change, renamed, or deleted.
                
            

    */
open class PhysicalFilesWatcher
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String, System.IO.FileSystemWatcher, bool)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.#ctor(System.String,System.IO.FileSystemWatcher,System.Boolean)
    /**
    
            Initializes an instance of  that watches files in .
            Wraps an instance of 
            

    - Parameter root: Root directory for the watcher
    - Parameter fileSystemWatcher: The wrapped watcher that is watching 
    - Parameter pollForChanges: 
            True when the watcher should use polling to trigger instances of
             created by 
            
    */
    public init(root : Optional<dotnet.System.String>, fileSystemWatcher : Optional<dotnet.System.IO.FileSystemWatcher>, pollForChanges : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_ctor_0__3__String_FileSystemWatcher_bool(&__thrown, root?.get_handle() ?? nil, fileSystemWatcher?.get_handle() ?? nil, Swift.Int32(pollForChanges ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileSystemWatcher, bool, Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.#ctor(System.String,System.IO.FileSystemWatcher,System.Boolean,Microsoft.Extensions.FileProviders.Physical.ExclusionFilters)
    /**
    
            Initializes an instance of  that watches files in .
            Wraps an instance of 
            

    - Parameter root: Root directory for the watcher
    - Parameter fileSystemWatcher: The wrapped watcher that is watching 
    - Parameter pollForChanges: 
            True when the watcher should use polling to trigger instances of
             created by 
            
    - Parameter filters: Specifies which files or directories are excluded. Notifications of changes to are not raised to these.
    */
    public init(root : Optional<dotnet.System.String>, fileSystemWatcher : Optional<dotnet.System.IO.FileSystemWatcher>, pollForChanges : Bool, filters : aspnetcore.Microsoft.Extensions.FileProviders.Physical.ExclusionFilters) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_ctor_0__4__String_FileSystemWatcher_bool_ExclusionFilters(&__thrown, root?.get_handle() ?? nil, fileSystemWatcher?.get_handle() ?? nil, Swift.Int32(pollForChanges ? 1 : 0), filters.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.Primitives.IChangeToken CreateFileChangeToken(System.String)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.CreateFileChangeToken(System.String)
    /**
    
                
                Creates an instance of  for all files and directories that match the
                
                
                
                Globbing patterns are relative to the root directory given in the constructor
                . Globbing patterns
                are interpreted by .
                
            

    - Parameter filter: A globbing pattern for files and directories to watch
    - Returns: A change token for all files that match the filter

    */
    open func CreateFileChangeToken(filter : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_IChangeToken__CreateFileChangeToken_0__1__String(&__thrown, self.get_handle(), filter?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Primitives.IChangeToken(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PhysicalFilesWatcher.Dispose
    /**
    
            Disposes the provider. Change tokens may not trigger after the provider is disposed.
            

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileProviders_Physical_PhysicalFilesWatcher_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // PhysicalFilesWatcher


// type: Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken
    /**
    
                
                A change token that polls for file system changes.
                
                
                This change token does not raise any change callbacks. Callers should watch for  to turn
                from false to true
                and dispose the token after this happens.
                
            

    */
open class PollingFileChangeToken
    :
    dotnet.System.Object,
    Microsoft_Extensions_Primitives_IChangeToken
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.IO.FileInfo)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.#ctor(System.IO.FileInfo)
    /**
    
            Initializes a new instance of  that polls the specified file for changes as
            determined by .
            

    - Parameter fileInfo: The  to poll
    */
    public init(fileInfo : Optional<dotnet.System.IO.FileInfo>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_ctor_0__1__FileInfo(&__thrown, fileInfo?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IDisposable RegisterChangeCallback(System.Action<System.Object>, System.Object)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.RegisterChangeCallback(System.Action{System.Object},System.Object)
    /**
    
            Does not actually register callbacks.
            

    - Parameter callback: This parameter is ignored
    - Parameter state: This parameter is ignored
    - Returns: A disposable object that noops when disposed

    */
    open /* method final */ func RegisterChangeCallback(callback : Optional<dotnet.System.Action_1<dotnet.System.Object>>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IDisposable> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_IDisposable__RegisterChangeCallback_0__2__System_Action_object__Object(&__thrown, self.get_handle(), (callback?.get_handle()), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IDisposable(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func RegisterChangeCallback(callback : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IDisposable> {
        let del_callback = try dotnet.System.Action_1<dotnet.System.Object>(callback);
        return try RegisterChangeCallback(callback: del_callback, state: state);
    }
    // [IsSpecialName] bool get_ActiveChangeCallbacks()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.get_ActiveChangeCallbacks
    open /* method final */ func get_ActiveChangeCallbacks() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_bool__get_ActiveChangeCallbacks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HasChanged()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingFileChangeToken.get_HasChanged
    open /* method final */ func get_HasChanged() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PollingFileChangeToken_bool__get_HasChanged_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    
            Always false.
            

    */
    public var ActiveChangeCallbacks : Bool {
        get {
            return try! get_ActiveChangeCallbacks();
        }
    }
    /**
    
            True when the file has changed since the change token was created. Once the file changes, this value is always true
            

    */
    public var HasChanged : Bool {
        get {
            return try! get_HasChanged();
        }
    }
} // PollingFileChangeToken


// type: Microsoft.Extensions.FileProviders.Physical.PollingWildCardChangeToken
    /**
    
            A polling based  for wildcard patterns.
            

    */
open class PollingWildCardChangeToken
    :
    dotnet.System.Object,
    Microsoft_Extensions_Primitives_IChangeToken
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_Physical_PollingWildCardChangeToken_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_FileProviders_Physical_PollingWildCardChangeToken_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingWildCardChangeToken.#ctor(System.String,System.String)
    /**
    
            Initializes a new instance of .
            

    - Parameter root: The root of the file system.
    - Parameter pattern: The pattern to watch.
    */
    public init(root : Optional<dotnet.System.String>, pattern : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_Physical_PollingWildCardChangeToken_ctor_0__2__String_String(&__thrown, root?.get_handle() ?? nil, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_ActiveChangeCallbacks()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingWildCardChangeToken.get_ActiveChangeCallbacks
    open /* method final */ func get_ActiveChangeCallbacks() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PollingWildCardChangeToken_bool__get_ActiveChangeCallbacks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HasChanged()
// docid: M:Microsoft.Extensions.FileProviders.Physical.PollingWildCardChangeToken.get_HasChanged
    open /* method final */ func get_HasChanged() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_Physical_PollingWildCardChangeToken_bool__get_HasChanged_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    */
    public var ActiveChangeCallbacks : Bool {
        get {
            return try! get_ActiveChangeCallbacks();
        }
    }
    /**
    */
    public var HasChanged : Bool {
        get {
            return try! get_HasChanged();
        }
    }
} // PollingWildCardChangeToken


}




