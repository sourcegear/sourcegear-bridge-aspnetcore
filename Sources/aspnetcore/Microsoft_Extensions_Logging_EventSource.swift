// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.Logging
extension Microsoft.Extensions.Logging {
// type: Microsoft.Extensions.Logging.EventSourceLoggerFactoryExtensions
public struct EventSourceLoggerFactoryExtensions {
    // Microsoft.Extensions.Logging.ILoggingBuilder AddEventSourceLogger(Microsoft.Extensions.Logging.ILoggingBuilder)
// docid: M:Microsoft.Extensions.Logging.EventSourceLoggerFactoryExtensions.AddEventSourceLogger(Microsoft.Extensions.Logging.ILoggingBuilder)
    /**
    
            Adds an event logger named 'EventSource' to the factory.
            

    - Parameter builder: The extension method argument.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddEventSourceLogger(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_EventSourceLoggerFactoryExtensions_ILoggingBuilder__AddEventSourceLogger_0__1__ILoggingBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // EventSourceLoggerFactoryExtensions


}
// Microsoft.Extensions.Logging.EventSource
extension Microsoft.Extensions.Logging.EventSource {
// type: Microsoft.Extensions.Logging.EventSource.EventSourceLoggerProvider
    /**
    
            The provider for the .
            

    */
open class EventSourceLoggerProvider
    :
    dotnet.System.Object,
    Microsoft_Extensions_Logging_ILoggerProvider,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_EventSource_EventSourceLoggerProvider_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_EventSource_EventSourceLoggerProvider_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(Microsoft.Extensions.Logging.EventSource.LoggingEventSource)
// docid: M:Microsoft.Extensions.Logging.EventSource.EventSourceLoggerProvider.#ctor(Microsoft.Extensions.Logging.EventSource.LoggingEventSource)
    public init(eventSource : Optional<aspnetcore.Microsoft.Extensions.Logging.EventSource.LoggingEventSource>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_EventSource_EventSourceLoggerProvider_ctor_0__1__LoggingEventSource(&__thrown, eventSource?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.Logging.ILogger CreateLogger(System.String)
// docid: M:Microsoft.Extensions.Logging.EventSource.EventSourceLoggerProvider.CreateLogger(System.String)
    /**
    */
    open /* method final */ func CreateLogger(categoryName : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_EventSource_EventSourceLoggerProvider_ILogger__CreateLogger_0__1__String(&__thrown, self.get_handle(), categoryName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.Logging.EventSource.EventSourceLoggerProvider.Dispose
    /**
    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_EventSource_EventSourceLoggerProvider_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // EventSourceLoggerProvider


// type: Microsoft.Extensions.Logging.EventSource.LoggingEventSource
    /**
    
             The LoggingEventSource is the bridge from all ILogger based logging to EventSource/EventListener logging.
            
             You turn this logging on by enabling the EventSource called
            
                  Microsoft-Extensions-Logging
            
             When you enabled the EventSource, the EventLevel you set is translated in the obvious way to the level
             associated with the ILogger (thus Debug = verbose, Informational = Informational ... Critical == Critical)
            
             This allows you to filter by event level in a straightforward way.
            
             For finer control you can specify a EventSource Argument called
            
             FilterSpecs
            
             The FilterSpecs argument is a semicolon separated list of specifications.   Where each specification is
            
             SPEC =                          // empty spec, same as (ASTERISK)
                  | NAME                     // Just a name the level is the default level
                  | NAME : LEVEL             // specifies level for a particular logger (can have a (ASTERISK) suffix).
            
             When "UseAppFilters" is specified in the FilterSpecs, it avoids disabling all categories which happens by default otherwise.
            
             Where Name is the name of a ILoggger (case matters), Name can have a (ASTERISK) which acts as a wildcard
             AS A SUFFIX.   Thus Net(ASTERISK) will match any loggers that start with the 'Net'.
            
             The LEVEL is a number or a LogLevel string. 0=Trace, 1=Debug, 2=Information, 3=Warning,  4=Error, Critical=5
             This specifies the level for the associated pattern.  If the number is not specified, (first form
             of the specification) it is the default level for the EventSource.
            
             First match is used if a particular name matches more than one pattern.
            
             In addition the level and FilterSpec argument, you can also set EventSource Keywords.  See the Keywords
             definition below, but basically you get to decide if you wish to have
            
               (ASTERISK) Keywords.Message - You get the event with the data in parsed form.
               (ASTERISK) Keywords.JsonMessage - you get an event with the data in parse form but as a JSON blob (not broken up by argument ...)
               (ASTERISK) Keywords.FormattedMessage - you get an event with the data formatted as a string
            
             It is expected that you will turn only one of these keywords on at a time, but you can turn them all on (and get
             the same data logged three different ways.
            
             Example Usage
            
             This example shows how to use an EventListener to get ILogging information
            
             class MyEventListener : EventListener {
                 protected override void OnEventSourceCreated(EventSource eventSource) {
                     if (eventSource.Name == "Microsoft-Extensions-Logging") {
                         // initialize a string, string dictionary of arguments to pass to the EventSource.
                         // Turn on loggers matching App(ASTERISK) to Information, everything else ((ASTERISK)) is the default level (which is EventLevel.Error)
                         var args = new Dictionary<string, string>() { { "FilterSpecs", "App(ASTERISK):Information;(ASTERISK)" } };
                         // Set the default level (verbosity) to Error, and only ask for the formatted messages in this case.
                         EnableEvents(eventSource, EventLevel.Error, LoggingEventSource.Keywords.FormattedMessage, args);
                     }
                 }
                 protected override void OnEventWritten(EventWrittenEventArgs eventData) {
                     // Look for the formatted message event, which has the following argument layout (as defined in the LoggingEventSource.
                     // FormattedMessage(LogLevel Level, int FactoryID, string LoggerName, string EventId, string FormattedMessage);
                     if (eventData.EventName == "FormattedMessage")
                         Console.WriteLine("Logger {0}: {1}", eventData.Payload[2], eventData.Payload[4]);
                 }
             }
             

    */
public final class LoggingEventSource
    :
    dotnet.System.Diagnostics.Tracing.EventSource
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_EventSource_LoggingEventSource_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_EventSource_LoggingEventSource_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
} // LoggingEventSource


// type: Microsoft.Extensions.Logging.EventSource.LoggingEventSource+Keywords
public struct LoggingEventSource_Keywords {
    // static field: System.Diagnostics.Tracing.EventKeywords FormattedMessage
    /**
    
            Turns on the 'FormatMessage' event when ILogger.Log() is called.  It gives the formatted string version of the information.
            

    */
    public static var FormattedMessage : dotnet.System.Diagnostics.Tracing.EventKeywords {
        get {
        let __return = dotnet.System.Diagnostics.Tracing.EventKeywords(val: Microsoft_Extensions_Logging_EventSource_LoggingEventSource_Keywords_get_FormattedMessage());
            return __return;
        }
    }
    // static field: System.Diagnostics.Tracing.EventKeywords JsonMessage
    /**
    
            Turns on the 'MessageJson' event when ILogger.Log() is called.   It gives  JSON representation of the Arguments.
            

    */
    public static var JsonMessage : dotnet.System.Diagnostics.Tracing.EventKeywords {
        get {
        let __return = dotnet.System.Diagnostics.Tracing.EventKeywords(val: Microsoft_Extensions_Logging_EventSource_LoggingEventSource_Keywords_get_JsonMessage());
            return __return;
        }
    }
    // static field: System.Diagnostics.Tracing.EventKeywords Message
    /**
    
            Turns on the 'Message' event when ILogger.Log() is called.   It gives the information in a programmatic (not formatted) way
            

    */
    public static var Message : dotnet.System.Diagnostics.Tracing.EventKeywords {
        get {
        let __return = dotnet.System.Diagnostics.Tracing.EventKeywords(val: Microsoft_Extensions_Logging_EventSource_LoggingEventSource_Keywords_get_Message());
            return __return;
        }
    }
    // static field: System.Diagnostics.Tracing.EventKeywords Meta
    /**
    
            Meta events are events about the LoggingEventSource itself (that is they did not come from ILogger
            

    */
    public static var Meta : dotnet.System.Diagnostics.Tracing.EventKeywords {
        get {
        let __return = dotnet.System.Diagnostics.Tracing.EventKeywords(val: Microsoft_Extensions_Logging_EventSource_LoggingEventSource_Keywords_get_Meta());
            return __return;
        }
    }
} // LoggingEventSource_Keywords


}




// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddEventSourceLogger(Microsoft.Extensions.Logging.ILoggingBuilder)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddEventSourceLogger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.EventSourceLoggerFactoryExtensions.AddEventSourceLogger(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

