// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.SignalR
extension Microsoft.AspNetCore.SignalR {
// type: Microsoft.AspNetCore.SignalR.HubException
    /**
    
            The exception thrown from a hub when an error occurs.
            

    */
open class HubException
    :
    dotnet.System.Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_HubException_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.SignalR.HubException.#ctor
    /**
    
            Initializes a new instance of the  class.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_HubException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.HubException.#ctor(System.String)
    /**
    
            Initializes a new instance of the  class
            with a specified error message.
            

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_HubException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:Microsoft.AspNetCore.SignalR.HubException.#ctor(System.String,System.Exception)
    /**
    
            Initializes a new instance of the  class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter innerException: The exception that is the cause of the current exception, or null if no inner exception is specified.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_HubException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:Microsoft.AspNetCore.SignalR.HubException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter info: The  that holds the serialized object data about the exception being thrown.
    - Parameter context: The  that contains contextual information about the source or destination.
    */
    public init(info : dotnet.System.Runtime.Serialization.SerializationInfo, context : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_HubException_ctor_0__2__SerializationInfo_StreamingContext(&__thrown, info.get_handle(), context.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // HubException


// type: Microsoft.AspNetCore.SignalR.IInvocationBinder
    /**
    
            Class used by s to get the (s) expected by the hub message being deserialized.
            

    */
open class IInvocationBinder
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_SignalR_IInvocationBinder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_IInvocationBinder_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Type GetReturnType(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.IInvocationBinder.GetReturnType(System.String)
    /**
    
            Gets the  the invocation represented by the  is expected to contain.
            

    - Parameter invocationId: The ID of the invocation being received.
    - Returns: The  the invocation is expected to contain.

    */
    open func GetReturnType(invocationId : dotnet.System.String) throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_IInvocationBinder_Type__GetReturnType_0__1__String(&__thrown, self.get_handle(), invocationId.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // System.Collections.Generic.IReadOnlyList<System.Type> GetParameterTypes(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.IInvocationBinder.GetParameterTypes(System.String)
    /**
    
            Gets the list of s the method represented by  takes as arguments.
            

    - Parameter methodName: The name of the method being called.
    - Returns: A list of s the method takes as arguments.

    */
    open func GetParameterTypes(methodName : dotnet.System.String) throws -> dotnet.System.Collections.Generic.IReadOnlyList_1<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_IInvocationBinder_System_Collections_Generic_IReadOnlyList_System_Type___GetParameterTypes_0__1__String(&__thrown, self.get_handle(), methodName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyList_1(hndl : __return);
        }
    }
    // System.Type GetStreamItemType(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.IInvocationBinder.GetStreamItemType(System.String)
    /**
    
            Gets the  the stream item is expected to contain.
            

    - Parameter streamId: The ID of the stream the stream item is a part of.
    - Returns: The  of the item the stream contains.

    */
    open func GetStreamItemType(streamId : dotnet.System.String) throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_IInvocationBinder_Type__GetStreamItemType_0__1__String(&__thrown, self.get_handle(), streamId.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
} // IInvocationBinder


// type: Microsoft.AspNetCore.SignalR.ISignalRBuilder
    /**
    
            A builder abstraction for configuring SignalR object instances.
            

    */
open class ISignalRBuilder
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_SignalR_ISignalRBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_ISignalRBuilder_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.IServiceCollection get_Services()
// docid: M:Microsoft.AspNetCore.SignalR.ISignalRBuilder.get_Services
    open func get_Services() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_ISignalRBuilder_IServiceCollection__get_Services_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
} // ISignalRBuilder


}
// Microsoft.AspNetCore.SignalR.Protocol
extension Microsoft.AspNetCore.SignalR.Protocol_ {
// type: Microsoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage
    /**
    
            The  represents a cancellation of a streaming method.
            

    */
open class CancelInvocationMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_CancelInvocationMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CancelInvocationMessage.#ctor(System.String)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The ID of the hub method invocation being canceled.
    */
    public init(invocationId : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_CancelInvocationMessage_ctor_0__1__String(&__thrown, invocationId.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // CancelInvocationMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.CloseMessage
    /**
    
            The message sent when closing a connection.
            

    */
open class CloseMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: Microsoft.AspNetCore.SignalR.Protocol.CloseMessage Empty
    /**
    
            An empty close message with no error and  set to .
            

    */
    open class var Empty : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CloseMessage {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CloseMessage(hndl: Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_get_Empty());
            return __return;
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.#ctor(System.String)
    /**
    
            Initializes a new instance of the  class with an optional error message and  set to .
            

    - Parameter error: An optional error message.
    */
    public init(error : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_ctor_0__1__String(&__thrown, error?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, bool)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.#ctor(System.String,System.Boolean)
    /**
    
            Initializes a new instance of the  class with an optional error message and a  indicating whether or not a client with
            automatic reconnects enabled should attempt to reconnect upon receiving the message.
            

    - Parameter error: An optional error message.
    - Parameter allowReconnect: 
            , if client with automatic reconnects enabled should attempt to reconnect after receiving the ;
            , if the client should not try to reconnect whether or not automatic reconnects are enabled.
            
    */
    public init(error : Optional<dotnet.System.String>, allowReconnect : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_ctor_0__2__String_bool(&__thrown, error?.get_handle() ?? nil, Swift.Int32(allowReconnect ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Error()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.get_Error
    open func get_Error() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_String__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_AllowReconnect()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CloseMessage.get_AllowReconnect
    open func get_AllowReconnect() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CloseMessage_bool__get_AllowReconnect_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    
            If , clients with automatic reconnects enabled should not attempt to automatically reconnect after receiving the .
            

    */
    open var AllowReconnect : Bool {
        get {
            return try! get_AllowReconnect();
        }
    }
    /**
    
            Gets the optional error message.
            

    */
    open var Error : Optional<dotnet.System.String> {
        get {
            return try! get_Error();
        }
    }
} // CloseMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage
    /**
    
            Represents an invocation that has completed. If there is an error then the invocation didn't complete successfully.
            

    */
open class CompletionMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.String, System.Object, bool)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.#ctor(System.String,System.String,System.Object,System.Boolean)
    /**
    
            Constructs a .
            

    - Parameter invocationId: The ID of the invocation that has completed.
    - Parameter error: An optional error if the invocation failed.
    - Parameter result: An optional result if the invocation returns a result.
    - Parameter hasResult: Specifies whether the completion contains a result.
    */
    public init(invocationId : dotnet.System.String, error : Optional<dotnet.System.String>, result : Optional<dotnet.System.Object>, hasResult : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_ctor_0__4__String_String_Object_bool(&__thrown, invocationId.get_handle(), error?.get_handle() ?? nil, result?.get_handle() ?? nil, Swift.Int32(hasResult ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage WithError(System.String, System.String)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithError(System.String,System.String)
    /**
    
            Constructs a  with an error.
            

    - Parameter invocationId: The ID of the invocation that is being completed.
    - Parameter error: The error that occurred during the invocation.
    - Returns: The constructed .

    */
    open class func WithError(invocationId : dotnet.System.String, error : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_CompletionMessage__WithError_0__2__String_String(&__thrown, invocationId.get_handle(), error?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage WithResult(System.String, System.Object)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.WithResult(System.String,System.Object)
    /**
    
            Constructs a  with a result.
            

    - Parameter invocationId: The ID of the invocation that is being completed.
    - Parameter payload: The result from the invocation.
    - Returns: The constructed .

    */
    open class func WithResult(invocationId : dotnet.System.String, payload : Optional<dotnet.System.Object>) throws -> aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_CompletionMessage__WithResult_0__2__String_Object(&__thrown, invocationId.get_handle(), payload?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage Empty(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.Empty(System.String)
    /**
    
            Constructs a  without an error or result.
            This means the invocation was successful but there is no return value.
            

    - Parameter invocationId: The ID of the invocation that is being completed.
    - Returns: The constructed .

    */
    open class func Empty(invocationId : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_CompletionMessage__Empty_0__1__String(&__thrown, invocationId.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.CompletionMessage(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Error()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.get_Error
    open func get_Error() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_String__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Object get_Result()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.get_Result
    open func get_Result() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_Object__get_Result_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_HasResult()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.CompletionMessage.get_HasResult
    open func get_HasResult() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_CompletionMessage_bool__get_HasResult_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    
            Optional error message if the invocation wasn't completed successfully. This must be null if there is a result.
            

    */
    open var Error : Optional<dotnet.System.String> {
        get {
            return try! get_Error();
        }
    }
    /**
    
            Specifies whether the completion contains a result.
            

    */
    open var HasResult : Bool {
        get {
            return try! get_HasResult();
        }
    }
    /**
    
            Optional result from the invocation. This must be null if there is an error.
            This can also be null if there wasn't a result from the method invocation.
            

    */
    open var Result : Optional<dotnet.System.Object> {
        get {
            return try! get_Result();
        }
    }
} // CompletionMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol
public struct HandshakeProtocol {
// TODO COPE (returns byreflike): System.ReadOnlySpan<System.Byte> GetSuccessfulHandshake(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol)
    // void WriteRequestMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage, System.Buffers.IBufferWriter<System.Byte>)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteRequestMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage,System.Buffers.IBufferWriter{System.Byte})
    /**
    
            Writes the serialized representation of a  to the specified writer.
            

    - Parameter requestMessage: The message to write.
    - Parameter output: The output writer.
    */
    public static func WriteRequestMessage(requestMessage : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeRequestMessage, output : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_SignalR_Protocol_HandshakeProtocol_void__WriteRequestMessage_0__2__HandshakeRequestMessage_System_Buffers_IBufferWriter_u8_(&__thrown, requestMessage.get_handle(), output.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void WriteResponseMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage, System.Buffers.IBufferWriter<System.Byte>)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.WriteResponseMessage(Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage,System.Buffers.IBufferWriter{System.Byte})
    /**
    
            Writes the serialized representation of a  to the specified writer.
            

    - Parameter responseMessage: The message to write.
    - Parameter output: The output writer.
    */
    public static func WriteResponseMessage(responseMessage : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeResponseMessage, output : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_SignalR_Protocol_HandshakeProtocol_void__WriteResponseMessage_0__2__HandshakeResponseMessage_System_Buffers_IBufferWriter_u8_(&__thrown, responseMessage.get_handle(), output.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryParseResponseMessage(ref System.Buffers.ReadOnlySequence<System.Byte>, ref Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseResponseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage@)
    /**
    
            Creates a new  from the specified serialized representation.
            

    - Parameter buffer: The serialized representation of the message.
    - Parameter responseMessage: When this method returns, contains the parsed message.
    - Returns: A value that is true if the  was successfully parsed; otherwise, false.

    */
    public static func TryParseResponseMessage(buffer : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, responseMessage : inout Optional<aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeResponseMessage>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_buffer = (buffer != nil) ? (buffer!.get_handle()) : nil;
            var _tmp_out_responseMessage = (responseMessage != nil) ? (responseMessage!.get_handle()) : nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HandshakeProtocol_bool__TryParseResponseMessage_0__2__refSystem_Buffers_ReadOnlySequence_u8__outHandshakeResponseMessage(&__thrown, &_tmp_ref_buffer, &_tmp_out_responseMessage);
        let __h__tmp2_buffer = _tmp_ref_buffer;
        let _tmp2_buffer = (__h__tmp2_buffer != nil) ? dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>(hndl: __h__tmp2_buffer!) : nil;
            buffer = _tmp2_buffer;
        let __h__tmp2_responseMessage = _tmp_out_responseMessage;
        let _tmp2_responseMessage = (__h__tmp2_responseMessage != nil) ? aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeResponseMessage(hndl: __h__tmp2_responseMessage!) : nil;
            responseMessage = _tmp2_responseMessage;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryParseRequestMessage(ref System.Buffers.ReadOnlySequence<System.Byte>, ref Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeProtocol.TryParseRequestMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage@)
    /**
    
            Creates a new  from the specified serialized representation.
            

    - Parameter buffer: The serialized representation of the message.
    - Parameter requestMessage: When this method returns, contains the parsed message.
    - Returns: A value that is true if the  was successfully parsed; otherwise, false.

    */
    public static func TryParseRequestMessage(buffer : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, requestMessage : inout Optional<aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeRequestMessage>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_buffer = (buffer != nil) ? (buffer!.get_handle()) : nil;
            var _tmp_out_requestMessage = (requestMessage != nil) ? (requestMessage!.get_handle()) : nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HandshakeProtocol_bool__TryParseRequestMessage_0__2__refSystem_Buffers_ReadOnlySequence_u8__outHandshakeRequestMessage(&__thrown, &_tmp_ref_buffer, &_tmp_out_requestMessage);
        let __h__tmp2_buffer = _tmp_ref_buffer;
        let _tmp2_buffer = (__h__tmp2_buffer != nil) ? dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>(hndl: __h__tmp2_buffer!) : nil;
            buffer = _tmp2_buffer;
        let __h__tmp2_requestMessage = _tmp_out_requestMessage;
        let _tmp2_requestMessage = (__h__tmp2_requestMessage != nil) ? aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeRequestMessage(hndl: __h__tmp2_requestMessage!) : nil;
            requestMessage = _tmp2_requestMessage;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // HandshakeProtocol


// type: Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage
    /**
    
            A handshake request message.
            

    */
open class HandshakeRequestMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_HandshakeRequestMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Int32)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.#ctor(System.String,System.Int32)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter protocol: The requested protocol name.
    - Parameter version: The requested protocol version.
    */
    public init(protocol_ : dotnet.System.String, version : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_HandshakeRequestMessage_ctor_0__2__String_i32(&__thrown, protocol_.get_handle(), version);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Protocol()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.get_Protocol
    open func get_Protocol() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HandshakeRequestMessage_String__get_Protocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Version()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeRequestMessage.get_Version
    open func get_Version() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HandshakeRequestMessage_i32__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    
            Gets the requested protocol name.
            

    */
    open var Protocol_ : dotnet.System.String {
        get {
            return try! get_Protocol();
        }
    }
    /**
    
            Gets the requested protocol version.
            

    */
    open var Version : Swift.Int32 {
        get {
            return try! get_Version();
        }
    }
} // HandshakeRequestMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage
    /**
    
            A handshake response message.
            

    */
open class HandshakeResponseMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_HandshakeResponseMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage Empty
    /**
    
            An empty response message with no error.
            

    */
    open class var Empty : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeResponseMessage {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HandshakeResponseMessage(hndl: Microsoft_AspNetCore_SignalR_Protocol_HandshakeResponseMessage_get_Empty());
            return __return;
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.#ctor(System.String)
    /**
    
            Initializes a new instance of the  class.
            An error response does need a minor version. Since the handshake has failed, any extra data will be ignored.
            

    - Parameter error: Error encountered by the server, indicating why the handshake has failed.
    */
    public init(error : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_HandshakeResponseMessage_ctor_0__1__String(&__thrown, error?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Error()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HandshakeResponseMessage.get_Error
    open func get_Error() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HandshakeResponseMessage_String__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the optional error message.
            

    */
    open var Error : Optional<dotnet.System.String> {
        get {
            return try! get_Error();
        }
    }
} // HandshakeResponseMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HubInvocationMessage
    /**
    
            A base class for hub messages related to a specific invocation.
            

    */
open class HubInvocationMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_HubInvocationMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Collections.Generic.IDictionary<System.String,System.String> get_Headers()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.get_Headers
    open func get_Headers() throws -> Optional<dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.String,dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubInvocationMessage_System_Collections_Generic_IDictionary_string_string___get_Headers_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IDictionary_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Headers(System.Collections.Generic.IDictionary<System.String,System.String>)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.set_Headers(System.Collections.Generic.IDictionary{System.String,System.String})
    open func set_Headers(value : Optional<dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.String,dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_SignalR_Protocol_HubInvocationMessage_void__set_Headers_0__1__System_Collections_Generic_IDictionary_string_string_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_InvocationId()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubInvocationMessage.get_InvocationId
    open func get_InvocationId() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubInvocationMessage_String__get_InvocationId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets or sets a name/value collection of headers.
            

    */
    open var Headers : Optional<dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.String,dotnet.System.String>> {
        get {
            return try! get_Headers();
        }
        set(v) {
            return try! set_Headers(value: v!);
        }
    }
    /**
    
            Gets the invocation ID.
            

    */
    open var InvocationId : Optional<dotnet.System.String> {
        get {
            return try! get_InvocationId();
        }
    }
} // HubInvocationMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HubMessage
    /**
    
            A base class for hub messages.
            

    */
open class HubMessage
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_HubMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // HubMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage
    /**
    
            A base class for hub messages representing an invocation.
            

    */
open class HubMethodInvocationMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_HubMethodInvocationMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.String get_Target()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.get_Target
    open func get_Target() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubMethodInvocationMessage_String__get_Target_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Object[] get_Arguments()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.get_Arguments
    open func get_Arguments() throws -> dotnet.System_Arr<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubMethodInvocationMessage_ObjectArray__get_Arguments_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Object>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String[] get_StreamIds()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubMethodInvocationMessage.get_StreamIds
    open func get_StreamIds() throws -> Optional<dotnet.System_Arr<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubMethodInvocationMessage_StringArray__get_StreamIds_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<dotnet.System.String>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the target method arguments.
            

    */
    open var Arguments : dotnet.System_Arr<dotnet.System.Object> {
        get {
            return try! get_Arguments();
        }
    }
    /**
    
            The target methods stream IDs.
            

    */
    open var StreamIds : Optional<dotnet.System_Arr<dotnet.System.String>> {
        get {
            return try! get_StreamIds();
        }
    }
    /**
    
            Gets the target method name.
            

    */
    open var Target : dotnet.System.String {
        get {
            return try! get_Target();
        }
    }
} // HubMethodInvocationMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.HubProtocolConstants
public struct HubProtocolConstants {
    // static field: System.Int32 InvocationMessageType
    /**
    
            Represents the invocation message type.
            

    */
    public static var InvocationMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_InvocationMessageType();
            return __return;
        }
    }
    // static field: System.Int32 StreamItemMessageType
    /**
    
            Represents the stream item message type.
            

    */
    public static var StreamItemMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_StreamItemMessageType();
            return __return;
        }
    }
    // static field: System.Int32 CompletionMessageType
    /**
    
            Represents the completion message type.
            

    */
    public static var CompletionMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_CompletionMessageType();
            return __return;
        }
    }
    // static field: System.Int32 StreamInvocationMessageType
    /**
    
            Represents the stream invocation message type.
            

    */
    public static var StreamInvocationMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_StreamInvocationMessageType();
            return __return;
        }
    }
    // static field: System.Int32 CancelInvocationMessageType
    /**
    
            Represents the cancel invocation message type.
            

    */
    public static var CancelInvocationMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_CancelInvocationMessageType();
            return __return;
        }
    }
    // static field: System.Int32 PingMessageType
    /**
    
            Represents the ping message type.
            

    */
    public static var PingMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_PingMessageType();
            return __return;
        }
    }
    // static field: System.Int32 CloseMessageType
    /**
    
            Represents the close message type.
            

    */
    public static var CloseMessageType : Swift.Int32 {
        get {
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolConstants_get_CloseMessageType();
            return __return;
        }
    }
} // HubProtocolConstants


// type: Microsoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions
public struct HubProtocolExtensions {
    // System.Byte[] GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol, Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.HubProtocolExtensions.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol,Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
    /**
    
            Converts the specified  to its serialized representation.
            

    - Parameter hubProtocol: The hub protocol.
    - Parameter message: The message to convert to bytes.
    - Returns: The serialized representation of the specified message.

    */
    public static func GetMessageBytes(hubProtocol : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.IHubProtocol, message : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_HubProtocolExtensions_u8Array__GetMessageBytes_0__2__IHubProtocol_HubMessage(&__thrown, hubProtocol.get_handle(), message.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // HubProtocolExtensions


// type: Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol
    /**
    
            A protocol abstraction for communicating with SignalR hubs.
            

    */
open class IHubProtocol
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // bool TryParseMessage(ref System.Buffers.ReadOnlySequence<System.Byte>, Microsoft.AspNetCore.SignalR.IInvocationBinder, ref Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.TryParseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.AspNetCore.SignalR.IInvocationBinder,Microsoft.AspNetCore.SignalR.Protocol.HubMessage@)
    /**
    
            Creates a new  from the specified serialized representation, and using the specified binder.
            

    - Parameter input: The serialized representation of the message.
    - Parameter binder: The binder used to parse the message.
    - Parameter message: When this method returns true, contains the parsed message.
    - Returns: A value that is true if the  was successfully parsed; otherwise, false.

    */
    open func TryParseMessage(input : inout Optional<dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>>, binder : aspnetcore.Microsoft.AspNetCore.SignalR.IInvocationBinder, message : inout Optional<aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage>) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_ref_input = (input != nil) ? (input!.get_handle()) : nil;
            var _tmp_out_message = (message != nil) ? (message!.get_handle()) : nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_bool__TryParseMessage_0__3__refSystem_Buffers_ReadOnlySequence_u8__IInvocationBinder_outHubMessage(&__thrown, self.get_handle(), &_tmp_ref_input, binder.get_handle(), &_tmp_out_message);
        let __h__tmp2_input = _tmp_ref_input;
        let _tmp2_input = (__h__tmp2_input != nil) ? dotnet.System.Buffers.ReadOnlySequence_1<Swift.UInt8>(hndl: __h__tmp2_input!) : nil;
            input = _tmp2_input;
        let __h__tmp2_message = _tmp_out_message;
        let _tmp2_message = (__h__tmp2_message != nil) ? aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage(hndl: __h__tmp2_message!) : nil;
            message = _tmp2_message;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage, System.Buffers.IBufferWriter<System.Byte>)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.WriteMessage(Microsoft.AspNetCore.SignalR.Protocol.HubMessage,System.Buffers.IBufferWriter{System.Byte})
    /**
    
            Writes the specified  to a writer.
            

    - Parameter message: The message to write.
    - Parameter output: The output writer.
    */
    open func WriteMessage(message : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage, output : dotnet.System.Buffers.IBufferWriter_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_void__WriteMessage_0__2__HubMessage_System_Buffers_IBufferWriter_u8_(&__thrown, self.get_handle(), message.get_handle(), output.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.ReadOnlyMemory<System.Byte> GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
    /**
    
            Converts the specified  to its serialized representation.
            

    - Parameter message: The message to convert.
    - Returns: The serialized representation of the message.

    */
    open func GetMessageBytes(message : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage) throws -> dotnet.System.ReadOnlyMemory_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_System_ReadOnlyMemory_u8___GetMessageBytes_0__1__HubMessage(&__thrown, self.get_handle(), message.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
    // bool IsVersionSupported(System.Int32)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.IsVersionSupported(System.Int32)
    /**
    
            Gets a value indicating whether the protocol supports the specified version.
            

    - Parameter version: The version.
    - Returns: A value indicating whether the protocol supports the specified version.

    */
    open func IsVersionSupported(version : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_bool__IsVersionSupported_0__1__i32(&__thrown, self.get_handle(), version);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Version()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.get_Version
    open func get_Version() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_i32__get_Version_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Connections.TransferFormat get_TransferFormat()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol.get_TransferFormat
    open func get_TransferFormat() throws -> aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol_TransferFormat__get_TransferFormat_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.TransferFormat(val: __return);
        }
    }
} // IHubProtocol


// type: Microsoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage
    /**
    
            Represents a failure to bind arguments for an invocation. This does not represent an actual
            message that is sent on the wire, it is returned by 
            to indicate that a binding failure occurred when parsing an invocation. The invocation ID is associated
            so that the error can be sent back to the client, associated with the appropriate invocation ID.
            

    */
open class InvocationBindingFailureMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_InvocationBindingFailureMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.String, System.Runtime.ExceptionServices.ExceptionDispatchInfo)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.#ctor(System.String,System.String,System.Runtime.ExceptionServices.ExceptionDispatchInfo)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The invocation ID.
    - Parameter target: The target method name.
    - Parameter bindingFailure: The exception thrown during binding.
    */
    public init(invocationId : Optional<dotnet.System.String>, target : dotnet.System.String, bindingFailure : dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_InvocationBindingFailureMessage_ctor_0__3__String_String_ExceptionDispatchInfo(&__thrown, invocationId?.get_handle() ?? nil, target.get_handle(), bindingFailure.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Runtime.ExceptionServices.ExceptionDispatchInfo get_BindingFailure()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.get_BindingFailure
    open func get_BindingFailure() throws -> dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_InvocationBindingFailureMessage_ExceptionDispatchInfo__get_BindingFailure_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Target()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationBindingFailureMessage.get_Target
    open func get_Target() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_InvocationBindingFailureMessage_String__get_Target_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    
            Gets the exception thrown during binding.
            

    */
    open var BindingFailure : dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo {
        get {
            return try! get_BindingFailure();
        }
    }
    /**
    
            Gets the target method name.
            

    */
    open var Target : dotnet.System.String {
        get {
            return try! get_Target();
        }
    }
} // InvocationBindingFailureMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage
    /**
    
            A hub message representing a non-streaming invocation.
            

    */
open class InvocationMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMethodInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_InvocationMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Object[])
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.#ctor(System.String,System.Object[])
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter target: The target method name.
    - Parameter arguments: The target method arguments.
    */
    public init(target : dotnet.System.String, arguments : dotnet.System_Arr<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_InvocationMessage_ctor_0__2__String_ObjectArray(&__thrown, target.get_handle(), arguments.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.Object[])
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.#ctor(System.String,System.String,System.Object[])
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The invocation ID.
    - Parameter target: The target method name.
    - Parameter arguments: The target method arguments.
    */
    public init(invocationId : Optional<dotnet.System.String>, target : dotnet.System.String, arguments : dotnet.System_Arr<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_InvocationMessage_ctor_0__3__String_String_ObjectArray(&__thrown, invocationId?.get_handle() ?? nil, target.get_handle(), arguments.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.Object[], System.String[])
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.#ctor(System.String,System.String,System.Object[],System.String[])
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The invocation ID.
    - Parameter target: The target method name.
    - Parameter arguments: The target method arguments.
    - Parameter streamIds: The target methods stream IDs.
    */
    public init(invocationId : Optional<dotnet.System.String>, target : dotnet.System.String, arguments : dotnet.System_Arr<dotnet.System.Object>, streamIds : Optional<dotnet.System_Arr<dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_InvocationMessage_ctor_0__4__String_String_ObjectArray_StringArray(&__thrown, invocationId?.get_handle() ?? nil, target.get_handle(), arguments.get_handle(), (streamIds?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.InvocationMessage.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_InvocationMessage_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // InvocationMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.PingMessage
    /**
    
            A keep-alive message to let the other side of the connection know that the connection is still alive.
            

    */
open class PingMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_PingMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: Microsoft.AspNetCore.SignalR.Protocol.PingMessage Instance
    /**
    
            A static instance of the PingMessage to remove unneeded allocations.
            

    */
    open class var Instance : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.PingMessage {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.PingMessage(hndl: Microsoft_AspNetCore_SignalR_Protocol_PingMessage_get_Instance());
            return __return;
        }
    }
} // PingMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage
    /**
    
            Represents a failure to bind arguments for a StreamDataMessage. This does not represent an actual
            message that is sent on the wire, it is returned by 
            to indicate that a binding failure occurred when parsing a StreamDataMessage. The stream ID is associated
            so that the error can be sent to the relevant hub method.
            

    */
open class StreamBindingFailureMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_StreamBindingFailureMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Runtime.ExceptionServices.ExceptionDispatchInfo)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.#ctor(System.String,System.Runtime.ExceptionServices.ExceptionDispatchInfo)
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter id: The stream ID.
    - Parameter bindingFailure: The exception thrown during binding.
    */
    public init(id : dotnet.System.String, bindingFailure : dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_StreamBindingFailureMessage_ctor_0__2__String_ExceptionDispatchInfo(&__thrown, id.get_handle(), bindingFailure.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Id()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.get_Id
    open func get_Id() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_StreamBindingFailureMessage_String__get_Id_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Runtime.ExceptionServices.ExceptionDispatchInfo get_BindingFailure()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamBindingFailureMessage.get_BindingFailure
    open func get_BindingFailure() throws -> dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_StreamBindingFailureMessage_ExceptionDispatchInfo__get_BindingFailure_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo(hndl : __return);
        }
    }
    /**
    
            Gets the exception thrown during binding.
            

    */
    open var BindingFailure : dotnet.System.Runtime.ExceptionServices.ExceptionDispatchInfo {
        get {
            return try! get_BindingFailure();
        }
    }
    /**
    
            Gets the id of the relevant stream
            

    */
    open var Id : dotnet.System.String {
        get {
            return try! get_Id();
        }
    }
} // StreamBindingFailureMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage
    /**
    
            A hub message representing a streaming invocation.
            

    */
open class StreamInvocationMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMethodInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_StreamInvocationMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.String, System.Object[])
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.#ctor(System.String,System.String,System.Object[])
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The invocation ID.
    - Parameter target: The target method name.
    - Parameter arguments: The target method arguments.
    */
    public init(invocationId : dotnet.System.String, target : dotnet.System.String, arguments : dotnet.System_Arr<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_StreamInvocationMessage_ctor_0__3__String_String_ObjectArray(&__thrown, invocationId.get_handle(), target.get_handle(), arguments.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.Object[], System.String[])
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.#ctor(System.String,System.String,System.Object[],System.String[])
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter invocationId: The invocation ID.
    - Parameter target: The target method name.
    - Parameter arguments: The target method arguments.
    - Parameter streamIds: The target methods stream IDs.
    */
    public init(invocationId : dotnet.System.String, target : dotnet.System.String, arguments : dotnet.System_Arr<dotnet.System.Object>, streamIds : Optional<dotnet.System_Arr<dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_StreamInvocationMessage_ctor_0__4__String_String_ObjectArray_StringArray(&__thrown, invocationId.get_handle(), target.get_handle(), arguments.get_handle(), (streamIds?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamInvocationMessage.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_StreamInvocationMessage_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // StreamInvocationMessage


// type: Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage
    /**
    
            Represents a single item of an active stream.
            

    */
open class StreamItemMessage
    :
    aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubInvocationMessage
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_SignalR_Protocol_StreamItemMessage_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Object)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.#ctor(System.String,System.Object)
    /**
    
            Constructs a .
            

    - Parameter invocationId: The ID of the stream.
    - Parameter item: An item from the stream.
    */
    public init(invocationId : dotnet.System.String, item : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_SignalR_Protocol_StreamItemMessage_ctor_0__2__String_Object(&__thrown, invocationId.get_handle(), item?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.ToString
    /**
    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_StreamItemMessage_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Object get_Item()
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.get_Item
    open func get_Item() throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_SignalR_Protocol_StreamItemMessage_Object__get_Item_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Item(System.Object)
// docid: M:Microsoft.AspNetCore.SignalR.Protocol.StreamItemMessage.set_Item(System.Object)
    open func set_Item(value : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_SignalR_Protocol_StreamItemMessage_void__set_Item_0__1__Object(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The single item from a stream.
            

    */
    open var Item : Optional<dotnet.System.Object> {
        get {
            return try! get_Item();
        }
        set(v) {
            return try! set_Item(value: v!);
        }
    }
} // StreamItemMessage


}




public protocol Microsoft_AspNetCore_SignalR_IInvocationBinder
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_SignalR_ISignalRBuilder
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD System.Byte[] GetMessageBytes(Microsoft.AspNetCore.SignalR.Protocol.IHubProtocol, Microsoft.AspNetCore.SignalR.Protocol.HubMessage)
extension Microsoft_AspNetCore_SignalR_Protocol_IHubProtocol {
    public func GetMessageBytes(message : aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubMessage) throws -> dotnet.System_Arr<Swift.UInt8> {
        return try aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.HubProtocolExtensions.GetMessageBytes(hubProtocol: aspnetcore.Microsoft.AspNetCore.SignalR.Protocol_.IHubProtocol(hndl: __copy_handle(self.get_handle())), message: message);
    }
}

