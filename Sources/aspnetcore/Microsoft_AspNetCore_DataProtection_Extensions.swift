// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.DataProtection
extension Microsoft.AspNetCore.DataProtection {
// type: Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions
public struct DataProtectionAdvancedExtensions {
    // System.Byte[] Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.Byte[], System.TimeSpan)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector,System.Byte[],System.TimeSpan)
    /**
    
            Cryptographically protects a piece of plaintext data, expiring the data after
            the specified amount of time has elapsed.
            

    - Parameter protector: The protector to use.
    - Parameter plaintext: The plaintext data to protect.
    - Parameter lifetime: The amount of time after which the payload should no longer be unprotectable.
    - Returns: The protected form of the plaintext data.

    */
    public static func Protect(protector : aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, plaintext : dotnet.System_Arr<Swift.UInt8>, lifetime : dotnet.System.TimeSpan) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionAdvancedExtensions_u8Array__Protect_0__3__ITimeLimitedDataProtector_u8Array_TimeSpan(&__thrown, protector.get_handle(), plaintext.get_handle(), lifetime.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector,System.String,System.DateTimeOffset)
    /**
    
            Cryptographically protects a piece of plaintext data, expiring the data at
            the chosen time.
            

    - Parameter protector: The protector to use.
    - Parameter plaintext: The plaintext data to protect.
    - Parameter expiration: The time when this payload should expire.
    - Returns: The protected form of the plaintext data.

    */
    public static func Protect(protector : aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, plaintext : dotnet.System.String, expiration : dotnet.System.DateTimeOffset) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionAdvancedExtensions_String__Protect_0__3__ITimeLimitedDataProtector_String_DateTimeOffset(&__thrown, protector.get_handle(), plaintext.get_handle(), expiration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, System.TimeSpan)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector,System.String,System.TimeSpan)
    /**
    
            Cryptographically protects a piece of plaintext data, expiring the data after
            the specified amount of time has elapsed.
            

    - Parameter protector: The protector to use.
    - Parameter plaintext: The plaintext data to protect.
    - Parameter lifetime: The amount of time after which the payload should no longer be unprotectable.
    - Returns: The protected form of the plaintext data.

    */
    public static func Protect(protector : aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, plaintext : dotnet.System.String, lifetime : dotnet.System.TimeSpan) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionAdvancedExtensions_String__Protect_0__3__ITimeLimitedDataProtector_String_TimeSpan(&__thrown, protector.get_handle(), plaintext.get_handle(), lifetime.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector ToTimeLimitedDataProtector(Microsoft.AspNetCore.DataProtection.IDataProtector)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.ToTimeLimitedDataProtector(Microsoft.AspNetCore.DataProtection.IDataProtector)
    /**
    
            Converts an  into an 
            so that payloads can be protected with a finite lifetime.
            

    - Parameter protector: The  to convert to a time-limited protector.
    - Returns: An .

    */
    public static func ToTimeLimitedDataProtector(protector : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtector) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionAdvancedExtensions_ITimeLimitedDataProtector__ToTimeLimitedDataProtector_0__1__IDataProtector(&__thrown, protector.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl : __return);
        }
    }
    // System.String Unprotect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, ref System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Unprotect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector,System.String,System.DateTimeOffset@)
    /**
    
            Cryptographically unprotects a piece of protected data.
            

    - Parameter protector: The protector to use.
    - Parameter protectedData: The protected data to unprotect.
    - Parameter expiration: An 'out' parameter which upon a successful unprotect
            operation receives the expiration date of the payload.
    - Returns: The plaintext form of the protected data.

    */
    public static func Unprotect(protector : aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, protectedData : dotnet.System.String, expiration : inout dotnet.System.DateTimeOffset) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
            var _tmp_out_expiration = expiration.get_handle();
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionAdvancedExtensions_String__Unprotect_0__3__ITimeLimitedDataProtector_String_outDateTimeOffset(&__thrown, protector.get_handle(), protectedData.get_handle(), &_tmp_out_expiration);
        let _tmp2_expiration = dotnet.System.DateTimeOffset(hndl: _tmp_out_expiration);
            expiration = _tmp2_expiration;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // DataProtectionAdvancedExtensions


// type: Microsoft.AspNetCore.DataProtection.DataProtectionProvider
public struct DataProtectionProvider {
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.String)
    /**
    
            Creates a  that store keys in a location based on
            the platform and operating system.
            

    - Parameter applicationName: An identifier that uniquely discriminates this application from all other
            applications on the machine.
    */
    public static func Create(applicationName : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__1__String(&__thrown, applicationName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.IO.DirectoryInfo)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo)
    /**
    
            Creates an  given a location at which to store keys.
            

    - Parameter keyDirectory: The  in which keys should be stored. This may
            represent a directory on a local disk or a UNC share.
    */
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__1__DirectoryInfo(&__thrown, keyDirectory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.IO.DirectoryInfo, System.Action<Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo,System.Action{Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder})
    /**
    
            Creates an  given a location at which to store keys and an
            optional configuration callback.
            

    - Parameter keyDirectory: The  in which keys should be stored. This may
            represent a directory on a local disk or a UNC share.
    - Parameter setupAction: An optional callback which provides further configuration of the data protection
            system. See  for more information.
    */
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo, setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__2__DirectoryInfo_System_Action_Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder_(&__thrown, keyDirectory.get_handle(), setupAction.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // delegate closure overload
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo, setupAction : @escaping (aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>(setupAction);
        return try Create(keyDirectory: keyDirectory, setupAction: del_setupAction);
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.String, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.String,System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    
            Creates a  that store keys in a location based on
            the platform and operating system and uses the given  to encrypt the keys.
            

    - Parameter applicationName: An identifier that uniquely discriminates this application from all other
            applications on the machine.
    - Parameter certificate: The  to be used for encryption.
    */
    public static func Create(applicationName : dotnet.System.String, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__2__String_X509Certificate2(&__thrown, applicationName.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.IO.DirectoryInfo, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo,System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    
            Creates an  given a location at which to store keys
            and a  used to encrypt the keys.
            

    - Parameter keyDirectory: The  in which keys should be stored. This may
            represent a directory on a local disk or a UNC share.
    - Parameter certificate: The  to be used for encryption.
    */
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__2__DirectoryInfo_X509Certificate2(&__thrown, keyDirectory.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionProvider Create(System.IO.DirectoryInfo, System.Action<Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionProvider.Create(System.IO.DirectoryInfo,System.Action{Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder},System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    
            Creates an  given a location at which to store keys, an
            optional configuration callback and a  used to encrypt the keys.
            

    - Parameter keyDirectory: The  in which keys should be stored. This may
            represent a directory on a local disk or a UNC share.
    - Parameter setupAction: An optional callback which provides further configuration of the data protection
            system. See  for more information.
    - Parameter certificate: The  to be used for encryption.
    */
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo, setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionProvider_IDataProtectionProvider__Create_0__3__DirectoryInfo_System_Action_Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder__X509Certificate2(&__thrown, keyDirectory.get_handle(), setupAction.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider(hndl : __return);
        }
    }
    // delegate closure overload
    public static func Create(keyDirectory : dotnet.System.IO.DirectoryInfo, setupAction : @escaping (aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> Void, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder>(setupAction);
        return try Create(keyDirectory: keyDirectory, setupAction: del_setupAction, certificate: certificate);
    }
} // DataProtectionProvider


// type: Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector
    /**
    
            An interface that can provide data protection services where payloads have
            a finite lifetime.
            

    */
open class ITimeLimitedDataProtector
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector,
    Microsoft_AspNetCore_DataProtection_IDataProtector
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector CreateProtector(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.CreateProtector(System.String)
    /**
    
            Creates an  given a purpose.
            

    - Parameter purpose: 
            The purpose to be assigned to the newly-created .
            
    - Returns: An  tied to the provided purpose.

    */
    open func CreateProtector(purpose : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector_ITimeLimitedDataProtector__CreateProtector_0__1__String(&__thrown, self.get_handle(), purpose.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl : __return);
        }
    }
    // System.Byte[] Protect(System.Byte[], System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.Protect(System.Byte[],System.DateTimeOffset)
    /**
    
            Cryptographically protects a piece of plaintext data, expiring the data at
            the chosen time.
            

    - Parameter plaintext: The plaintext data to protect.
    - Parameter expiration: The time when this payload should expire.
    - Returns: The protected form of the plaintext data.

    */
    open func Protect(plaintext : dotnet.System_Arr<Swift.UInt8>, expiration : dotnet.System.DateTimeOffset) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector_u8Array__Protect_0__2__u8Array_DateTimeOffset(&__thrown, self.get_handle(), plaintext.get_handle(), expiration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Unprotect(System.Byte[], ref System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector.Unprotect(System.Byte[],System.DateTimeOffset@)
    /**
    
            Cryptographically unprotects a piece of protected data.
            

    - Parameter protectedData: The protected data to unprotect.
    - Parameter expiration: An 'out' parameter which upon a successful unprotect
            operation receives the expiration date of the payload.
    - Returns: The plaintext form of the protected data.

    */
    open func Unprotect(protectedData : dotnet.System_Arr<Swift.UInt8>, expiration : inout dotnet.System.DateTimeOffset) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_expiration = expiration.get_handle();
        let __return = Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector_u8Array__Unprotect_0__2__u8Array_outDateTimeOffset(&__thrown, self.get_handle(), protectedData.get_handle(), &_tmp_out_expiration);
        let _tmp2_expiration = dotnet.System.DateTimeOffset(hndl: _tmp_out_expiration);
            expiration = _tmp2_expiration;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // ITimeLimitedDataProtector


}



public protocol Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector
    :
    Microsoft_AspNetCore_DataProtection_IDataProtector
{
}

// EXTENSION METHOD System.Byte[] Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.Byte[], System.TimeSpan)
extension Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector {
    public func Protect(plaintext : dotnet.System_Arr<Swift.UInt8>, lifetime : dotnet.System.TimeSpan) throws -> dotnet.System_Arr<Swift.UInt8> {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(protector: aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl: __copy_handle(self.get_handle())), plaintext: plaintext, lifetime: lifetime);
    }
}

// EXTENSION METHOD System.String Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, System.DateTimeOffset)
extension Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector {
    public func Protect(plaintext : dotnet.System.String, expiration : dotnet.System.DateTimeOffset) throws -> dotnet.System.String {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(protector: aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl: __copy_handle(self.get_handle())), plaintext: plaintext, expiration: expiration);
    }
}

// EXTENSION METHOD System.String Protect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, System.TimeSpan)
extension Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector {
    public func Protect(plaintext : dotnet.System.String, lifetime : dotnet.System.TimeSpan) throws -> dotnet.System.String {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Protect(protector: aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl: __copy_handle(self.get_handle())), plaintext: plaintext, lifetime: lifetime);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector ToTimeLimitedDataProtector(Microsoft.AspNetCore.DataProtection.IDataProtector)
extension Microsoft_AspNetCore_DataProtection_IDataProtector {
    public func ToTimeLimitedDataProtector() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.ToTimeLimitedDataProtector(protector: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtector(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD System.String Unprotect(Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector, System.String, ref System.DateTimeOffset)
extension Microsoft_AspNetCore_DataProtection_ITimeLimitedDataProtector {
    public func Unprotect(protectedData : dotnet.System.String, expiration : inout dotnet.System.DateTimeOffset) throws -> dotnet.System.String {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionAdvancedExtensions.Unprotect(protector: aspnetcore.Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector(hndl: __copy_handle(self.get_handle())), protectedData: protectedData, expiration: &expiration);
    }
}

