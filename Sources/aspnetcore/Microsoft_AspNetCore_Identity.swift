// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Identity
extension Microsoft.AspNetCore.Identity {
// type: Microsoft.AspNetCore.Identity.AspNetRoleManager`1
    /**
    
            Provides the APIs for managing roles in a persistence store.
            

    */
open class AspNetRoleManager_1<TRole : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_AspNetRoleManager_1_get_type_handle(TRole.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IRoleStore<TRole>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IRoleValidator<TRole>>, Microsoft.AspNetCore.Identity.ILookupNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.RoleManager<TRole>>, Microsoft.AspNetCore.Http.IHttpContextAccessor)
// docid: M:Microsoft.AspNetCore.Identity.AspNetRoleManager`1.#ctor(Microsoft.AspNetCore.Identity.IRoleStore{`0},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IRoleValidator{`0}},Microsoft.AspNetCore.Identity.ILookupNormalizer,Microsoft.AspNetCore.Identity.IdentityErrorDescriber,Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.RoleManager{`0}},Microsoft.AspNetCore.Http.IHttpContextAccessor)
    /**
    
            Constructs a new instance of .
            

    - Parameter store: The persistence store the manager will operate over.
    - Parameter roleValidators: A collection of validators for roles.
    - Parameter keyNormalizer: The normalizer to use when normalizing role names to keys.
    - Parameter errors: The  used to provider error messages.
    - Parameter logger: The logger used to log messages, warnings and errors.
    - Parameter contextAccessor: The accessor used to access the .
    */
    public init(store : aspnetcore.Microsoft.AspNetCore.Identity.IRoleStore_1<TRole>, roleValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IRoleValidator_1<TRole>>>, keyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>, errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.RoleManager_1<TRole>>>, contextAccessor : Optional<aspnetcore.Microsoft.AspNetCore.Http.IHttpContextAccessor>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_AspNetRoleManager_1_ctor_0__6__Microsoft_AspNetCore_Identity_IRoleStore_TRole__System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IRoleValidator_TRole___ILookupNormalizer_IdentityErrorDescriber_Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_RoleManager_TRole___IHttpContextAccessor(TRole.get_type_handle(), &__thrown, nil, (roleValidators?.get_handle()), keyNormalizer?.get_handle() ?? nil, errors?.get_handle() ?? nil, (logger?.get_handle()), contextAccessor?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // AspNetRoleManager_1


// type: Microsoft.AspNetCore.Identity.AspNetUserManager`1
    /**
    
            Provides the APIs for managing user in a persistence store.
            

    */
open class AspNetUserManager_1<TUser : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_AspNetUserManager_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.IUserStore<TUser>, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions>, Microsoft.AspNetCore.Identity.IPasswordHasher<TUser>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IUserValidator<TUser>>, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Identity.IPasswordValidator<TUser>>, Microsoft.AspNetCore.Identity.ILookupNormalizer, Microsoft.AspNetCore.Identity.IdentityErrorDescriber, System.IServiceProvider, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.UserManager<TUser>>)
// docid: M:Microsoft.AspNetCore.Identity.AspNetUserManager`1.#ctor(Microsoft.AspNetCore.Identity.IUserStore{`0},Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.IdentityOptions},Microsoft.AspNetCore.Identity.IPasswordHasher{`0},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IUserValidator{`0}},System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Identity.IPasswordValidator{`0}},Microsoft.AspNetCore.Identity.ILookupNormalizer,Microsoft.AspNetCore.Identity.IdentityErrorDescriber,System.IServiceProvider,Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.UserManager{`0}})
    /**
    
            Constructs a new instance of .
            

    - Parameter store: The persistence store the manager will operate over.
    - Parameter optionsAccessor: The accessor used to access the .
    - Parameter passwordHasher: The password hashing implementation to use when saving passwords.
    - Parameter userValidators: A collection of  to validate users against.
    - Parameter passwordValidators: A collection of  to validate passwords against.
    - Parameter keyNormalizer: The  to use when generating index keys for users.
    - Parameter errors: The  used to provider error messages.
    - Parameter services: The  used to resolve services.
    - Parameter logger: The logger used to log messages, warnings and errors.
    */
    public override init(store : aspnetcore.Microsoft.AspNetCore.Identity.IUserStore_1<TUser>, optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>>, passwordHasher : aspnetcore.Microsoft.AspNetCore.Identity.IPasswordHasher_1<TUser>, userValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IUserValidator_1<TUser>>>, passwordValidators : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Identity.IPasswordValidator_1<TUser>>>, keyNormalizer : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ILookupNormalizer>, errors : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityErrorDescriber>, services : Optional<dotnet.System.IServiceProvider>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_AspNetUserManager_1_ctor_0__9__Microsoft_AspNetCore_Identity_IUserStore_TUser__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_IdentityOptions__Microsoft_AspNetCore_Identity_IPasswordHasher_TUser__System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IUserValidator_TUser___System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_IPasswordValidator_TUser___ILookupNormalizer_IdentityErrorDescriber_IServiceProvider_Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_UserManager_TUser__(TUser.get_type_handle(), &__thrown, nil, (optionsAccessor?.get_handle()), nil, (userValidators?.get_handle()), (passwordValidators?.get_handle()), keyNormalizer?.get_handle() ?? nil, errors?.get_handle() ?? nil, services?.get_handle() ?? nil, (logger?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // AspNetUserManager_1


// type: Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions
    /**
    
            Contains options for the .
            

    */
open class DataProtectionTokenProviderOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Name(System.String)
// docid: M:Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.set_Name(System.String)
    open func set_Name(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions_void__set_Name_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_TokenLifespan()
// docid: M:Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions.get_TokenLifespan
    open func get_TokenLifespan() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions_TimeSpan__get_TokenLifespan_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_TokenLifespan(System.TimeSpan)
    /**
    
            Gets or sets the name of the . Defaults to DataProtectorTokenProvider.
            

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
        set(v) {
            return try! set_Name(value: v!);
        }
    }
    /**
    
            Gets or sets the amount of time a generated token remains valid. Defaults to 1 day.
            

    */
    open var TokenLifespan : dotnet.System.TimeSpan {
        get {
            return try! get_TokenLifespan();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_TokenLifespan(System.TimeSpan)
    }
} // DataProtectionTokenProviderOptions


// type: Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1
    /**
    
            Provides protection and validation of identity tokens.
            

    */
open class DataProtectorTokenProvider_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.DataProtection.IDataProtectionProvider, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions>, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>>)
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.#ctor(Microsoft.AspNetCore.DataProtection.IDataProtectionProvider,Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions},Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.DataProtectorTokenProvider{`0}})
    /**
    
            Initializes a new instance of the  class.
            

    - Parameter dataProtectionProvider: The system data protection provider.
    - Parameter options: The configured .
    - Parameter logger: The logger used to log messages, warnings and errors.
    */
    public init(dataProtectionProvider : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionProvider>, options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.DataProtectionTokenProviderOptions>>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.DataProtectorTokenProvider_1<TUser>>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_ctor_0__3__IDataProtectionProvider_Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_DataProtectionTokenProviderOptions__Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_TUser__(TUser.get_type_handle(), &__thrown, dataProtectionProvider?.get_handle() ?? nil, (options?.get_handle()), (logger?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<System.String> GenerateAsync(System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.GenerateAsync(System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Generates a protected token for the specified  as an asynchronous operation.
            

    - Parameter purpose: The purpose the token will be used for.
    - Parameter manager: The  to retrieve user properties from.
    - Parameter user: The  the token will be generated from.
    - Returns: A  representing the generated token.

    */
    open func GenerateAsync(purpose : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_System_Threading_Tasks_Task_string___GenerateAsync_0__3__String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> ValidateAsync(System.String, System.String, Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.ValidateAsync(System.String,System.String,Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Validates the protected  for the specified  and  as an asynchronous operation.
            

    - Parameter purpose: The purpose the token was be used for.
    - Parameter token: The token to validate.
    - Parameter manager: The  to retrieve user properties from.
    - Parameter user: The  the token was generated for.
    - Returns: 
            A  that represents the result of the asynchronous validation,
            containing true if the token is valid, otherwise false.
            

    */
    open func ValidateAsync(purpose : Optional<dotnet.System.String>, token : Optional<dotnet.System.String>, manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_System_Threading_Tasks_Task_bool___ValidateAsync_0__4__String_String_Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), purpose?.get_handle() ?? nil, token?.get_handle() ?? nil, nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager<TUser>, TUser)
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.CanGenerateTwoFactorTokenAsync(Microsoft.AspNetCore.Identity.UserManager{`0},`0)
    /**
    
            Returns a  indicating whether a token generated by this instance
            can be used as a Two Factor Authentication token as an asynchronous operation.
            

    - Parameter manager: The  to retrieve user properties from.
    - Parameter user: The  the token was generated for.
    - Returns: 
            A  that represents the result of the asynchronous query,
            containing true if a token generated by this instance can be used as a Two Factor Authentication token, otherwise false.
            

    */
    open func CanGenerateTwoFactorTokenAsync(manager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_System_Threading_Tasks_Task_bool___CanGenerateTwoFactorTokenAsync_0__2__Microsoft_AspNetCore_Identity_UserManager_TUser__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), nil, user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_String__get_Name_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.DataProtectorTokenProvider<TUser>> get_Logger()
// docid: M:Microsoft.AspNetCore.Identity.DataProtectorTokenProvider`1.get_Logger
    open func get_Logger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.DataProtectorTokenProvider_1<TUser>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_1_Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_DataProtectorTokenProvider_TUser____get_Logger_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the  used to log messages from the provider.
            

    */
    open var Logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.DataProtectorTokenProvider_1<TUser>>> {
        get {
            return try! get_Logger();
        }
    }
    /**
    
            Gets the name of this instance.
            

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
} // DataProtectorTokenProvider_1


// type: Microsoft.AspNetCore.Identity.ExternalLoginInfo
    /**
    
            Represents login information, source and externally source principal for a user record
            

    */
open class ExternalLoginInfo
    :
    aspnetcore.Microsoft.AspNetCore.Identity.UserLoginInfo
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ExternalLoginInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Security.Claims.ClaimsPrincipal, System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.#ctor(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.String)
    /**
    
            Creates a new instance of 
            

    - Parameter principal: The  to associate with this login.
    - Parameter loginProvider: The provider associated with this login information.
    - Parameter providerKey: The unique identifier for this user provided by the login provider.
    - Parameter displayName: The display name for the login provider.
    */
    public init(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>, loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, displayName : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_ExternalLoginInfo_ctor_0__4__ClaimsPrincipal_String_String_String(&__thrown, principal?.get_handle() ?? nil, loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, displayName?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Security.Claims.ClaimsPrincipal get_Principal()
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.get_Principal
    open func get_Principal() throws -> Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ExternalLoginInfo_ClaimsPrincipal__get_Principal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.ClaimsPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Principal(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.set_Principal(System.Security.Claims.ClaimsPrincipal)
    open func set_Principal(value : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ExternalLoginInfo_void__set_Principal_0__1__ClaimsPrincipal(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationToken> get_AuthenticationTokens()
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.get_AuthenticationTokens
    open func get_AuthenticationTokens() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationToken>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ExternalLoginInfo_System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Authentication_AuthenticationToken___get_AuthenticationTokens_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticationTokens(System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationToken>)
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.set_AuthenticationTokens(System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Authentication.AuthenticationToken})
    open func set_AuthenticationTokens(value : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationToken>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ExternalLoginInfo_void__set_AuthenticationTokens_0__1__System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Authentication_AuthenticationToken_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Authentication.AuthenticationProperties get_AuthenticationProperties()
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.get_AuthenticationProperties
    open func get_AuthenticationProperties() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ExternalLoginInfo_AuthenticationProperties__get_AuthenticationProperties_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticationProperties(Microsoft.AspNetCore.Authentication.AuthenticationProperties)
// docid: M:Microsoft.AspNetCore.Identity.ExternalLoginInfo.set_AuthenticationProperties(Microsoft.AspNetCore.Authentication.AuthenticationProperties)
    open func set_AuthenticationProperties(value : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_ExternalLoginInfo_void__set_AuthenticationProperties_0__1__AuthenticationProperties(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The  associated with this login.
            

    */
    open var AuthenticationProperties : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties> {
        get {
            return try! get_AuthenticationProperties();
        }
        set(v) {
            return try! set_AuthenticationProperties(value: v!);
        }
    }
    /**
    
            The s associated with this login.
            

    */
    open var AuthenticationTokens : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationToken>> {
        get {
            return try! get_AuthenticationTokens();
        }
        set(v) {
            return try! set_AuthenticationTokens(value: v!);
        }
    }
    /**
    
            Gets or sets the  associated with this login.
            

    */
    open var Principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        get {
            return try! get_Principal();
        }
        set(v) {
            return try! set_Principal(value: v!);
        }
    }
} // ExternalLoginInfo


// type: Microsoft.AspNetCore.Identity.ISecurityStampValidator
    /**
    
            Provides an abstraction for a validating a security stamp of an incoming identity, and regenerating or rejecting the
            identity based on the validation result.
            

    */
open class ISecurityStampValidator
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_ISecurityStampValidator
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ISecurityStampValidator_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Threading.Tasks.Task ValidateAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
// docid: M:Microsoft.AspNetCore.Identity.ISecurityStampValidator.ValidateAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
    /**
    
            Validates a security stamp of an identity as an asynchronous operation, and rebuilds the identity if the validation succeeds, otherwise rejects
            the identity.
            

    - Parameter context: The context containing the 
            and  to validate.
    - Returns: The  that represents the asynchronous validation operation.

    */
    open func ValidateAsync(context : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext>) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_ISecurityStampValidator_Task__ValidateAsync_0__1__CookieValidatePrincipalContext(&__thrown, self.get_handle(), context?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ISecurityStampValidator


// type: Microsoft.AspNetCore.Identity.ITwoFactorSecurityStampValidator
    /**
    
            Used to validate the two factor remember client cookie security stamp.
            

    */
open class ITwoFactorSecurityStampValidator
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_Identity_ITwoFactorSecurityStampValidator,
    Microsoft_AspNetCore_Identity_ISecurityStampValidator
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_ITwoFactorSecurityStampValidator_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

} // ITwoFactorSecurityStampValidator


// type: Microsoft.AspNetCore.Identity.IdentityBuilderExtensions
public struct IdentityBuilderExtensions {
    // Microsoft.AspNetCore.Identity.IdentityBuilder AddDefaultTokenProviders(Microsoft.AspNetCore.Identity.IdentityBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilderExtensions.AddDefaultTokenProviders(Microsoft.AspNetCore.Identity.IdentityBuilder)
    /**
    
            Adds the default token providers used to generate tokens for reset passwords, change email
            and change telephone number operations, and for two factor authentication token generation.
            

    - Parameter builder: The current  instance.
    - Returns: The current  instance.

    */
    public static func AddDefaultTokenProviders(builder : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilderExtensions_IdentityBuilder__AddDefaultTokenProviders_0__1__IdentityBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityBuilder AddSignInManager(Microsoft.AspNetCore.Identity.IdentityBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityBuilderExtensions.AddSignInManager(Microsoft.AspNetCore.Identity.IdentityBuilder)
    /**
    
            Adds a  for the .
            

    - Parameter builder: The current  instance.
    - Returns: The current  instance.

    */
    public static func AddSignInManager(builder : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityBuilderExtensions_IdentityBuilder__AddSignInManager_0__1__IdentityBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddSignInManager<TSignInManager>(Microsoft.AspNetCore.Identity.IdentityBuilder)
} // IdentityBuilderExtensions


// type: Microsoft.AspNetCore.Identity.IdentityConstants
    /**
    
            Represents all the options you can use to configure the cookies middleware used by the identity system.
            

    */
open class IdentityConstants
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityConstants_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.String ApplicationScheme
    /**
    
            The scheme used to identify application authentication cookies.
            

    */
    open class var ApplicationScheme : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_IdentityConstants_get_ApplicationScheme();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String ExternalScheme
    /**
    
            The scheme used to identify external authentication cookies.
            

    */
    open class var ExternalScheme : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_IdentityConstants_get_ExternalScheme();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String TwoFactorRememberMeScheme
    /**
    
            The scheme used to identify Two Factor authentication cookies for saving the Remember Me state.
            

    */
    open class var TwoFactorRememberMeScheme : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_IdentityConstants_get_TwoFactorRememberMeScheme();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // static field: System.String TwoFactorUserIdScheme
    /**
    
            The scheme used to identify Two Factor authentication cookies for round tripping user identities.
            

    */
    open class var TwoFactorUserIdScheme : Optional<dotnet.System.String> {
        get {
        let __h = Microsoft_AspNetCore_Identity_IdentityConstants_get_TwoFactorUserIdScheme();
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityConstants.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityConstants_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // IdentityConstants


// type: Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions
public struct IdentityCookieAuthenticationBuilderExtensions {
    // Microsoft.AspNetCore.Identity.IdentityCookiesBuilder AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
    /**
    
            Adds cookie authentication.
            

    - Parameter builder: The current  instance.
    - Returns: The  which can be used to configure the identity cookies.

    */
    public static func AddIdentityCookies(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_IdentityCookiesBuilder__AddIdentityCookies_0__1__AuthenticationBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Identity.IdentityCookiesBuilder AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder, System.Action<Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder,System.Action{Microsoft.AspNetCore.Identity.IdentityCookiesBuilder})
    /**
    
            Adds the cookie authentication needed for sign in manager.
            

    - Parameter builder: The current  instance.
    - Parameter configureCookies: Action used to configure the cookies.
    - Returns: The  which can be used to configure the identity cookies.

    */
    public static func AddIdentityCookies(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>, configureCookies : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_IdentityCookiesBuilder__AddIdentityCookies_0__2__AuthenticationBuilder_System_Action_Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_(&__thrown, builder?.get_handle() ?? nil, (configureCookies?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddIdentityCookies(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>, configureCookies : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        let del_configureCookies = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>(configureCookies);
        return try AddIdentityCookies(builder: builder, configureCookies: del_configureCookies);
    }
    // Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddApplicationCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddApplicationCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
    /**
    
            Adds the identity application cookie.
            

    - Parameter builder: The current  instance.
    - Returns: The  which can be used to configure the cookie authentication.

    */
    public static func AddApplicationCookie(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___AddApplicationCookie_0__1__AuthenticationBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddExternalCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddExternalCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
    /**
    
            Adds the identity cookie used for external logins.
            

    - Parameter builder: The current  instance.
    - Returns: The  which can be used to configure the cookie authentication.

    */
    public static func AddExternalCookie(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___AddExternalCookie_0__1__AuthenticationBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddTwoFactorRememberMeCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddTwoFactorRememberMeCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
    /**
    
            Adds the identity cookie used for two factor remember me.
            

    - Parameter builder: The current  instance.
    - Returns: The  which can be used to configure the cookie authentication.

    */
    public static func AddTwoFactorRememberMeCookie(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___AddTwoFactorRememberMeCookie_0__1__AuthenticationBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddTwoFactorUserIdCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddTwoFactorUserIdCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
    /**
    
            Adds the identity cookie used for two factor logins.
            

    - Parameter builder: The current  instance.
    - Returns: The  which can be used to configure the cookie authentication.

    */
    public static func AddTwoFactorUserIdCookie(builder : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookieAuthenticationBuilderExtensions_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___AddTwoFactorUserIdCookie_0__1__AuthenticationBuilder(&__thrown, builder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IdentityCookieAuthenticationBuilderExtensions


// type: Microsoft.AspNetCore.Identity.IdentityCookiesBuilder
    /**
    
            Used to configure identity cookie options.
            

    */
open class IdentityCookiesBuilder
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> get_ApplicationCookie()
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.get_ApplicationCookie
    open func get_ApplicationCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___get_ApplicationCookie_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ApplicationCookie(Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.set_ApplicationCookie(Microsoft.Extensions.Options.OptionsBuilder{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions})
    open func set_ApplicationCookie(value : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_void__set_ApplicationCookie_0__1__Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> get_ExternalCookie()
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.get_ExternalCookie
    open func get_ExternalCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___get_ExternalCookie_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ExternalCookie(Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.set_ExternalCookie(Microsoft.Extensions.Options.OptionsBuilder{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions})
    open func set_ExternalCookie(value : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_void__set_ExternalCookie_0__1__Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> get_TwoFactorRememberMeCookie()
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.get_TwoFactorRememberMeCookie
    open func get_TwoFactorRememberMeCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___get_TwoFactorRememberMeCookie_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_TwoFactorRememberMeCookie(Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.set_TwoFactorRememberMeCookie(Microsoft.Extensions.Options.OptionsBuilder{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions})
    open func set_TwoFactorRememberMeCookie(value : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_void__set_TwoFactorRememberMeCookie_0__1__Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> get_TwoFactorUserIdCookie()
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.get_TwoFactorUserIdCookie
    open func get_TwoFactorUserIdCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions___get_TwoFactorUserIdCookie_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_TwoFactorUserIdCookie(Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>)
// docid: M:Microsoft.AspNetCore.Identity.IdentityCookiesBuilder.set_TwoFactorUserIdCookie(Microsoft.Extensions.Options.OptionsBuilder{Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions})
    open func set_TwoFactorUserIdCookie(value : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_IdentityCookiesBuilder_void__set_TwoFactorUserIdCookie_0__1__Microsoft_Extensions_Options_OptionsBuilder_Microsoft_AspNetCore_Authentication_Cookies_CookieAuthenticationOptions_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Used to configure the application cookie.
            

    */
    open var ApplicationCookie : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        get {
            return try! get_ApplicationCookie();
        }
        set(v) {
            return try! set_ApplicationCookie(value: v!);
        }
    }
    /**
    
            Used to configure the external cookie.
            

    */
    open var ExternalCookie : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        get {
            return try! get_ExternalCookie();
        }
        set(v) {
            return try! set_ExternalCookie(value: v!);
        }
    }
    /**
    
            Used to configure the two factor remember me cookie.
            

    */
    open var TwoFactorRememberMeCookie : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        get {
            return try! get_TwoFactorRememberMeCookie();
        }
        set(v) {
            return try! set_TwoFactorRememberMeCookie(value: v!);
        }
    }
    /**
    
            Used to configure the two factor user id cookie.
            

    */
    open var TwoFactorUserIdCookie : Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        get {
            return try! get_TwoFactorUserIdCookie();
        }
        set(v) {
            return try! set_TwoFactorUserIdCookie(value: v!);
        }
    }
} // IdentityCookiesBuilder


// type: Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext
    /**
    
            Used to pass information during the SecurityStamp validation event.
            

    */
open class SecurityStampRefreshingPrincipalContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Security.Claims.ClaimsPrincipal get_CurrentPrincipal()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext.get_CurrentPrincipal
    open func get_CurrentPrincipal() throws -> Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_ClaimsPrincipal__get_CurrentPrincipal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.ClaimsPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_CurrentPrincipal(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext.set_CurrentPrincipal(System.Security.Claims.ClaimsPrincipal)
    open func set_CurrentPrincipal(value : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_void__set_CurrentPrincipal_0__1__ClaimsPrincipal(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Claims.ClaimsPrincipal get_NewPrincipal()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext.get_NewPrincipal
    open func get_NewPrincipal() throws -> Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_ClaimsPrincipal__get_NewPrincipal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Claims.ClaimsPrincipal(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_NewPrincipal(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext.set_NewPrincipal(System.Security.Claims.ClaimsPrincipal)
    open func set_NewPrincipal(value : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_void__set_NewPrincipal_0__1__ClaimsPrincipal(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The principal contained in the current cookie.
            

    */
    open var CurrentPrincipal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        get {
            return try! get_CurrentPrincipal();
        }
        set(v) {
            return try! set_CurrentPrincipal(value: v!);
        }
    }
    /**
    
            The new principal which should replace the current.
            

    */
    open var NewPrincipal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal> {
        get {
            return try! get_NewPrincipal();
        }
        set(v) {
            return try! set_NewPrincipal(value: v!);
        }
    }
} // SecurityStampRefreshingPrincipalContext


// type: Microsoft.AspNetCore.Identity.SecurityStampValidator
public struct SecurityStampValidator {
    // System.Threading.Tasks.Task ValidatePrincipalAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator.ValidatePrincipalAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
    /**
    
            Validates a principal against a user's stored security stamp.
            

    - Parameter context: The context containing the 
            and  to validate.
    - Returns: The  that represents the asynchronous validation operation.

    */
    public static func ValidatePrincipalAsync(context : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext>) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_Task__ValidatePrincipalAsync_0__1__CookieValidatePrincipalContext(&__thrown, context?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Tasks.Task ValidateAsync<TValidator>(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
} // SecurityStampValidator


// type: Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions
    /**
    
            Options for .
            

    */
open class SecurityStampValidatorOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.TimeSpan get_ValidationInterval()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions.get_ValidationInterval
    open func get_ValidationInterval() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions_TimeSpan__get_ValidationInterval_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_ValidationInterval(System.TimeSpan)
    // [IsSpecialName] System.Func<Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,System.Threading.Tasks.Task> get_OnRefreshingPrincipal()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions.get_OnRefreshingPrincipal
    open func get_OnRefreshingPrincipal() throws -> Optional<dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,dotnet.System.Threading.Tasks.Task>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions_System_Func_Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_Task___get_OnRefreshingPrincipal_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_OnRefreshingPrincipal(System.Func<Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,System.Threading.Tasks.Task>)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions.set_OnRefreshingPrincipal(System.Func{Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,System.Threading.Tasks.Task})
    open func set_OnRefreshingPrincipal(value : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,dotnet.System.Threading.Tasks.Task>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions_void__set_OnRefreshingPrincipal_0__1__System_Func_Microsoft_AspNetCore_Identity_SecurityStampRefreshingPrincipalContext_Task_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_OnRefreshingPrincipal(value : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext>) throws -> dotnet.System.Threading.Tasks.Task) throws {
        let del_value = try dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,dotnet.System.Threading.Tasks.Task>(value);
        return try set_OnRefreshingPrincipal(value: del_value);
    }
    /**
    
            Invoked when the default security stamp validator replaces the user's ClaimsPrincipal in the cookie.
            

    */
    open var OnRefreshingPrincipal : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampRefreshingPrincipalContext,dotnet.System.Threading.Tasks.Task>> {
        get {
            return try! get_OnRefreshingPrincipal();
        }
        set(v) {
            return try! set_OnRefreshingPrincipal(value: v!);
        }
    }
    /**
    
            Gets or sets the  after which security stamps are re-validated. Defaults to 30 minutes.
            

    */
    open var ValidationInterval : dotnet.System.TimeSpan {
        get {
            return try! get_ValidationInterval();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_ValidationInterval(System.TimeSpan)
    }
} // SecurityStampValidatorOptions


// type: Microsoft.AspNetCore.Identity.SecurityStampValidator`1
    /**
    
            Provides default implementation of validation functions for security stamps.
            

    */
open class SecurityStampValidator_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Identity_ISecurityStampValidator
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SecurityStampValidator_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions>, Microsoft.AspNetCore.Identity.SignInManager<TUser>, Microsoft.AspNetCore.Authentication.ISystemClock, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions},Microsoft.AspNetCore.Identity.SignInManager{`0},Microsoft.AspNetCore.Authentication.ISystemClock,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a new instance of .
            

    - Parameter options: Used to access the .
    - Parameter signInManager: The .
    - Parameter clock: The system clock.
    - Parameter logger: The logger.
    */
    public init(options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions>>, signInManager : aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1<TUser>, clock : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.ISystemClock>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_ctor_0__4__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions__Microsoft_AspNetCore_Identity_SignInManager_TUser__ISystemClock_ILoggerFactory(TUser.get_type_handle(), &__thrown, (options?.get_handle()), nil, clock?.get_handle() ?? nil, logger?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task ValidateAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.ValidateAsync(Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext)
    /**
    
            Validates a security stamp of an identity as an asynchronous operation, and rebuilds the identity if the validation succeeds, otherwise rejects
            the identity.
            

    - Parameter context: The context containing the 
            and  to validate.
    - Returns: The  that represents the asynchronous validation operation.

    */
    open func ValidateAsync(context : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieValidatePrincipalContext>) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_Task__ValidateAsync_0__1__CookieValidatePrincipalContext(TUser.get_type_handle(), &__thrown, self.get_handle(), context?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SignInManager<TUser> get_SignInManager()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.get_SignInManager
    open func get_SignInManager() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_Microsoft_AspNetCore_Identity_SignInManager_TUser___get_SignInManager_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions get_Options()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.get_Options
    open func get_Options() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_SecurityStampValidatorOptions__get_Options_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Authentication.ISystemClock get_Clock()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.get_Clock
    open func get_Clock() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Authentication.ISystemClock> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_ISystemClock__get_Clock_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Authentication.ISystemClock(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ILogger get_Logger()
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.get_Logger
    open func get_Logger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SecurityStampValidator_1_ILogger__get_Logger_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Logger(Microsoft.Extensions.Logging.ILogger)
// docid: M:Microsoft.AspNetCore.Identity.SecurityStampValidator`1.set_Logger(Microsoft.Extensions.Logging.ILogger)
    open func set_Logger(value : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SecurityStampValidator_1_void__set_Logger_0__1__ILogger(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The .
            

    */
    open var Clock : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.ISystemClock> {
        get {
            return try! get_Clock();
        }
    }
    /**
    
            Gets the  used to log messages.
            

    */
    open var Logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        get {
            return try! get_Logger();
        }
        set(v) {
            return try! set_Logger(value: v!);
        }
    }
    /**
    
            The .
            

    */
    open var Options : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions> {
        get {
            return try! get_Options();
        }
    }
    /**
    
            The SignInManager.
            

    */
    open var SignInManager : Optional<aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1<TUser>> {
        get {
            return try! get_SignInManager();
        }
    }
} // SecurityStampValidator_1


// type: Microsoft.AspNetCore.Identity.SignInManager`1
    /**
    
            Provides the APIs for user sign in.
            

    */
open class SignInManager_1<TUser : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_SignInManager_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.Identity.UserManager<TUser>, Microsoft.AspNetCore.Http.IHttpContextAccessor, Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory<TUser>, Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.IdentityOptions>, Microsoft.Extensions.Logging.ILogger<Microsoft.AspNetCore.Identity.SignInManager<TUser>>, Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider, Microsoft.AspNetCore.Identity.IUserConfirmation<TUser>)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.#ctor(Microsoft.AspNetCore.Identity.UserManager{`0},Microsoft.AspNetCore.Http.IHttpContextAccessor,Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory{`0},Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.IdentityOptions},Microsoft.Extensions.Logging.ILogger{Microsoft.AspNetCore.Identity.SignInManager{`0}},Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider,Microsoft.AspNetCore.Identity.IUserConfirmation{`0})
    /**
    
            Creates a new instance of .
            

    - Parameter userManager: An instance of  used to retrieve users from and persist users.
    - Parameter contextAccessor: The accessor used to access the .
    - Parameter claimsFactory: The factory to use to create claims principals for a user.
    - Parameter optionsAccessor: The accessor used to access the .
    - Parameter logger: The logger used to log messages, warnings and errors.
    - Parameter schemes: The scheme provider that is used enumerate the authentication schemes.
    - Parameter confirmation: The  used check whether a user account is confirmed.
    */
    public init(userManager : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>, contextAccessor : Optional<aspnetcore.Microsoft.AspNetCore.Http.IHttpContextAccessor>, claimsFactory : aspnetcore.Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory_1<TUser>, optionsAccessor : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1<TUser>>>, schemes : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.IAuthenticationSchemeProvider>, confirmation : aspnetcore.Microsoft.AspNetCore.Identity.IUserConfirmation_1<TUser>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_SignInManager_1_ctor_0__7__Microsoft_AspNetCore_Identity_UserManager_TUser__IHttpContextAccessor_Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_TUser__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_IdentityOptions__Microsoft_Extensions_Logging_ILogger_Microsoft_AspNetCore_Identity_Microsoft_AspNetCore_Identity_SignInManager_TUser___IAuthenticationSchemeProvider_Microsoft_AspNetCore_Identity_IUserConfirmation_TUser_(TUser.get_type_handle(), &__thrown, nil, contextAccessor?.get_handle() ?? nil, nil, (optionsAccessor?.get_handle()), (logger?.get_handle()), schemes?.get_handle() ?? nil, nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.Task<System.Security.Claims.ClaimsPrincipal> CreateUserPrincipalAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.CreateUserPrincipalAsync(`0)
    /**
    
            Creates a  for the specified , as an asynchronous operation.
            

    - Parameter user: The user to create a  for.
    - Returns: The task object representing the asynchronous operation, containing the ClaimsPrincipal for the specified user.

    */
    open func CreateUserPrincipalAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Security.Claims.ClaimsPrincipal>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_System_Security_Claims_ClaimsPrincipal___CreateUserPrincipalAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsSignedIn(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.IsSignedIn(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Returns true if the principal has an identity with the application cookie identity
            

    - Parameter principal: The  instance.
    - Returns: True if the user is logged in with identity.

    */
    open func IsSignedIn(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_bool__IsSignedIn_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.Task<bool> CanSignInAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.CanSignInAsync(`0)
    /**
    
            Returns a flag indicating whether the specified user can sign in.
            

    - Parameter user: The user whose sign-in status should be returned.
    - Returns: 
            The task object representing the asynchronous operation, containing a flag that is true
            if the specified user can sign-in, otherwise false.
            

    */
    open func CanSignInAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_bool___CanSignInAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RefreshSignInAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.RefreshSignInAsync(`0)
    /**
    
            Signs in the specified , whilst preserving the existing
            AuthenticationProperties of the current signed-in user like rememberMe, as an asynchronous operation.
            

    - Parameter user: The user to sign-in.
    - Returns: The task object representing the asynchronous operation.

    */
    open func RefreshSignInAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__RefreshSignInAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SignInAsync(TUser, bool, System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.SignInAsync(`0,System.Boolean,System.String)
    /**
    
            Signs in the specified .
            

    - Parameter user: The user to sign-in.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter authenticationMethod: Name of the method used to authenticate the user.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SignInAsync(user : TUser, isPersistent : Bool, authenticationMethod : Optional<dotnet.System.String> = nil) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__SignInAsync_0__3__TUser_bool_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(isPersistent ? 1 : 0), authenticationMethod?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SignInAsync(TUser, Microsoft.AspNetCore.Authentication.AuthenticationProperties, System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.SignInAsync(`0,Microsoft.AspNetCore.Authentication.AuthenticationProperties,System.String)
    /**
    
            Signs in the specified .
            

    - Parameter user: The user to sign-in.
    - Parameter authenticationProperties: Properties applied to the login and authentication cookie.
    - Parameter authenticationMethod: Name of the method used to authenticate the user.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SignInAsync(user : TUser, authenticationProperties : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties>, authenticationMethod : Optional<dotnet.System.String> = nil) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__SignInAsync_0__3__TUser_AuthenticationProperties_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), authenticationProperties?.get_handle() ?? nil, authenticationMethod?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SignInWithClaimsAsync(TUser, bool, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.SignInWithClaimsAsync(`0,System.Boolean,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})
    /**
    
            Signs in the specified .
            

    - Parameter user: The user to sign-in.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter additionalClaims: Additional claims that will be stored in the cookie.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SignInWithClaimsAsync(user : TUser, isPersistent : Bool, additionalClaims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__SignInWithClaimsAsync_0__3__TUser_bool_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), Swift.Int32(isPersistent ? 1 : 0), (additionalClaims?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SignInWithClaimsAsync(TUser, Microsoft.AspNetCore.Authentication.AuthenticationProperties, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.SignInWithClaimsAsync(`0,Microsoft.AspNetCore.Authentication.AuthenticationProperties,System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})
    /**
    
            Signs in the specified .
            

    - Parameter user: The user to sign-in.
    - Parameter authenticationProperties: Properties applied to the login and authentication cookie.
    - Parameter additionalClaims: Additional claims that will be stored in the cookie.
    - Returns: The task object representing the asynchronous operation.

    */
    open func SignInWithClaimsAsync(user : TUser, authenticationProperties : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties>, additionalClaims : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Security.Claims.Claim>>) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__SignInWithClaimsAsync_0__3__TUser_AuthenticationProperties_System_Collections_Generic_IEnumerable_System_Security_Claims_Claim_(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), authenticationProperties?.get_handle() ?? nil, (additionalClaims?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task SignOutAsync()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.SignOutAsync
    /**
    
            Signs the current user out of the application.
            

    */
    open func SignOutAsync() throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__SignOutAsync_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> ValidateSecurityStampAsync(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ValidateSecurityStampAsync(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Validates the security stamp for the specified  against
            the persisted stamp for the current user, as an asynchronous operation.
            

    - Parameter principal: The principal whose stamp should be validated.
    - Returns: The task object representing the asynchronous operation. The task will contain the 
            if the stamp matches the persisted value, otherwise it will return null.

    */
    open func ValidateSecurityStampAsync(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_TUser___ValidateSecurityStampAsync_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> ValidateTwoFactorSecurityStampAsync(System.Security.Claims.ClaimsPrincipal)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ValidateTwoFactorSecurityStampAsync(System.Security.Claims.ClaimsPrincipal)
    /**
    
            Validates the security stamp for the specified  from one of
            the two factor principals (remember client or user id) against
            the persisted stamp for the current user, as an asynchronous operation.
            

    - Parameter principal: The principal whose stamp should be validated.
    - Returns: The task object representing the asynchronous operation. The task will contain the 
            if the stamp matches the persisted value, otherwise it will return null.

    */
    open func ValidateTwoFactorSecurityStampAsync(principal : Optional<dotnet.System.Security.Claims.ClaimsPrincipal>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_TUser___ValidateTwoFactorSecurityStampAsync_0__1__ClaimsPrincipal(TUser.get_type_handle(), &__thrown, self.get_handle(), principal?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> ValidateSecurityStampAsync(TUser, System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ValidateSecurityStampAsync(`0,System.String)
    /**
    
            Validates the security stamp for the specified .  If no user is specified, or if the store
            does not support security stamps, validation is considered successful.
            

    - Parameter user: The user whose stamp should be validated.
    - Parameter securityStamp: The expected security stamp value.
    - Returns: The result of the validation.

    */
    open func ValidateSecurityStampAsync(user : TUser, securityStamp : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_bool___ValidateSecurityStampAsync_0__2__TUser_String(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), securityStamp?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> PasswordSignInAsync(TUser, System.String, bool, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.PasswordSignInAsync(`0,System.String,System.Boolean,System.Boolean)
    /**
    
            Attempts to sign in the specified  and  combination
            as an asynchronous operation.
            

    - Parameter user: The user to sign in.
    - Parameter password: The password to attempt to sign in with.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter lockoutOnFailure: Flag indicating if the user account should be locked if the sign in fails.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func PasswordSignInAsync(user : TUser, password : Optional<dotnet.System.String>, isPersistent : Bool, lockoutOnFailure : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___PasswordSignInAsync_0__4__TUser_String_bool_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0), Swift.Int32(lockoutOnFailure ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> PasswordSignInAsync(System.String, System.String, bool, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.PasswordSignInAsync(System.String,System.String,System.Boolean,System.Boolean)
    /**
    
            Attempts to sign in the specified  and  combination
            as an asynchronous operation.
            

    - Parameter userName: The user name to sign in.
    - Parameter password: The password to attempt to sign in with.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter lockoutOnFailure: Flag indicating if the user account should be locked if the sign in fails.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func PasswordSignInAsync(userName : Optional<dotnet.System.String>, password : Optional<dotnet.System.String>, isPersistent : Bool, lockoutOnFailure : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___PasswordSignInAsync_0__4__String_String_bool_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), userName?.get_handle() ?? nil, password?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0), Swift.Int32(lockoutOnFailure ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> CheckPasswordSignInAsync(TUser, System.String, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.CheckPasswordSignInAsync(`0,System.String,System.Boolean)
    /**
    
            Attempts a password sign in for a user.
            

    - Parameter user: The user to sign in.
    - Parameter password: The password to attempt to sign in with.
    - Parameter lockoutOnFailure: Flag indicating if the user account should be locked if the sign in fails.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func CheckPasswordSignInAsync(user : TUser, password : Optional<dotnet.System.String>, lockoutOnFailure : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___CheckPasswordSignInAsync_0__3__TUser_String_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval(), password?.get_handle() ?? nil, Swift.Int32(lockoutOnFailure ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<bool> IsTwoFactorClientRememberedAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.IsTwoFactorClientRememberedAsync(`0)
    /**
    
            Returns a flag indicating if the current client browser has been remembered by two factor authentication
            for the user attempting to login, as an asynchronous operation.
            

    - Parameter user: The user attempting to login.
    - Returns: 
            The task object representing the asynchronous operation containing true if the browser has been remembered
            for the current user.
            

    */
    open func IsTwoFactorClientRememberedAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_bool___IsTwoFactorClientRememberedAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task RememberTwoFactorClientAsync(TUser)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.RememberTwoFactorClientAsync(`0)
    /**
    
            Sets a flag on the browser to indicate the user has selected "Remember this browser" for two factor authentication purposes,
            as an asynchronous operation.
            

    - Parameter user: The user who choose "remember this browser".
    - Returns: The task object representing the asynchronous operation.

    */
    open func RememberTwoFactorClientAsync(user : TUser) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__RememberTwoFactorClientAsync_0__1__TUser(TUser.get_type_handle(), &__thrown, self.get_handle(), user.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task ForgetTwoFactorClientAsync()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ForgetTwoFactorClientAsync
    /**
    
            Clears the "Remember this browser flag" from the current browser, as an asynchronous operation.
            

    - Returns: The task object representing the asynchronous operation.

    */
    open func ForgetTwoFactorClientAsync() throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Task__ForgetTwoFactorClientAsync_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> TwoFactorRecoveryCodeSignInAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.TwoFactorRecoveryCodeSignInAsync(System.String)
    /**
    
            Signs in the user without two factor authentication using a two factor recovery code.
            

    - Parameter recoveryCode: The two factor recovery code.
    - Returns: 

    */
    open func TwoFactorRecoveryCodeSignInAsync(recoveryCode : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___TwoFactorRecoveryCodeSignInAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), recoveryCode?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> TwoFactorAuthenticatorSignInAsync(System.String, bool, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.TwoFactorAuthenticatorSignInAsync(System.String,System.Boolean,System.Boolean)
    /**
    
            Validates the sign in code from an authenticator app and creates and signs in the user, as an asynchronous operation.
            

    - Parameter code: The two factor authentication code to validate.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter rememberClient: Flag indicating whether the current browser should be remember, suppressing all further
            two factor authentication prompts.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func TwoFactorAuthenticatorSignInAsync(code : Optional<dotnet.System.String>, isPersistent : Bool, rememberClient : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___TwoFactorAuthenticatorSignInAsync_0__3__String_bool_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), code?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0), Swift.Int32(rememberClient ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> TwoFactorSignInAsync(System.String, System.String, bool, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.TwoFactorSignInAsync(System.String,System.String,System.Boolean,System.Boolean)
    /**
    
            Validates the two factor sign in code and creates and signs in the user, as an asynchronous operation.
            

    - Parameter provider: The two factor authentication provider to validate the code against.
    - Parameter code: The two factor authentication code to validate.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter rememberClient: Flag indicating whether the current browser should be remember, suppressing all further
            two factor authentication prompts.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func TwoFactorSignInAsync(provider : Optional<dotnet.System.String>, code : Optional<dotnet.System.String>, isPersistent : Bool, rememberClient : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___TwoFactorSignInAsync_0__4__String_String_bool_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), provider?.get_handle() ?? nil, code?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0), Swift.Int32(rememberClient ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<TUser> GetTwoFactorAuthenticationUserAsync()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.GetTwoFactorAuthenticationUserAsync
    /**
    
            Gets the  for the current two factor authentication login, as an asynchronous operation.
            

    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func GetTwoFactorAuthenticationUserAsync() throws -> Optional<dotnet.System.Threading.Tasks.Task_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_TUser___GetTwoFactorAuthenticationUserAsync_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> ExternalLoginSignInAsync(System.String, System.String, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ExternalLoginSignInAsync(System.String,System.String,System.Boolean)
    /**
    
            Signs in a user via a previously registered third party login, as an asynchronous operation.
            

    - Parameter loginProvider: The login provider to use.
    - Parameter providerKey: The unique provider identifier for the user.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func ExternalLoginSignInAsync(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, isPersistent : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___ExternalLoginSignInAsync_0__3__String_String_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.SignInResult> ExternalLoginSignInAsync(System.String, System.String, bool, bool)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ExternalLoginSignInAsync(System.String,System.String,System.Boolean,System.Boolean)
    /**
    
            Signs in a user via a previously registered third party login, as an asynchronous operation.
            

    - Parameter loginProvider: The login provider to use.
    - Parameter providerKey: The unique provider identifier for the user.
    - Parameter isPersistent: Flag indicating whether the sign-in cookie should persist after the browser is closed.
    - Parameter bypassTwoFactor: Flag indicating whether to bypass two factor authentication.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func ExternalLoginSignInAsync(loginProvider : Optional<dotnet.System.String>, providerKey : Optional<dotnet.System.String>, isPersistent : Bool, bypassTwoFactor : Bool) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.SignInResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_SignInResult___ExternalLoginSignInAsync_0__4__String_String_bool_bool(TUser.get_type_handle(), &__thrown, self.get_handle(), loginProvider?.get_handle() ?? nil, providerKey?.get_handle() ?? nil, Swift.Int32(isPersistent ? 1 : 0), Swift.Int32(bypassTwoFactor ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.Authentication.AuthenticationScheme>> GetExternalAuthenticationSchemesAsync()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.GetExternalAuthenticationSchemesAsync
    /**
    
            Gets a collection of s for the known external login providers.
            

    - Returns: A collection of s for the known external login providers.

    */
    open func GetExternalAuthenticationSchemesAsync() throws -> Optional<dotnet.System.Threading.Tasks.Task_1<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationScheme>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_System_Collections_Generic_System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_Authentication_AuthenticationScheme____GetExternalAuthenticationSchemesAsync_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.ExternalLoginInfo> GetExternalLoginInfoAsync(System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.GetExternalLoginInfoAsync(System.String)
    /**
    
            Gets the external login information for the current login, as an asynchronous operation.
            

    - Parameter expectedXsrf: Flag indication whether a Cross Site Request Forgery token was expected in the current request.
    - Returns: The task object representing the asynchronous operation containing the 
            for the sign-in attempt.

    */
    open func GetExternalLoginInfoAsync(expectedXsrf : Optional<dotnet.System.String> = nil) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.ExternalLoginInfo>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_ExternalLoginInfo___GetExternalLoginInfoAsync_0__1__String(TUser.get_type_handle(), &__thrown, self.get_handle(), expectedXsrf?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task<Microsoft.AspNetCore.Identity.IdentityResult> UpdateExternalAuthenticationTokensAsync(Microsoft.AspNetCore.Identity.ExternalLoginInfo)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.UpdateExternalAuthenticationTokensAsync(Microsoft.AspNetCore.Identity.ExternalLoginInfo)
    /**
    
            Stores any authentication tokens found in the external authentication cookie into the associated user.
            

    - Parameter externalLogin: The information from the external login provider.
    - Returns: The  that represents the asynchronous operation, containing the  of the operation.

    */
    open func UpdateExternalAuthenticationTokensAsync(externalLogin : Optional<aspnetcore.Microsoft.AspNetCore.Identity.ExternalLoginInfo>) throws -> Optional<dotnet.System.Threading.Tasks.Task_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityResult>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_System_Threading_Tasks_Task_Microsoft_AspNetCore_Identity_IdentityResult___UpdateExternalAuthenticationTokensAsync_0__1__ExternalLoginInfo(TUser.get_type_handle(), &__thrown, self.get_handle(), externalLogin?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.AspNetCore.Authentication.AuthenticationProperties ConfigureExternalAuthenticationProperties(System.String, System.String, System.String)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.ConfigureExternalAuthenticationProperties(System.String,System.String,System.String)
    /**
    
            Configures the redirect URL and user identifier for the specified external login .
            

    - Parameter provider: The provider to configure.
    - Parameter redirectUrl: The external login URL users should be redirected to during the login flow.
    - Parameter userId: The current user's identifier, which will be used to provide CSRF protection.
    - Returns: A configured .

    */
    open func ConfigureExternalAuthenticationProperties(provider : Optional<dotnet.System.String>, redirectUrl : Optional<dotnet.System.String>, userId : Optional<dotnet.System.String> = nil) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_AuthenticationProperties__ConfigureExternalAuthenticationProperties_0__3__String_String_String(TUser.get_type_handle(), &__thrown, self.get_handle(), provider?.get_handle() ?? nil, redirectUrl?.get_handle() ?? nil, userId?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationProperties(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ILogger get_Logger()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.get_Logger
    open func get_Logger() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_ILogger__get_Logger_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Logger(Microsoft.Extensions.Logging.ILogger)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.set_Logger(Microsoft.Extensions.Logging.ILogger)
    open func set_Logger(value : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInManager_1_void__set_Logger_0__1__ILogger(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.UserManager<TUser> get_UserManager()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.get_UserManager
    open func get_UserManager() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Microsoft_AspNetCore_Identity_UserManager_TUser___get_UserManager_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_UserManager(Microsoft.AspNetCore.Identity.UserManager<TUser>)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.set_UserManager(Microsoft.AspNetCore.Identity.UserManager{`0})
    open func set_UserManager(value : aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInManager_1_void__set_UserManager_0__1__Microsoft_AspNetCore_Identity_UserManager_TUser_(TUser.get_type_handle(), &__thrown, self.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory<TUser> get_ClaimsFactory()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.get_ClaimsFactory
    open func get_ClaimsFactory() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory_1<TUser>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_TUser___get_ClaimsFactory_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClaimsFactory(Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory<TUser>)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.set_ClaimsFactory(Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory{`0})
    open func set_ClaimsFactory(value : aspnetcore.Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory_1<TUser>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInManager_1_void__set_ClaimsFactory_0__1__Microsoft_AspNetCore_Identity_IUserClaimsPrincipalFactory_TUser_(TUser.get_type_handle(), &__thrown, self.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Identity.IdentityOptions get_Options()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.get_Options
    open func get_Options() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_IdentityOptions__get_Options_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Options(Microsoft.AspNetCore.Identity.IdentityOptions)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.set_Options(Microsoft.AspNetCore.Identity.IdentityOptions)
    open func set_Options(value : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInManager_1_void__set_Options_0__1__IdentityOptions(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.Http.HttpContext get_Context()
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.get_Context
    open func get_Context() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Identity_SignInManager_1_HttpContext__get_Context_0__0(TUser.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.Http.HttpContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Context(Microsoft.AspNetCore.Http.HttpContext)
// docid: M:Microsoft.AspNetCore.Identity.SignInManager`1.set_Context(Microsoft.AspNetCore.Http.HttpContext)
    open func set_Context(value : Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Identity_SignInManager_1_void__set_Context_0__1__HttpContext(TUser.get_type_handle(), &__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The  used.
            

    */
    open var ClaimsFactory : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IUserClaimsPrincipalFactory_1<TUser>> {
        get {
            return try! get_ClaimsFactory();
        }
        set(v) {
            return try! set_ClaimsFactory(value: v!);
        }
    }
    /**
    
            The  used.
            

    */
    open var Context : Optional<aspnetcore.Microsoft.AspNetCore.Http.HttpContext> {
        get {
            return try! get_Context();
        }
        set(v) {
            return try! set_Context(value: v!);
        }
    }
    /**
    
            Gets the  used to log messages from the manager.
            

    */
    open var Logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        get {
            return try! get_Logger();
        }
        set(v) {
            return try! set_Logger(value: v!);
        }
    }
    /**
    
            The  used.
            

    */
    open var Options : Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityOptions> {
        get {
            return try! get_Options();
        }
        set(v) {
            return try! set_Options(value: v!);
        }
    }
    /**
    
            The  used.
            

    */
    open var UserManager : Optional<aspnetcore.Microsoft.AspNetCore.Identity.UserManager_1<TUser>> {
        get {
            return try! get_UserManager();
        }
        set(v) {
            return try! set_UserManager(value: v!);
        }
    }
} // SignInManager_1


// type: Microsoft.AspNetCore.Identity.TwoFactorSecurityStampValidator`1
    /**
    
            Responsible for validation of two factor identity cookie security stamp.
            

    */
open class TwoFactorSecurityStampValidator_1<TUser : SGBridgeGenericValue>
    :
    aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidator_1<TUser>,
    Microsoft_AspNetCore_Identity_ITwoFactorSecurityStampValidator
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Identity_TwoFactorSecurityStampValidator_1_get_type_handle(TUser.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions>, Microsoft.AspNetCore.Identity.SignInManager<TUser>, Microsoft.AspNetCore.Authentication.ISystemClock, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.Identity.TwoFactorSecurityStampValidator`1.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions},Microsoft.AspNetCore.Identity.SignInManager{`0},Microsoft.AspNetCore.Authentication.ISystemClock,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a new instance of .
            

    - Parameter options: Used to access the .
    - Parameter signInManager: The .
    - Parameter clock: The system clock.
    - Parameter logger: The logger.
    */
    public override init(options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Identity.SecurityStampValidatorOptions>>, signInManager : aspnetcore.Microsoft.AspNetCore.Identity.SignInManager_1<TUser>, clock : Optional<aspnetcore.Microsoft.AspNetCore.Authentication.ISystemClock>, logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Identity_TwoFactorSecurityStampValidator_1_ctor_0__4__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Identity_SecurityStampValidatorOptions__Microsoft_AspNetCore_Identity_SignInManager_TUser__ISystemClock_ILoggerFactory(TUser.get_type_handle(), &__thrown, (options?.get_handle()), nil, clock?.get_handle() ?? nil, logger?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TwoFactorSecurityStampValidator_1


}



public protocol Microsoft_AspNetCore_Identity_ISecurityStampValidator
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_Identity_ITwoFactorSecurityStampValidator
    :
    Microsoft_AspNetCore_Identity_ISecurityStampValidator
{
}

// EXTENSION METHOD Microsoft.AspNetCore.Identity.IdentityBuilder AddDefaultTokenProviders(Microsoft.AspNetCore.Identity.IdentityBuilder)
extension aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder {
    public func AddDefaultTokenProviders() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilderExtensions.AddDefaultTokenProviders(builder: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Identity.IdentityBuilder AddSignInManager(Microsoft.AspNetCore.Identity.IdentityBuilder)
extension aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder {
    public func AddSignInManager() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilder> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityBuilderExtensions.AddSignInManager(builder: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Identity.IdentityBuilder AddSignInManager<TSignInManager>(Microsoft.AspNetCore.Identity.IdentityBuilder)
// TODO COPE extension method (unused generic param) Microsoft.AspNetCore.Identity.IdentityBuilder AddSignInManager<TSignInManager>(Microsoft.AspNetCore.Identity.IdentityBuilder)

// EXTENSION METHOD Microsoft.AspNetCore.Identity.IdentityCookiesBuilder AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddIdentityCookies() throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(builder: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Identity.IdentityCookiesBuilder AddIdentityCookies(Microsoft.AspNetCore.Authentication.AuthenticationBuilder, System.Action<Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddIdentityCookies(configureCookies : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>>) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(builder: self, configureCookies: configureCookies);
    }
    // delegate closure overload
    public func AddIdentityCookies(configureCookies : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder> {
        let del_configureCookies = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookiesBuilder>(configureCookies);
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddIdentityCookies(builder: self, configureCookies: del_configureCookies);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddApplicationCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddApplicationCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddApplicationCookie(builder: self);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddExternalCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddExternalCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddExternalCookie(builder: self);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddTwoFactorRememberMeCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddTwoFactorRememberMeCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddTwoFactorRememberMeCookie(builder: self);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Options.OptionsBuilder<Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions> AddTwoFactorUserIdCookie(Microsoft.AspNetCore.Authentication.AuthenticationBuilder)
extension aspnetcore.Microsoft.AspNetCore.Authentication.AuthenticationBuilder {
    public func AddTwoFactorUserIdCookie() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<aspnetcore.Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationOptions>> {
        return try aspnetcore.Microsoft.AspNetCore.Identity.IdentityCookieAuthenticationBuilderExtensions.AddTwoFactorUserIdCookie(builder: self);
    }
}

