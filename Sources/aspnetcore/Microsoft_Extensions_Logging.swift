// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions
public struct LoggingServiceCollectionExtensions {
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Adds logging services to the specified .
            

    - Parameter services: The  to add services to.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddLogging(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_LoggingServiceCollectionExtensions_IServiceCollection__AddLogging_0__1__IServiceCollection(&__thrown, services?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.DependencyInjection.IServiceCollection AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Logging.ILoggingBuilder>)
// docid: M:Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.Extensions.Logging.ILoggingBuilder})
    /**
    
            Adds logging services to the specified .
            

    - Parameter services: The  to add services to.
    - Parameter configure: The  configuration delegate.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddLogging(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_LoggingServiceCollectionExtensions_IServiceCollection__AddLogging_0__2__IServiceCollection_System_Action_Microsoft_Extensions_Logging_ILoggingBuilder_(&__thrown, services?.get_handle() ?? nil, (configure?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddLogging(services : Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>, configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configure);
        return try AddLogging(services: services, configure: del_configure);
    }
} // LoggingServiceCollectionExtensions


}

// Microsoft.Extensions.Logging
extension Microsoft.Extensions.Logging {
// type: Microsoft.Extensions.Logging.ActivityTrackingOptions
    /**
    
            Flags to indicate which trace context parts should be included with the logging scopes.
            

    */
public struct ActivityTrackingOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_ActivityTrackingOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions None
    /**
    
            None of the trace context part wil be included in the logging.
            

    */
    public static var None : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_None());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions SpanId
    /**
    
            Span Id will be included in the logging.
            

    */
    public static var SpanId : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_SpanId());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions TraceId
    /**
    
            Trace Id will be included in the logging.
            

    */
    public static var TraceId : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_TraceId());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions ParentId
    /**
    
            Parent Id will be included in the logging.
            

    */
    public static var ParentId : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_ParentId());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions TraceState
    /**
    
            Trace State will be included in the logging.
            

    */
    public static var TraceState : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_TraceState());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions TraceFlags
    /**
    
            Trace flags will be included in the logging.
            

    */
    public static var TraceFlags : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_TraceFlags());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions Tags
    /**
    
            Tags will be included in the logging.
            

    */
    public static var Tags : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_Tags());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Logging.ActivityTrackingOptions Baggage
    /**
    
            Items of baggage will be included in the logging.
            

    */
    public static var Baggage : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: Microsoft_Extensions_Logging_ActivityTrackingOptions_get_Baggage());
            return __return;
        }
    }
} // ActivityTrackingOptions


// type: Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions
public struct FilterLoggingBuilderExtensions {
    // Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder,System.Func{Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter levelFilter: The filter to be added.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_ILoggingBuilder__AddFilter_0__2__ILoggingBuilder_System_Func_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (levelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try AddFilter(builder: builder, levelFilter: del_levelFilter);
    }
    // Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder,System.Func{System.String,Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter categoryLevelFilter: The filter to be added.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, categoryLevelFilter : Optional<dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_ILoggingBuilder__AddFilter_0__2__ILoggingBuilder_System_Func_string_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (categoryLevelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, categoryLevelFilter : @escaping (Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_categoryLevelFilter = try dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(categoryLevelFilter);
        return try AddFilter(builder: builder, categoryLevelFilter: del_categoryLevelFilter);
    }
    // Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder,System.Func{System.String,System.String,Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter filter: The filter to be added.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_ILoggingBuilder__AddFilter_0__2__ILoggingBuilder_System_Func_string_string_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (filter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, filter : @escaping (Optional<dotnet.System.String>, Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_filter = try dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(filter);
        return try AddFilter(builder: builder, filter: del_filter);
    }
    // Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, Microsoft.Extensions.Logging.LogLevel)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder,System.String,Microsoft.Extensions.Logging.LogLevel)
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter category: The category to filter.
    - Parameter level: The level to filter.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, category : Optional<dotnet.System.String>, level : aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_ILoggingBuilder__AddFilter_0__3__ILoggingBuilder_String_LogLevel(&__thrown, builder?.get_handle() ?? nil, category?.get_handle() ?? nil, level.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder,System.String,System.Func{Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter category: The category to filter.
    - Parameter levelFilter: The filter function to apply.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, category : Optional<dotnet.System.String>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_ILoggingBuilder__AddFilter_0__3__ILoggingBuilder_String_System_Func_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, category?.get_handle() ?? nil, (levelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>, category : Optional<dotnet.System.String>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try AddFilter(builder: builder, category: category, levelFilter: del_levelFilter);
    }
    // Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions,System.Func{Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter levelFilter: The filter function to apply.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_LoggerFilterOptions__AddFilter_0__2__LoggerFilterOptions_System_Func_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (levelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try AddFilter(builder: builder, levelFilter: del_levelFilter);
    }
    // Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions,System.Func{System.String,Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter categoryLevelFilter: The filter function to apply.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, categoryLevelFilter : Optional<dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_LoggerFilterOptions__AddFilter_0__2__LoggerFilterOptions_System_Func_string_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (categoryLevelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, categoryLevelFilter : @escaping (Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_categoryLevelFilter = try dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(categoryLevelFilter);
        return try AddFilter(builder: builder, categoryLevelFilter: del_categoryLevelFilter);
    }
    // Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions,System.Func{System.String,System.String,Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter filter: The filter function to apply.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_LoggerFilterOptions__AddFilter_0__2__LoggerFilterOptions_System_Func_string_string_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, (filter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, filter : @escaping (Optional<dotnet.System.String>, Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_filter = try dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(filter);
        return try AddFilter(builder: builder, filter: del_filter);
    }
    // Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, Microsoft.Extensions.Logging.LogLevel)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions,System.String,Microsoft.Extensions.Logging.LogLevel)
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter category: The category to filter.
    - Parameter level: The level to filter.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, category : Optional<dotnet.System.String>, level : aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_LoggerFilterOptions__AddFilter_0__3__LoggerFilterOptions_String_LogLevel(&__thrown, builder?.get_handle() ?? nil, category?.get_handle() ?? nil, level.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions,System.String,System.Func{Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Adds a log filter to the factory.
            

    - Parameter builder: The  to add the filter to.
    - Parameter category: The category to filter.
    - Parameter levelFilter: The filter function to apply.
    - Returns: The  so that additional calls can be chained.

    */
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, category : Optional<dotnet.System.String>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_FilterLoggingBuilderExtensions_LoggerFilterOptions__AddFilter_0__3__LoggerFilterOptions_String_System_Func_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, builder?.get_handle() ?? nil, category?.get_handle() ?? nil, (levelFilter?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func AddFilter(builder : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>, category : Optional<dotnet.System.String>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try AddFilter(builder: builder, category: category, levelFilter: del_levelFilter);
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, Microsoft.Extensions.Logging.LogLevel)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, Microsoft.Extensions.Logging.LogLevel)
// TODO COPE (write_all_methods) (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
} // FilterLoggingBuilderExtensions


// type: Microsoft.Extensions.Logging.ILoggingBuilder
    /**
    
            An interface for configuring logging providers.
            

    */
open class ILoggingBuilder
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_Logging_ILoggingBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_ILoggingBuilder_get_type_handle();
    }
    open class func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_ILoggingBuilder_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.IServiceCollection get_Services()
// docid: M:Microsoft.Extensions.Logging.ILoggingBuilder.get_Services
    open func get_Services() throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_ILoggingBuilder_IServiceCollection__get_Services_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ILoggingBuilder


// type: Microsoft.Extensions.Logging.LoggerFactory
    /**
    
            Produces instances of  classes based on the given providers.
            

    */
open class LoggerFactory
    :
    dotnet.System.Object,
    Microsoft_Extensions_Logging_ILoggerFactory,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_LoggerFactory_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_LoggerFactory_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.#ctor
    /**
    
            Creates a new  instance.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactory_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.Logging.ILoggerProvider>)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILoggerProvider})
    /**
    
            Creates a new  instance.
            

    - Parameter providers: The providers to use in producing  instances.
    */
    public init(providers : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.Logging.ILoggerProvider>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactory_ctor_0__1__System_Collections_Generic_IEnumerable_Microsoft_Extensions_Logging_ILoggerProvider_(&__thrown, (providers?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.Logging.ILoggerProvider>, Microsoft.Extensions.Logging.LoggerFilterOptions)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILoggerProvider},Microsoft.Extensions.Logging.LoggerFilterOptions)
    /**
    
            Creates a new  instance.
            

    - Parameter providers: The providers to use in producing  instances.
    - Parameter filterOptions: The filter options to use.
    */
    public init(providers : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.Logging.ILoggerProvider>>, filterOptions : Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactory_ctor_0__2__System_Collections_Generic_IEnumerable_Microsoft_Extensions_Logging_ILoggerProvider__LoggerFilterOptions(&__thrown, (providers?.get_handle()), filterOptions?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.Logging.ILoggerProvider>, Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.Extensions.Logging.LoggerFilterOptions>)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILoggerProvider},Microsoft.Extensions.Options.IOptionsMonitor{Microsoft.Extensions.Logging.LoggerFilterOptions})
    /**
    
            Creates a new  instance.
            

    - Parameter providers: The providers to use in producing  instances.
    - Parameter filterOption: The filter option to use.
    */
    public init(providers : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.Logging.ILoggerProvider>>, filterOption : Optional<aspnetcore.Microsoft.Extensions.Options.IOptionsMonitor_1<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactory_ctor_0__2__System_Collections_Generic_IEnumerable_Microsoft_Extensions_Logging_ILoggerProvider__Microsoft_Extensions_Options_IOptionsMonitor_Microsoft_Extensions_Logging_LoggerFilterOptions_(&__thrown, (providers?.get_handle()), (filterOption?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.Logging.ILoggerProvider>, Microsoft.Extensions.Options.IOptionsMonitor<Microsoft.Extensions.Logging.LoggerFilterOptions>, Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Logging.LoggerFactoryOptions>)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.Logging.ILoggerProvider},Microsoft.Extensions.Options.IOptionsMonitor{Microsoft.Extensions.Logging.LoggerFilterOptions},Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Logging.LoggerFactoryOptions})
    /**
    
            Creates a new  instance.
            

    - Parameter providers: The providers to use in producing  instances.
    - Parameter filterOption: The filter option to use.
    - Parameter options: The .
    */
    public init(providers : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.Logging.ILoggerProvider>>, filterOption : Optional<aspnetcore.Microsoft.Extensions.Options.IOptionsMonitor_1<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions>>, options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Logging.LoggerFactoryOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactory_ctor_0__3__System_Collections_Generic_IEnumerable_Microsoft_Extensions_Logging_ILoggerProvider__Microsoft_Extensions_Options_IOptionsMonitor_Microsoft_Extensions_Logging_LoggerFilterOptions__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Logging_LoggerFactoryOptions_(&__thrown, (providers?.get_handle()), (filterOption?.get_handle()), (options?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AddProvider(Microsoft.Extensions.Logging.ILoggerProvider)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.AddProvider(Microsoft.Extensions.Logging.ILoggerProvider)
    /**
    
            Adds the given provider to those used in creating  instances.
            

    - Parameter provider: The  to add.
    */
    open /* method final */ func AddProvider(provider : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerProvider>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_LoggerFactory_void__AddProvider_0__1__ILoggerProvider(&__thrown, self.get_handle(), provider?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.Extensions.Logging.ILoggerFactory Create(System.Action<Microsoft.Extensions.Logging.ILoggingBuilder>)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.Create(System.Action{Microsoft.Extensions.Logging.ILoggingBuilder})
    /**
    
            Creates new instance of  configured using provided  delegate.
            

    - Parameter configure: A delegate to configure the .
    - Returns: The  that was created.

    */
    open class func Create(configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFactory_ILoggerFactory__Create_0__1__System_Action_Microsoft_Extensions_Logging_ILoggingBuilder_(&__thrown, (configure?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open class func Create(configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory> {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configure);
        return try Create(configure: del_configure);
    }
    // Microsoft.Extensions.Logging.ILogger CreateLogger(System.String)
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.CreateLogger(System.String)
    /**
    
            Creates an  with the given .
            

    - Parameter categoryName: The category name for messages produced by the logger.
    - Returns: The  that was created.

    */
    open /* method final */ func CreateLogger(categoryName : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFactory_ILogger__CreateLogger_0__1__String(&__thrown, self.get_handle(), categoryName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Logging.ILogger(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.Logging.LoggerFactory.Dispose
    /**
    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_LoggerFactory_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // LoggerFactory


// type: Microsoft.Extensions.Logging.LoggerFactoryOptions
    /**
    
            The options for a LoggerFactory.
            

    */
open class LoggerFactoryOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_LoggerFactoryOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_LoggerFactoryOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Logging.LoggerFactoryOptions.#ctor
    /**
    
            Creates a new  instance.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFactoryOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.ActivityTrackingOptions get_ActivityTrackingOptions()
// docid: M:Microsoft.Extensions.Logging.LoggerFactoryOptions.get_ActivityTrackingOptions
    open func get_ActivityTrackingOptions() throws -> aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFactoryOptions_ActivityTrackingOptions__get_ActivityTrackingOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions(val: __return);
        }
    }
    // [IsSpecialName] void set_ActivityTrackingOptions(Microsoft.Extensions.Logging.ActivityTrackingOptions)
// docid: M:Microsoft.Extensions.Logging.LoggerFactoryOptions.set_ActivityTrackingOptions(Microsoft.Extensions.Logging.ActivityTrackingOptions)
    open func set_ActivityTrackingOptions(value : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_LoggerFactoryOptions_void__set_ActivityTrackingOptions_0__1__ActivityTrackingOptions(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Gets or sets  value to indicate which parts of the tracing context information should be included with the logging scopes.
            

    */
    open var ActivityTrackingOptions : aspnetcore.Microsoft.Extensions.Logging.ActivityTrackingOptions {
        get {
            return try! get_ActivityTrackingOptions();
        }
        set(v) {
            return try! set_ActivityTrackingOptions(value: v);
        }
    }
} // LoggerFactoryOptions


// type: Microsoft.Extensions.Logging.LoggerFilterOptions
    /**
    
            The options for a LoggerFilter.
            

    */
open class LoggerFilterOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_LoggerFilterOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_LoggerFilterOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.#ctor
    /**
    
            Creates a new  instance.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFilterOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_CaptureScopes()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.get_CaptureScopes
    open func get_CaptureScopes() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterOptions_bool__get_CaptureScopes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_CaptureScopes(bool)
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.set_CaptureScopes(System.Boolean)
    open func set_CaptureScopes(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_LoggerFilterOptions_void__set_CaptureScopes_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.Logging.LogLevel get_MinLevel()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.get_MinLevel
    open func get_MinLevel() throws -> aspnetcore.Microsoft.Extensions.Logging.LogLevel {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterOptions_LogLevel__get_MinLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Logging.LogLevel(val: __return);
        }
    }
    // [IsSpecialName] void set_MinLevel(Microsoft.Extensions.Logging.LogLevel)
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.set_MinLevel(Microsoft.Extensions.Logging.LogLevel)
    open func set_MinLevel(value : aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Logging_LoggerFilterOptions_void__set_MinLevel_0__1__LogLevel(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.Logging.LoggerFilterRule> get_Rules()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterOptions.get_Rules
    open func get_Rules() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterRule>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterOptions_System_Collections_Generic_IList_Microsoft_Extensions_Logging_LoggerFilterRule___get_Rules_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets or sets value indicating whether logging scopes are being captured. Defaults to true
            

    */
    open var CaptureScopes : Bool {
        get {
            return try! get_CaptureScopes();
        }
        set(v) {
            return try! set_CaptureScopes(value: v);
        }
    }
    /**
    
            Gets or sets the minimum level of log messages if none of the rules match.
            

    */
    open var MinLevel : aspnetcore.Microsoft.Extensions.Logging.LogLevel {
        get {
            return try! get_MinLevel();
        }
        set(v) {
            return try! set_MinLevel(value: v);
        }
    }
    /**
    
            Gets the collection of  used for filtering log messages.
            

    */
    open var Rules : Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterRule>> {
        get {
            return try! get_Rules();
        }
    }
} // LoggerFilterOptions


// type: Microsoft.Extensions.Logging.LoggerFilterRule
    /**
    
            Defines a rule used to filter log messages
            

    */
open class LoggerFilterRule
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_LoggerFilterRule_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_LoggerFilterRule_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String, System.String, System.Nullable<Microsoft.Extensions.Logging.LogLevel>, System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.#ctor(System.String,System.String,System.Nullable{Microsoft.Extensions.Logging.LogLevel},System.Func{System.String,System.String,Microsoft.Extensions.Logging.LogLevel,System.Boolean})
    /**
    
            Creates a new  instance.
            

    - Parameter providerName: The provider name to use in this filter rule.
    - Parameter categoryName: The category name to use in this filter rule.
    - Parameter logLevel: The  to use in this filter rule.
    - Parameter filter: The filter to apply.
    */
    public init(providerName : Optional<dotnet.System.String>, categoryName : Optional<dotnet.System.String>, logLevel : Optional<aspnetcore.Microsoft.Extensions.Logging.LogLevel>, filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_LoggerFilterRule_ctor_0__4__String_String_System_Nullable_Microsoft_Extensions_Logging_LogLevel__System_Func_string_string_Microsoft_Extensions_Logging_LogLevel_bool_(&__thrown, providerName?.get_handle() ?? nil, categoryName?.get_handle() ?? nil, (logLevel != nil) ? System_Int32_box(logLevel!.get_value()) : nil, (filter?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.ToString
    /**
    */
    open override func ToString() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterRule_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_CategoryName()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.get_CategoryName
    open func get_CategoryName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterRule_String__get_CategoryName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool> get_Filter()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.get_Filter
    open func get_Filter() throws -> Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterRule_System_Func_string_string_Microsoft_Extensions_Logging_LogLevel_bool___get_Filter_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Func_4(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Nullable<Microsoft.Extensions.Logging.LogLevel> get_LogLevel()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.get_LogLevel
    open func get_LogLevel() throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LogLevel> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterRule_System_Nullable_Microsoft_Extensions_Logging_LogLevel___get_LogLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? aspnetcore.Microsoft.Extensions.Logging.LogLevel(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] System.String get_ProviderName()
// docid: M:Microsoft.Extensions.Logging.LoggerFilterRule.get_ProviderName
    open func get_ProviderName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_LoggerFilterRule_String__get_ProviderName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Gets the logger category this rule applies to.
            

    */
    open var CategoryName : Optional<dotnet.System.String> {
        get {
            return try! get_CategoryName();
        }
    }
    /**
    
            Gets the filter delegate that would be applied to messages that passed the .
            

    */
    open var Filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>> {
        get {
            return try! get_Filter();
        }
    }
    /**
    
            Gets the minimum  of messages.
            

    */
    open var LogLevel : Optional<aspnetcore.Microsoft.Extensions.Logging.LogLevel> {
        get {
            return try! get_LogLevel();
        }
    }
    /**
    
            Gets the logger provider type or alias this rule applies to.
            

    */
    open var ProviderName : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderName();
        }
    }
} // LoggerFilterRule


// type: Microsoft.Extensions.Logging.ProviderAliasAttribute
    /**
    
            Defines alias for  implementation to be used in filtering rules.
            

    */
open class ProviderAliasAttribute
    :
    dotnet.System.Attribute
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Logging_ProviderAliasAttribute_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_Extensions_Logging_ProviderAliasAttribute_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(System.String)
// docid: M:Microsoft.Extensions.Logging.ProviderAliasAttribute.#ctor(System.String)
    /**
    
            Creates a new  instance.
            

    - Parameter alias: The alias to set.
    */
    public init(alias : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Logging_ProviderAliasAttribute_ctor_0__1__String(&__thrown, alias?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Alias()
// docid: M:Microsoft.Extensions.Logging.ProviderAliasAttribute.get_Alias
    open func get_Alias() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Logging_ProviderAliasAttribute_String__get_Alias_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            The alias of the provider.
            

    */
    open var Alias : Optional<dotnet.System.String> {
        get {
            return try! get_Alias();
        }
    }
} // ProviderAliasAttribute


}



public protocol Microsoft_Extensions_Logging_ILoggingBuilder
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddLogging() throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.DependencyInjection.IServiceCollection AddLogging(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.Extensions.Logging.ILoggingBuilder>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddLogging(configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func AddLogging(configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection> {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configure);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddFilter(levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), levelFilter: levelFilter);
    }
    // delegate closure overload
    public func AddFilter(levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), levelFilter: del_levelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddFilter(categoryLevelFilter : Optional<dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), categoryLevelFilter: categoryLevelFilter);
    }
    // delegate closure overload
    public func AddFilter(categoryLevelFilter : @escaping (Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_categoryLevelFilter = try dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(categoryLevelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), categoryLevelFilter: del_categoryLevelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddFilter(filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), filter: filter);
    }
    // delegate closure overload
    public func AddFilter(filter : @escaping (Optional<dotnet.System.String>, Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_filter = try dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(filter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), filter: del_filter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, Microsoft.Extensions.Logging.LogLevel)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddFilter(category : Optional<dotnet.System.String>, level : aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), category: category, level: level);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
extension Microsoft_Extensions_Logging_ILoggingBuilder {
    public func AddFilter(category : Optional<dotnet.System.String>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), category: category, levelFilter: levelFilter);
    }
    // delegate closure overload
    public func AddFilter(category : Optional<dotnet.System.String>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder(hndl: __copy_handle(self.get_handle())), category: category, levelFilter: del_levelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
extension aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions {
    public func AddFilter(levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, levelFilter: levelFilter);
    }
    // delegate closure overload
    public func AddFilter(levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, levelFilter: del_levelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
extension aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions {
    public func AddFilter(categoryLevelFilter : Optional<dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, categoryLevelFilter: categoryLevelFilter);
    }
    // delegate closure overload
    public func AddFilter(categoryLevelFilter : @escaping (Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_categoryLevelFilter = try dotnet.System.Func_3<dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(categoryLevelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, categoryLevelFilter: del_categoryLevelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
extension aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions {
    public func AddFilter(filter : Optional<dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, filter: filter);
    }
    // delegate closure overload
    public func AddFilter(filter : @escaping (Optional<dotnet.System.String>, Optional<dotnet.System.String>, aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_filter = try dotnet.System.Func_4<dotnet.System.String,dotnet.System.String,aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(filter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, filter: del_filter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, Microsoft.Extensions.Logging.LogLevel)
extension aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions {
    public func AddFilter(category : Optional<dotnet.System.String>, level : aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, category: category, level: level);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
extension aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions {
    public func AddFilter(category : Optional<dotnet.System.String>, levelFilter : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Bool>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, category: category, levelFilter: levelFilter);
    }
    // delegate closure overload
    public func AddFilter(category : Optional<dotnet.System.String>, levelFilter : @escaping (aspnetcore.Microsoft.Extensions.Logging.LogLevel) throws -> Bool) throws -> Optional<aspnetcore.Microsoft.Extensions.Logging.LoggerFilterOptions> {
        let del_levelFilter = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Logging.LogLevel,Swift.Bool>(levelFilter);
        return try aspnetcore.Microsoft.Extensions.Logging.FilterLoggingBuilderExtensions.AddFilter(builder: self, category: category, levelFilter: del_levelFilter);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, Microsoft.Extensions.Logging.LogLevel)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, Microsoft.Extensions.Logging.LogLevel)

// EXTENSION METHOD Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.ILoggingBuilder AddFilter<T>(Microsoft.Extensions.Logging.ILoggingBuilder, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.Func<System.String,Microsoft.Extensions.Logging.LogLevel,bool>)

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, Microsoft.Extensions.Logging.LogLevel)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, Microsoft.Extensions.Logging.LogLevel)

// EXTENSION METHOD Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)
// TODO COPE extension method (unused generic param) Microsoft.Extensions.Logging.LoggerFilterOptions AddFilter<T>(Microsoft.Extensions.Logging.LoggerFilterOptions, System.String, System.Func<Microsoft.Extensions.Logging.LogLevel,bool>)

