// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.DataProtection
extension Microsoft.AspNetCore.DataProtection {
// type: Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions
public struct DataProtectionBuilderExtensions {
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder SetApplicationName(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.SetApplicationName(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.String)
    /**
    
            Sets the unique name of this application within the data protection system.
            

    - Parameter builder: The .
    - Parameter applicationName: The application name.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func SetApplicationName(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, applicationName : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__SetApplicationName_0__2__IDataProtectionBuilder_String(&__thrown, builder.get_handle(), applicationName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink)
    /**
    
            Registers a  to perform escrow before keys are persisted to storage.
            

    - Parameter builder: The .
    - Parameter sink: The instance of the  to register.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func AddKeyEscrowSink(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, sink : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__AddKeyEscrowSink_0__2__IDataProtectionBuilder_IKeyEscrowSink(&__thrown, builder.get_handle(), sink.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (unused generic param) Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink<TImplementation>(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Func<System.IServiceProvider,Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.Func{System.IServiceProvider,Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink})
    /**
    
            Registers a  to perform escrow before keys are persisted to storage.
            

    - Parameter builder: The .
    - Parameter factory: A factory that creates the  instance.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func AddKeyEscrowSink(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, factory : dotnet.System.Func_2<dotnet.System.IServiceProvider,aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__AddKeyEscrowSink_0__2__IDataProtectionBuilder_System_Func_System_IServiceProvider_Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink_(&__thrown, builder.get_handle(), factory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddKeyEscrowSink(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, factory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_factory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>(factory);
        return try AddKeyEscrowSink(builder: builder, factory: del_factory);
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyManagementOptions(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Action<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyManagementOptions(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.Action{Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions})
    /**
    
            Configures the key management options for the data protection system.
            

    - Parameter builder: The .
    - Parameter setupAction: An  to configure the provided .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func AddKeyManagementOptions(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__AddKeyManagementOptions_0__2__IDataProtectionBuilder_System_Action_Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_(&__thrown, builder.get_handle(), setupAction.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddKeyManagementOptions(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, setupAction : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>(setupAction);
        return try AddKeyManagementOptions(builder: builder, setupAction: del_setupAction);
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder DisableAutomaticKeyGeneration(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.DisableAutomaticKeyGeneration(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
    /**
    
            Configures the data protection system not to generate new keys automatically.
            

    - Parameter builder: The .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func DisableAutomaticKeyGeneration(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__DisableAutomaticKeyGeneration_0__1__IDataProtectionBuilder(&__thrown, builder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder PersistKeysToFileSystem(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.IO.DirectoryInfo)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToFileSystem(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.IO.DirectoryInfo)
    /**
    
            Configures the data protection system to persist keys to the specified directory.
            This path may be on the local machine or may point to a UNC share.
            

    - Parameter builder: The .
    - Parameter directory: The directory in which to store keys.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func PersistKeysToFileSystem(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, directory : dotnet.System.IO.DirectoryInfo) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__PersistKeysToFileSystem_0__2__IDataProtectionBuilder_DirectoryInfo(&__thrown, builder.get_handle(), directory.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder PersistKeysToRegistry(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.Win32.RegistryKey)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToRegistry(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.Win32.RegistryKey)
    /**
    
            Configures the data protection system to persist keys to the Windows registry.
            

    - Parameter builder: The .
    - Parameter registryKey: The location in the registry where keys should be stored.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func PersistKeysToRegistry(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, registryKey : dotnet.Microsoft.Win32.RegistryKey) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__PersistKeysToRegistry_0__2__IDataProtectionBuilder_RegistryKey(&__thrown, builder.get_handle(), registryKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Security.Cryptography.X509Certificates.X509Certificate2)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.Security.Cryptography.X509Certificates.X509Certificate2)
    /**
    
            Configures keys to be encrypted to a given certificate before being persisted to storage.
            

    - Parameter builder: The .
    - Parameter certificate: The certificate to use when encrypting keys.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithCertificate(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithCertificate_0__2__IDataProtectionBuilder_X509Certificate2(&__thrown, builder.get_handle(), certificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.String)
    /**
    
            Configures keys to be encrypted to a given certificate before being persisted to storage.
            

    - Parameter builder: The .
    - Parameter thumbprint: The thumbprint of the certificate to use when encrypting keys.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithCertificate(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, thumbprint : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithCertificate_0__2__IDataProtectionBuilder_String(&__thrown, builder.get_handle(), thumbprint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UnprotectKeysWithAnyCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Security.Cryptography.X509Certificates.X509Certificate2[])
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UnprotectKeysWithAnyCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.Security.Cryptography.X509Certificates.X509Certificate2[])
    /**
    
            Configures certificates which can be used to decrypt keys loaded from storage.
            

    - Parameter builder: The .
    - Parameter certificates: Certificates that can be used to decrypt key data.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UnprotectKeysWithAnyCertificate(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, certificates : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UnprotectKeysWithAnyCertificate_0__2__IDataProtectionBuilder_X509Certificate2Array(&__thrown, builder.get_handle(), certificates.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
    /**
    
            Configures keys to be encrypted with Windows DPAPI before being persisted to
            storage. The encrypted key will only be decryptable by the current Windows user account.
            

    - Parameter builder: The .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithDpapi(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithDpapi_0__1__IDataProtectionBuilder(&__thrown, builder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, bool)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.Boolean)
    /**
    
            Configures keys to be encrypted with Windows DPAPI before being persisted to
            storage.
            

    - Parameter builder: The .
    - Parameter protectToLocalMachine: 'true' if the key should be decryptable by any
            use on the local machine, 'false' if the key should only be decryptable by the current
            Windows user account.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithDpapi(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, protectToLocalMachine : Bool) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithDpapi_0__2__IDataProtectionBuilder_bool(&__thrown, builder.get_handle(), Swift.Int32(protectToLocalMachine ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
    /**
    
            Configures keys to be encrypted with Windows CNG DPAPI before being persisted
            to storage. The keys will be decryptable by the current Windows user account.
            

    - Parameter builder: The .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithDpapiNG(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithDpapiNG_0__1__IDataProtectionBuilder(&__thrown, builder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String, Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,System.String,Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags)
    /**
    
            Configures keys to be encrypted with Windows CNG DPAPI before being persisted to storage.
            

    - Parameter builder: The .
    - Parameter protectionDescriptorRule: The descriptor rule string with which to protect the key material.
    - Parameter flags: Flags that should be passed to the call to 'NCryptCreateProtectionDescriptor'.
            The default value of this parameter is .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func ProtectKeysWithDpapiNG(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, protectionDescriptorRule : dotnet.System.String, flags : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__ProtectKeysWithDpapiNG_0__3__IDataProtectionBuilder_String_DpapiNGProtectionDescriptorFlags(&__thrown, builder.get_handle(), protectionDescriptorRule.get_handle(), flags.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder SetDefaultKeyLifetime(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.TimeSpan)
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration)
    /**
    
            Configures the data protection system to use the specified cryptographic algorithms
            by default when generating protected payloads.
            

    - Parameter builder: The .
    - Parameter configuration: Information about what cryptographic algorithms should be used.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UseCryptographicAlgorithms(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UseCryptographicAlgorithms_0__2__IDataProtectionBuilder_AuthenticatedEncryptorConfiguration(&__thrown, builder.get_handle(), configuration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration)
    /**
    
            Configures the data protection system to use custom Windows CNG algorithms.
            This API is intended for advanced scenarios where the developer cannot use the
            algorithms specified in the  and
             enumerations.
            

    - Parameter builder: The .
    - Parameter configuration: Information about what cryptographic algorithms should be used.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UseCustomCryptographicAlgorithms(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UseCustomCryptographicAlgorithms_0__2__IDataProtectionBuilder_CngCbcAuthenticatedEncryptorConfiguration(&__thrown, builder.get_handle(), configuration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration)
    /**
    
            Configures the data protection system to use custom Windows CNG algorithms.
            This API is intended for advanced scenarios where the developer cannot use the
            algorithms specified in the  and
             enumerations.
            

    - Parameter builder: The .
    - Parameter configuration: Information about what cryptographic algorithms should be used.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UseCustomCryptographicAlgorithms(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UseCustomCryptographicAlgorithms_0__2__IDataProtectionBuilder_CngGcmAuthenticatedEncryptorConfiguration(&__thrown, builder.get_handle(), configuration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder,Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration)
    /**
    
            Configures the data protection system to use custom algorithms.
            This API is intended for advanced scenarios where the developer cannot use the
            algorithms specified in the  and
             enumerations.
            

    - Parameter builder: The .
    - Parameter configuration: Information about what cryptographic algorithms should be used.
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UseCustomCryptographicAlgorithms(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UseCustomCryptographicAlgorithms_0__2__IDataProtectionBuilder_ManagedAuthenticatedEncryptorConfiguration(&__thrown, builder.get_handle(), configuration.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseEphemeralDataProtectionProvider(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseEphemeralDataProtectionProvider(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
    /**
    
            Configures the data protection system to use the 
            for data protection services.
            

    - Parameter builder: The .
    - Returns: A reference to the  after this operation has completed.

    */
    public static func UseEphemeralDataProtectionProvider(builder : aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionBuilderExtensions_IDataProtectionBuilder__UseEphemeralDataProtectionProvider_0__1__IDataProtectionBuilder(&__thrown, builder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
} // DataProtectionBuilderExtensions


// type: Microsoft.AspNetCore.DataProtection.DataProtectionOptions
    /**
    
            Provides global options for the Data Protection system.
            

    */
open class DataProtectionOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_DataProtectionOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_DataProtectionOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_ApplicationDiscriminator()
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionOptions.get_ApplicationDiscriminator
    open func get_ApplicationDiscriminator() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionOptions_String__get_ApplicationDiscriminator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ApplicationDiscriminator(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionOptions.set_ApplicationDiscriminator(System.String)
    open func set_ApplicationDiscriminator(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_DataProtectionOptions_void__set_ApplicationDiscriminator_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            An identifier that uniquely discriminates this application from all other
            applications on the machine. The discriminator value is implicitly included
            in all protected payloads generated by the data protection system to isolate
            multiple logical applications that all happen to be using the same key material.
            

    */
    open var ApplicationDiscriminator : Optional<dotnet.System.String> {
        get {
            return try! get_ApplicationDiscriminator();
        }
        set(v) {
            return try! set_ApplicationDiscriminator(value: v!);
        }
    }
} // DataProtectionOptions


// type: Microsoft.AspNetCore.DataProtection.DataProtectionUtilityExtensions
public struct DataProtectionUtilityExtensions {
    // System.String GetApplicationUniqueIdentifier(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.DataProtection.DataProtectionUtilityExtensions.GetApplicationUniqueIdentifier(System.IServiceProvider)
    /**
    
            Returns a unique identifier for this application.
            

    - Parameter services: The application-level .
    - Returns: A unique application identifier, or null if  is null
            or cannot provide a unique application identifier.

    */
    public static func GetApplicationUniqueIdentifier(services : dotnet.System.IServiceProvider) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_DataProtectionUtilityExtensions_String__GetApplicationUniqueIdentifier_0__1__IServiceProvider(&__thrown, services.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DataProtectionUtilityExtensions


// type: Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider
    /**
    
            An  that is transient.
            

    */
public final class EphemeralDataProtectionProvider
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_IDataProtectionProvider
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_EphemeralDataProtectionProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.#ctor
    /**
    
            Creates an ephemeral .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_EphemeralDataProtectionProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates an ephemeral  with logging.
            

    - Parameter loggerFactory: The .
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_EphemeralDataProtectionProvider_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtector CreateProtector(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.EphemeralDataProtectionProvider.CreateProtector(System.String)
    /**
    */
    public func CreateProtector(purpose : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtector {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_EphemeralDataProtectionProvider_IDataProtector__CreateProtector_0__1__String(&__thrown, self.get_handle(), purpose.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtector(hndl : __return);
        }
    }
} // EphemeralDataProtectionProvider


// type: Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder
    /**
    
            Provides access to configuration for the data protection system, which allows the
            developer to configure default cryptographic algorithms, key storage locations,
            and the mechanism by which keys are protected at rest.
            

    */
open class IDataProtectionBuilder
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] Microsoft.Extensions.DependencyInjection.IServiceCollection get_Services()
// docid: M:Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder.get_Services
    open func get_Services() throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder_IServiceCollection__get_Services_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl : __return);
        }
    }
} // IDataProtectionBuilder


// type: Microsoft.AspNetCore.DataProtection.IPersistedDataProtector
    /**
    
            An interface that can provide data protection services for data which has been persisted
            to long-term storage.
            

    */
open class IPersistedDataProtector
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_IPersistedDataProtector,
    Microsoft_AspNetCore_DataProtection_IDataProtector
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_IPersistedDataProtector_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Byte[] DangerousUnprotect(System.Byte[], bool, ref bool, ref bool)
// docid: M:Microsoft.AspNetCore.DataProtection.IPersistedDataProtector.DangerousUnprotect(System.Byte[],System.Boolean,System.Boolean@,System.Boolean@)
    /**
    
            Cryptographically unprotects a piece of data, optionally ignoring failures due to
            revocation of the cryptographic keys used to protect the payload.
            

    - Parameter protectedData: The protected data to unprotect.
    - Parameter ignoreRevocationErrors: 'true' if the payload should be unprotected even
            if the cryptographic key used to protect it has been revoked (due to potential compromise),
            'false' if revocation should fail the unprotect operation.
    - Parameter requiresMigration: 'true' if the data should be reprotected before being
            persisted back to long-term storage, 'false' otherwise. Migration might be requested
            when the default protection key has changed, for instance.
    - Parameter wasRevoked: 'true' if the cryptographic key used to protect this payload
            has been revoked, 'false' otherwise. Payloads whose keys have been revoked should be
            treated as suspect unless the application has separate assurance that the payload
            has not been tampered with.
    - Returns: The plaintext form of the protected data.

    */
    open func DangerousUnprotect(protectedData : dotnet.System_Arr<Swift.UInt8>, ignoreRevocationErrors : Bool, requiresMigration : inout Bool, wasRevoked : inout Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_requiresMigration = Swift.Int32(requiresMigration ? 1 : 0);
            var _tmp_out_wasRevoked = Swift.Int32(wasRevoked ? 1 : 0);
        let __return = Microsoft_AspNetCore_DataProtection_IPersistedDataProtector_u8Array__DangerousUnprotect_0__4__u8Array_bool_outbool_outbool(&__thrown, self.get_handle(), protectedData.get_handle(), Swift.Int32(ignoreRevocationErrors ? 1 : 0), &_tmp_out_requiresMigration, &_tmp_out_wasRevoked);
        let _tmp2_requiresMigration = (_tmp_out_requiresMigration) != 0;
            requiresMigration = _tmp2_requiresMigration;
        let _tmp2_wasRevoked = (_tmp_out_wasRevoked) != 0;
            wasRevoked = _tmp2_wasRevoked;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // IPersistedDataProtector


// type: Microsoft.AspNetCore.DataProtection.ISecret
    /**
    
            Represents a secret value.
            

    */
open class ISecret
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_ISecret,
    System_IDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_ISecret_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void WriteSecretIntoBuffer(System.ArraySegment<System.Byte>)
// docid: M:Microsoft.AspNetCore.DataProtection.ISecret.WriteSecretIntoBuffer(System.ArraySegment{System.Byte})
    /**
    
            Writes the secret value to the specified buffer.
            

    - Parameter buffer: The buffer which should receive the secret value.
    */
    open func WriteSecretIntoBuffer(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_ISecret_void__WriteSecretIntoBuffer_0__1__System_ArraySegment_u8_(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Length()
// docid: M:Microsoft.AspNetCore.DataProtection.ISecret.get_Length
    open func get_Length() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_ISecret_i32__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // ISecret


// type: Microsoft.AspNetCore.DataProtection.Secret
    /**
    
            Represents a secret value stored in memory.
            

    */
public final class Secret
    :
    dotnet.System.Object,
    System_IDisposable,
    Microsoft_AspNetCore_DataProtection_ISecret
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_Secret_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.ArraySegment<System.Byte>)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.#ctor(System.ArraySegment{System.Byte})
    /**
    
            Creates a new Secret from the provided input value, where the input value
            is specified as an array segment.
            

    */
    public init(value : dotnet.System.ArraySegment_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Secret_ctor_0__1__System_ArraySegment_u8_(&__thrown, value.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.#ctor(System.Byte[])
    /**
    
            Creates a new Secret from the provided input value, where the input value
            is specified as an array.
            

    */
    public init(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Secret_ctor_0__1__u8Array(&__thrown, value.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte*, System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.#ctor(System.Byte*,System.Int32)
    /**
    
            Creates a new Secret from the provided input value, where the input value
            is specified as a pointer to unmanaged memory.
            

    */
    public init(secret : UnsafeMutablePointer<Swift.UInt8>?, secretLength : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Secret_ctor_0__2__pu8_i32(&__thrown, secret, secretLength);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.AspNetCore.DataProtection.ISecret)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.#ctor(Microsoft.AspNetCore.DataProtection.ISecret)
    /**
    
            Creates a new Secret from another secret object.
            

    */
    public init(secret : aspnetcore.Microsoft.AspNetCore.DataProtection.ISecret) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Secret_ctor_0__1__ISecret(&__thrown, secret.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.Dispose
    /**
    
            Wipes the secret from memory.
            

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Secret_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.AspNetCore.DataProtection.Secret Random(System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.Random(System.Int32)
    /**
    
            Returns a Secret made entirely of random bytes retrieved from
            a cryptographically secure RNG.
            

    */
    public class func Random(numBytes : Swift.Int32) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.Secret {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Secret_Secret__Random_0__1__i32(&__thrown, numBytes);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.Secret(hndl : __return);
        }
    }
    // void WriteSecretIntoBuffer(System.ArraySegment<System.Byte>)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.WriteSecretIntoBuffer(System.ArraySegment{System.Byte})
    /**
    
            Writes the secret value to the specified buffer.
            

    */
    public func WriteSecretIntoBuffer(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Secret_void__WriteSecretIntoBuffer_0__1__System_ArraySegment_u8_(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void WriteSecretIntoBuffer(System.Byte*, System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.WriteSecretIntoBuffer(System.Byte*,System.Int32)
    /**
    
            Writes the secret value to the specified buffer.
            

    - Parameter buffer: The buffer into which to write the secret value.
    - Parameter bufferLength: The size (in bytes) of the provided buffer.
    */
    public func WriteSecretIntoBuffer(buffer : UnsafeMutablePointer<Swift.UInt8>?, bufferLength : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Secret_void__WriteSecretIntoBuffer_0__2__pu8_i32(&__thrown, self.get_handle(), buffer, bufferLength);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Length()
// docid: M:Microsoft.AspNetCore.DataProtection.Secret.get_Length
    public func get_Length() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Secret_i32__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    
            The length (in bytes) of the secret value.
            

    */
    public var Length : Swift.Int32 {
        get {
            return try! get_Length();
        }
    }
} // Secret


}
// Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption
extension Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption {
// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory
    /**
    
            An  to create an 
            based on the .
            

    */
public final class AuthenticatedEncryptorFactory
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_AuthenticatedEncryptorFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Initializes a new instance of .
            

    - Parameter loggerFactory: The .
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_AuthenticatedEncryptorFactory_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.AuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
    /**
    */
    public func CreateEncryptorInstance(key : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_AuthenticatedEncryptorFactory_IAuthenticatedEncryptor__CreateEncryptorInstance_0__1__IKey(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // AuthenticatedEncryptorFactory


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory
    /**
    
            An  for .
            

    */
public final class CngCbcAuthenticatedEncryptorFactory
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngCbcAuthenticatedEncryptorFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Initializes a new instance of .
            

    - Parameter loggerFactory: The .
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngCbcAuthenticatedEncryptorFactory_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngCbcAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
    /**
    */
    public func CreateEncryptorInstance(key : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngCbcAuthenticatedEncryptorFactory_IAuthenticatedEncryptor__CreateEncryptorInstance_0__1__IKey(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // CngCbcAuthenticatedEncryptorFactory


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory
    /**
    
            An  for .
            

    */
public final class CngGcmAuthenticatedEncryptorFactory
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngGcmAuthenticatedEncryptorFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Initializes a new instance of .
            

    - Parameter loggerFactory: The .
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngGcmAuthenticatedEncryptorFactory_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.CngGcmAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
    /**
    */
    public func CreateEncryptorInstance(key : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_CngGcmAuthenticatedEncryptorFactory_IAuthenticatedEncryptor__CreateEncryptorInstance_0__1__IKey(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // CngGcmAuthenticatedEncryptorFactory


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm
    /**
    
            Specifies a symmetric encryption algorithm to use for providing confidentiality
            to protected payloads.
            

    */
public struct EncryptionAlgorithm : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_128_CBC
    /**
    
            The AES algorithm (FIPS 197) with a 128-bit key running in Cipher Block Chaining mode.
            

    */
    public static var AES_128_CBC : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_128_CBC());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_192_CBC
    /**
    
            The AES algorithm (FIPS 197) with a 192-bit key running in Cipher Block Chaining mode.
            

    */
    public static var AES_192_CBC : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_192_CBC());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_256_CBC
    /**
    
            The AES algorithm (FIPS 197) with a 256-bit key running in Cipher Block Chaining mode.
            

    */
    public static var AES_256_CBC : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_256_CBC());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_128_GCM
    /**
    
            The AES algorithm (FIPS 197) with a 128-bit key running in Galois/Counter Mode (FIPS SP 800-38D).
            

    */
    public static var AES_128_GCM : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_128_GCM());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_192_GCM
    /**
    
            The AES algorithm (FIPS 197) with a 192-bit key running in Galois/Counter Mode (FIPS SP 800-38D).
            

    */
    public static var AES_192_GCM : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_192_GCM());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm AES_256_GCM
    /**
    
            The AES algorithm (FIPS 197) with a 256-bit key running in Galois/Counter Mode (FIPS SP 800-38D).
            

    */
    public static var AES_256_GCM : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_EncryptionAlgorithm_get_AES_256_GCM());
            return __return;
        }
    }
} // EncryptionAlgorithm


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor
    /**
    
            The basic interface for providing an authenticated encryption and decryption routine.
            

    */
open class IAuthenticatedEncryptor
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptor
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptor_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Byte[] Decrypt(System.ArraySegment<System.Byte>, System.ArraySegment<System.Byte>)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor.Decrypt(System.ArraySegment{System.Byte},System.ArraySegment{System.Byte})
    /**
    
            Validates the authentication tag of and decrypts a blob of encrypted data.
            

    - Parameter ciphertext: The ciphertext (including authentication tag) to decrypt.
    - Parameter additionalAuthenticatedData: Any ancillary data which was used during computation
            of the authentication tag. The same AAD must have been specified in the corresponding
            call to 'Encrypt'.
    - Returns: The original plaintext data (if the authentication tag was validated and decryption succeeded).

    */
    open func Decrypt(ciphertext : dotnet.System.ArraySegment_1<Swift.UInt8>, additionalAuthenticatedData : dotnet.System.ArraySegment_1<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptor_u8Array__Decrypt_0__2__System_ArraySegment_u8__System_ArraySegment_u8_(&__thrown, self.get_handle(), ciphertext.get_handle(), additionalAuthenticatedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.ArraySegment<System.Byte>, System.ArraySegment<System.Byte>)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor.Encrypt(System.ArraySegment{System.Byte},System.ArraySegment{System.Byte})
    /**
    
            Encrypts and tamper-proofs a piece of data.
            

    - Parameter plaintext: The plaintext to encrypt. This input may be zero bytes in length.
    - Parameter additionalAuthenticatedData: A piece of data which will not be included in
            the returned ciphertext but which will still be covered by the authentication tag.
            This input may be zero bytes in length. The same AAD must be specified in the corresponding
            call to Decrypt.
    - Returns: The ciphertext blob, including authentication tag.

    */
    open func Encrypt(plaintext : dotnet.System.ArraySegment_1<Swift.UInt8>, additionalAuthenticatedData : dotnet.System.ArraySegment_1<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptor_u8Array__Encrypt_0__2__System_ArraySegment_u8__System_ArraySegment_u8_(&__thrown, self.get_handle(), plaintext.get_handle(), additionalAuthenticatedData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // IAuthenticatedEncryptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory
    /**
    
            A factory to produce  instances.
            

    */
open class IAuthenticatedEncryptorFactory
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
    /**
    
            Creates an  instance based on the given .
            

    - Returns: An  instance.

    */
    open func CreateEncryptorInstance(key : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory_IAuthenticatedEncryptor__CreateEncryptorInstance_0__1__IKey(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IAuthenticatedEncryptorFactory


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory
    /**
    
            An  for .
            

    */
public final class ManagedAuthenticatedEncryptorFactory
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ManagedAuthenticatedEncryptorFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Initializes a new instance of .
            

    - Parameter loggerFactory: The .
    */
    public init(loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ManagedAuthenticatedEncryptorFactory_ctor_0__1__ILoggerFactory(&__thrown, loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ManagedAuthenticatedEncryptorFactory.CreateEncryptorInstance(Microsoft.AspNetCore.DataProtection.KeyManagement.IKey)
    /**
    */
    public func CreateEncryptorInstance(key : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ManagedAuthenticatedEncryptorFactory_IAuthenticatedEncryptor__CreateEncryptorInstance_0__1__IKey(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ManagedAuthenticatedEncryptorFactory


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm
    /**
    
            Specifies a message authentication algorithm to use for providing tamper-proofing
            to protected payloads.
            

    */
public struct ValidationAlgorithm : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ValidationAlgorithm_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm HMACSHA256
    /**
    
            The HMAC algorithm (RFC 2104) using the SHA-256 hash function (FIPS 180-4).
            

    */
    public static var HMACSHA256 : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ValidationAlgorithm_get_HMACSHA256());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm HMACSHA512
    /**
    
            The HMAC algorithm (RFC 2104) using the SHA-512 hash function (FIPS 180-4).
            

    */
    public static var HMACSHA512 : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm(val: Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ValidationAlgorithm_get_HMACSHA512());
            return __return;
        }
    }
} // ValidationAlgorithm


}
// Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel
extension Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel {
// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration
    /**
    
            A factory for producing .
            

    */
open class AlgorithmConfiguration
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AlgorithmConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor CreateNewDescriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration.CreateNewDescriptor
    /**
    
            Creates a new  instance based on this
            configuration. The newly-created instance contains unique key material and is distinct
            from all other descriptors created by the  method.
            

    - Returns: A unique .

    */
    open func CreateNewDescriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AlgorithmConfiguration_IAuthenticatedEncryptorDescriptor__CreateNewDescriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // AlgorithmConfiguration


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration
    /**
    
            Represents a generalized authenticated encryption mechanism.
            

    */
public final class AuthenticatedEncryptorConfiguration
    :
    aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor CreateNewDescriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.CreateNewDescriptor
    /**
    */
    public override func CreateNewDescriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_IAuthenticatedEncryptorDescriptor__CreateNewDescriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm get_EncryptionAlgorithm()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.get_EncryptionAlgorithm
    public func get_EncryptionAlgorithm() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_EncryptionAlgorithm__get_EncryptionAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm(val: __return);
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithm(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.set_EncryptionAlgorithm(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm)
    public func set_EncryptionAlgorithm(value : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithm_0__1__EncryptionAlgorithm(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm get_ValidationAlgorithm()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.get_ValidationAlgorithm
    public func get_ValidationAlgorithm() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_ValidationAlgorithm__get_ValidationAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm(val: __return);
        }
    }
    // [IsSpecialName] void set_ValidationAlgorithm(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration.set_ValidationAlgorithm(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm)
    public func set_ValidationAlgorithm(value : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorConfiguration_void__set_ValidationAlgorithm_0__1__ValidationAlgorithm(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The algorithm to use for symmetric encryption (confidentiality).
            

    */
    public var EncryptionAlgorithm : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.EncryptionAlgorithm {
        get {
            return try! get_EncryptionAlgorithm();
        }
        set(v) {
            return try! set_EncryptionAlgorithm(value: v);
        }
    }
    /**
    
            The algorithm to use for message authentication (tamper-proofing).
            

    */
    public var ValidationAlgorithm : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ValidationAlgorithm {
        get {
            return try! get_ValidationAlgorithm();
        }
        set(v) {
            return try! set_ValidationAlgorithm(value: v);
        }
    }
} // AuthenticatedEncryptorConfiguration


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptor
    /**
    
            A descriptor which can create an authenticated encryption system based upon the
            configuration provided by an  object.
            

    */
public final class AuthenticatedEncryptorDescriptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration, Microsoft.AspNetCore.DataProtection.ISecret)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptor.#ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration,Microsoft.AspNetCore.DataProtection.ISecret)
    /**
    
            Initializes a new instance of .
            

    - Parameter configuration: The .
    - Parameter masterKey: The master key.
    */
    public init(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration, masterKey : aspnetcore.Microsoft.AspNetCore.DataProtection.ISecret) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptor_ctor_0__2__AuthenticatedEncryptorConfiguration_ISecret(&__thrown, configuration.get_handle(), masterKey.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo ExportToXml()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptor.ExportToXml
    /**
    */
    public func ExportToXml() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptor_XmlSerializedDescriptorInfo__ExportToXml_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo(hndl : __return);
        }
    }
} // AuthenticatedEncryptorDescriptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer
    /**
    
            A class that can deserialize an  that represents the serialized version
            of an .
            

    */
public final class AuthenticatedEncryptorDescriptorDeserializer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptorDeserializer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptorDeserializer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor ImportFromXml(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer.ImportFromXml(System.Xml.Linq.XElement)
    /**
    
            Imports the  from serialized XML.
            

    */
    public func ImportFromXml(element : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_AuthenticatedEncryptorDescriptorDeserializer_IAuthenticatedEncryptorDescriptor__ImportFromXml_0__1__XElement(&__thrown, self.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // AuthenticatedEncryptorDescriptorDeserializer


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration
    /**
    
            Represents a configured authenticated encryption mechanism which uses
            Windows CNG algorithms in CBC encryption + HMAC authentication modes.
            

    */
public final class CngCbcAuthenticatedEncryptorConfiguration
    :
    aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor CreateNewDescriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.CreateNewDescriptor
    /**
    */
    public override func CreateNewDescriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_IAuthenticatedEncryptorDescriptor__CreateNewDescriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_EncryptionAlgorithm()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithm
    public func get_EncryptionAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_String__get_EncryptionAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithm(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithm(System.String)
    public func set_EncryptionAlgorithm(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithm_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_EncryptionAlgorithmProvider()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmProvider
    public func get_EncryptionAlgorithmProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_String__get_EncryptionAlgorithmProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmProvider(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmProvider(System.String)
    public func set_EncryptionAlgorithmProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_EncryptionAlgorithmKeySize()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmKeySize
    public func get_EncryptionAlgorithmKeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_i32__get_EncryptionAlgorithmKeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmKeySize(System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmKeySize(System.Int32)
    public func set_EncryptionAlgorithmKeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmKeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_HashAlgorithm()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.get_HashAlgorithm
    public func get_HashAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_String__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashAlgorithm(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.set_HashAlgorithm(System.String)
    public func set_HashAlgorithm(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_void__set_HashAlgorithm_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_HashAlgorithmProvider()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.get_HashAlgorithmProvider
    public func get_HashAlgorithmProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_String__get_HashAlgorithmProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_HashAlgorithmProvider(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration.set_HashAlgorithmProvider(System.String)
    public func set_HashAlgorithmProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorConfiguration_void__set_HashAlgorithmProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The name of the algorithm to use for symmetric encryption.
            This property corresponds to the 'pszAlgId' parameter of BCryptOpenAlgorithmProvider.
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithm : dotnet.System.String {
        get {
            return try! get_EncryptionAlgorithm();
        }
        set(v) {
            return try! set_EncryptionAlgorithm(value: v);
        }
    }
    /**
    
            The length (in bits) of the key that will be used for symmetric encryption.
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithmKeySize : Swift.Int32 {
        get {
            return try! get_EncryptionAlgorithmKeySize();
        }
        set(v) {
            return try! set_EncryptionAlgorithmKeySize(value: v);
        }
    }
    /**
    
            The name of the provider which contains the implementation of the symmetric encryption algorithm.
            This property corresponds to the 'pszImplementation' parameter of BCryptOpenAlgorithmProvider.
            This property is optional.
            

    */
    public var EncryptionAlgorithmProvider : Optional<dotnet.System.String> {
        get {
            return try! get_EncryptionAlgorithmProvider();
        }
        set(v) {
            return try! set_EncryptionAlgorithmProvider(value: v!);
        }
    }
    /**
    
            The name of the algorithm to use for hashing data.
            This property corresponds to the 'pszAlgId' parameter of BCryptOpenAlgorithmProvider.
            This property is required to have a value.
            

    */
    public var HashAlgorithm : dotnet.System.String {
        get {
            return try! get_HashAlgorithm();
        }
        set(v) {
            return try! set_HashAlgorithm(value: v);
        }
    }
    /**
    
            The name of the provider which contains the implementation of the hash algorithm.
            This property corresponds to the 'pszImplementation' parameter of BCryptOpenAlgorithmProvider.
            This property is optional.
            

    */
    public var HashAlgorithmProvider : Optional<dotnet.System.String> {
        get {
            return try! get_HashAlgorithmProvider();
        }
        set(v) {
            return try! set_HashAlgorithmProvider(value: v!);
        }
    }
} // CngCbcAuthenticatedEncryptorConfiguration


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptor
    /**
    
            A descriptor which can create an authenticated encryption system based upon the
            configuration provided by an  object.
            

    */
public final class CngCbcAuthenticatedEncryptorDescriptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration, Microsoft.AspNetCore.DataProtection.ISecret)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptor.#ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration,Microsoft.AspNetCore.DataProtection.ISecret)
    /**
    
            Initializes a new instance of .
            

    - Parameter configuration: The .
    - Parameter masterKey: The master key.
    */
    public init(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration, masterKey : aspnetcore.Microsoft.AspNetCore.DataProtection.ISecret) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptor_ctor_0__2__CngCbcAuthenticatedEncryptorConfiguration_ISecret(&__thrown, configuration.get_handle(), masterKey.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo ExportToXml()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptor.ExportToXml
    /**
    */
    public func ExportToXml() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptor_XmlSerializedDescriptorInfo__ExportToXml_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo(hndl : __return);
        }
    }
} // CngCbcAuthenticatedEncryptorDescriptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptorDeserializer
    /**
    
            A class that can deserialize an  that represents the serialized version
            of an .
            

    */
public final class CngCbcAuthenticatedEncryptorDescriptorDeserializer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptorDeserializer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptorDeserializer.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptorDeserializer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor ImportFromXml(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorDescriptorDeserializer.ImportFromXml(System.Xml.Linq.XElement)
    /**
    
            Imports the  from serialized XML.
            

    */
    public func ImportFromXml(element : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngCbcAuthenticatedEncryptorDescriptorDeserializer_IAuthenticatedEncryptorDescriptor__ImportFromXml_0__1__XElement(&__thrown, self.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // CngCbcAuthenticatedEncryptorDescriptorDeserializer


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration
    /**
    
            Represents a configured authenticated encryption mechanism which uses
            Windows CNG algorithms in GCM encryption + authentication modes.
            

    */
public final class CngGcmAuthenticatedEncryptorConfiguration
    :
    aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor CreateNewDescriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.CreateNewDescriptor
    /**
    */
    public override func CreateNewDescriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_IAuthenticatedEncryptorDescriptor__CreateNewDescriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_EncryptionAlgorithm()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithm
    public func get_EncryptionAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_String__get_EncryptionAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithm(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithm(System.String)
    public func set_EncryptionAlgorithm(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithm_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_EncryptionAlgorithmProvider()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmProvider
    public func get_EncryptionAlgorithmProvider() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_String__get_EncryptionAlgorithmProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmProvider(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmProvider(System.String)
    public func set_EncryptionAlgorithmProvider(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmProvider_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_EncryptionAlgorithmKeySize()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmKeySize
    public func get_EncryptionAlgorithmKeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_i32__get_EncryptionAlgorithmKeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmKeySize(System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmKeySize(System.Int32)
    public func set_EncryptionAlgorithmKeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmKeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The name of the algorithm to use for symmetric encryption.
            This property corresponds to the 'pszAlgId' parameter of BCryptOpenAlgorithmProvider.
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithm : dotnet.System.String {
        get {
            return try! get_EncryptionAlgorithm();
        }
        set(v) {
            return try! set_EncryptionAlgorithm(value: v);
        }
    }
    /**
    
            The length (in bits) of the key that will be used for symmetric encryption.
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithmKeySize : Swift.Int32 {
        get {
            return try! get_EncryptionAlgorithmKeySize();
        }
        set(v) {
            return try! set_EncryptionAlgorithmKeySize(value: v);
        }
    }
    /**
    
            The name of the provider which contains the implementation of the symmetric encryption algorithm.
            This property corresponds to the 'pszImplementation' parameter of BCryptOpenAlgorithmProvider.
            This property is optional.
            

    */
    public var EncryptionAlgorithmProvider : Optional<dotnet.System.String> {
        get {
            return try! get_EncryptionAlgorithmProvider();
        }
        set(v) {
            return try! set_EncryptionAlgorithmProvider(value: v!);
        }
    }
} // CngGcmAuthenticatedEncryptorConfiguration


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptor
    /**
    
            A descriptor which can create an authenticated encryption system based upon the
            configuration provided by an  object.
            

    */
public final class CngGcmAuthenticatedEncryptorDescriptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration, Microsoft.AspNetCore.DataProtection.ISecret)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptor.#ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration,Microsoft.AspNetCore.DataProtection.ISecret)
    /**
    
            Initializes a new instance of .
            

    - Parameter configuration: The .
    - Parameter masterKey: The master key.
    */
    public init(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration, masterKey : aspnetcore.Microsoft.AspNetCore.DataProtection.ISecret) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptor_ctor_0__2__CngGcmAuthenticatedEncryptorConfiguration_ISecret(&__thrown, configuration.get_handle(), masterKey.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo ExportToXml()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptor.ExportToXml
    /**
    */
    public func ExportToXml() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptor_XmlSerializedDescriptorInfo__ExportToXml_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo(hndl : __return);
        }
    }
} // CngGcmAuthenticatedEncryptorDescriptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptorDeserializer
    /**
    
            A class that can deserialize an  that represents the serialized version
            of an .
            

    */
public final class CngGcmAuthenticatedEncryptorDescriptorDeserializer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptorDeserializer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptorDeserializer.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptorDeserializer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor ImportFromXml(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorDescriptorDeserializer.ImportFromXml(System.Xml.Linq.XElement)
    /**
    
            Imports the  from serialized XML.
            

    */
    public func ImportFromXml(element : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_CngGcmAuthenticatedEncryptorDescriptorDeserializer_IAuthenticatedEncryptorDescriptor__ImportFromXml_0__1__XElement(&__thrown, self.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // CngGcmAuthenticatedEncryptorDescriptorDeserializer


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor
    /**
    
            A self-contained descriptor that wraps all information (including secret key
            material) necessary to create an instance of an .
            

    */
open class IAuthenticatedEncryptorDescriptor
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo ExportToXml()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor.ExportToXml
    /**
    
            Exports the current descriptor to XML.
            

    - Returns: 
            An  wrapping the  which represents the serialized
            current descriptor object. The deserializer type must be assignable to .
            

    */
    open func ExportToXml() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor_XmlSerializedDescriptorInfo__ExportToXml_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo(hndl : __return);
        }
    }
} // IAuthenticatedEncryptorDescriptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptorDeserializer
    /**
    
            The basic interface for deserializing an XML element into an .
            

    */
open class IAuthenticatedEncryptorDescriptorDeserializer
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor ImportFromXml(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptorDeserializer.ImportFromXml(System.Xml.Linq.XElement)
    /**
    
            Deserializes the specified XML element.
            

    - Parameter element: The element to deserialize.
    - Returns: The  represented by .

    */
    open func ImportFromXml(element : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer_IAuthenticatedEncryptorDescriptor__ImportFromXml_0__1__XElement(&__thrown, self.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // IAuthenticatedEncryptorDescriptorDeserializer


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration
    /**
    
            Represents a configured authenticated encryption mechanism which uses
            managed  and
             types.
            

    */
public final class ManagedAuthenticatedEncryptorConfiguration
    :
    aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor CreateNewDescriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.CreateNewDescriptor
    /**
    */
    public override func CreateNewDescriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_IAuthenticatedEncryptorDescriptor__CreateNewDescriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
    // [IsSpecialName] System.Type get_EncryptionAlgorithmType()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmType
    public func get_EncryptionAlgorithmType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_Type__get_EncryptionAlgorithmType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmType(System.Type)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmType(System.Type)
    public func set_EncryptionAlgorithmType(value : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmType_0__1__Type(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_EncryptionAlgorithmKeySize()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.get_EncryptionAlgorithmKeySize
    public func get_EncryptionAlgorithmKeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_i32__get_EncryptionAlgorithmKeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EncryptionAlgorithmKeySize(System.Int32)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.set_EncryptionAlgorithmKeySize(System.Int32)
    public func set_EncryptionAlgorithmKeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_void__set_EncryptionAlgorithmKeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Type get_ValidationAlgorithmType()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.get_ValidationAlgorithmType
    public func get_ValidationAlgorithmType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_Type__get_ValidationAlgorithmType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ValidationAlgorithmType(System.Type)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration.set_ValidationAlgorithmType(System.Type)
    public func set_ValidationAlgorithmType(value : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorConfiguration_void__set_ValidationAlgorithmType_0__1__Type(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The length (in bits) of the key that will be used for symmetric encryption.
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithmKeySize : Swift.Int32 {
        get {
            return try! get_EncryptionAlgorithmKeySize();
        }
        set(v) {
            return try! set_EncryptionAlgorithmKeySize(value: v);
        }
    }
    /**
    
            The type of the algorithm to use for symmetric encryption.
            The type must subclass .
            This property is required to have a value.
            

    */
    public var EncryptionAlgorithmType : dotnet.System.Type_ {
        get {
            return try! get_EncryptionAlgorithmType();
        }
        set(v) {
            return try! set_EncryptionAlgorithmType(value: v);
        }
    }
    /**
    
            The type of the algorithm to use for validation.
            Type type must subclass .
            This property is required to have a value.
            

    */
    public var ValidationAlgorithmType : dotnet.System.Type_ {
        get {
            return try! get_ValidationAlgorithmType();
        }
        set(v) {
            return try! set_ValidationAlgorithmType(value: v);
        }
    }
} // ManagedAuthenticatedEncryptorConfiguration


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptor
    /**
    
            A descriptor which can create an authenticated encryption system based upon the
            configuration provided by an  object.
            

    */
public final class ManagedAuthenticatedEncryptorDescriptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration, Microsoft.AspNetCore.DataProtection.ISecret)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptor.#ctor(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration,Microsoft.AspNetCore.DataProtection.ISecret)
    /**
    
            Initializes a new instance of .
            

    - Parameter configuration: The .
    - Parameter masterKey: The master key.
    */
    public init(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration, masterKey : aspnetcore.Microsoft.AspNetCore.DataProtection.ISecret) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptor_ctor_0__2__ManagedAuthenticatedEncryptorConfiguration_ISecret(&__thrown, configuration.get_handle(), masterKey.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo ExportToXml()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptor.ExportToXml
    /**
    */
    public func ExportToXml() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptor_XmlSerializedDescriptorInfo__ExportToXml_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo(hndl : __return);
        }
    }
} // ManagedAuthenticatedEncryptorDescriptor


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptorDeserializer
    /**
    
            A class that can deserialize an  that represents the serialized version
            of an .
            

    */
public final class ManagedAuthenticatedEncryptorDescriptorDeserializer
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptorDeserializer_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptorDeserializer.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptorDeserializer_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor ImportFromXml(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorDescriptorDeserializer.ImportFromXml(System.Xml.Linq.XElement)
    /**
    
            Imports the  from serialized XML.
            

    */
    public func ImportFromXml(element : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_ManagedAuthenticatedEncryptorDescriptorDeserializer_IAuthenticatedEncryptorDescriptor__ImportFromXml_0__1__XElement(&__thrown, self.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // ManagedAuthenticatedEncryptorDescriptorDeserializer


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlExtensions
public struct XmlExtensions {
    // void MarkAsRequiresEncryption(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlExtensions.MarkAsRequiresEncryption(System.Xml.Linq.XElement)
    /**
    
            Marks the provided  as requiring encryption before being persisted
            to storage. Use when implementing .
            

    */
    public static func MarkAsRequiresEncryption(element : dotnet.System.Xml.Linq.XElement) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_XmlExtensions_void__MarkAsRequiresEncryption_0__1__XElement(&__thrown, element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // XmlExtensions


// type: Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo
    /**
    
            Wraps an  that contains the XML-serialized representation of an
             along with the type that can be used
            to deserialize it.
            

    */
public final class XmlSerializedDescriptorInfo
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_XmlSerializedDescriptorInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Xml.Linq.XElement, System.Type)
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo.#ctor(System.Xml.Linq.XElement,System.Type)
    /**
    
            Creates an instance of an .
            

    - Parameter serializedDescriptorElement: The XML-serialized form of the .
    - Parameter deserializerType: The class whose 
            method can be used to deserialize .
    */
    public init(serializedDescriptorElement : dotnet.System.Xml.Linq.XElement, deserializerType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_XmlSerializedDescriptorInfo_ctor_0__2__XElement_Type(&__thrown, serializedDescriptorElement.get_handle(), deserializerType.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_DeserializerType()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo.get_DeserializerType
    public func get_DeserializerType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_XmlSerializedDescriptorInfo_Type__get_DeserializerType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // [IsSpecialName] System.Xml.Linq.XElement get_SerializedDescriptorElement()
// docid: M:Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlSerializedDescriptorInfo.get_SerializedDescriptorElement
    public func get_SerializedDescriptorElement() throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_XmlSerializedDescriptorInfo_XElement__get_SerializedDescriptorElement_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
    /**
    
            The class whose 
            method can be used to deserialize the value stored in .
            

    */
    public var DeserializerType : dotnet.System.Type_ {
        get {
            return try! get_DeserializerType();
        }
    }
    /**
    
            An XML-serialized representation of an .
            

    */
    public var SerializedDescriptorElement : dotnet.System.Xml.Linq.XElement {
        get {
            return try! get_SerializedDescriptorElement();
        }
    }
} // XmlSerializedDescriptorInfo


}


// Microsoft.AspNetCore.DataProtection.Internal
extension Microsoft.AspNetCore.DataProtection.Internal {
// type: Microsoft.AspNetCore.DataProtection.Internal.IActivator
    /**
    
            An interface into  that also supports
            limited dependency injection (of ).
            

    */
open class IActivator
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_Internal_IActivator
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_Internal_IActivator_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Object CreateInstance(System.Type, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.Internal.IActivator.CreateInstance(System.Type,System.String)
    /**
    
            Creates an instance of  and ensures
            that it is assignable to .
            

    */
    open func CreateInstance(expectedBaseType : dotnet.System.Type_, implementationTypeName : dotnet.System.String) throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Internal_IActivator_Object__CreateInstance_0__2__Type_String(&__thrown, self.get_handle(), expectedBaseType.get_handle(), implementationTypeName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
} // IActivator


}

// Microsoft.AspNetCore.DataProtection.KeyManagement
extension Microsoft.AspNetCore.DataProtection.KeyManagement {
// type: Microsoft.AspNetCore.DataProtection.KeyManagement.IKey
    /**
    
            The basic interface for representing an authenticated encryption key.
            

    */
open class IKey
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_IKey
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor CreateEncryptor()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.CreateEncryptor
    /**
    
            Creates an  instance that can be used to encrypt data
            to and decrypt data from this key.
            

    - Returns: An .

    */
    open func CreateEncryptor() throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_IAuthenticatedEncryptor__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_ActivationDate()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_ActivationDate
    open func get_ActivationDate() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_DateTimeOffset__get_ActivationDate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_CreationDate()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_CreationDate
    open func get_CreationDate() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_DateTimeOffset__get_CreationDate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_ExpirationDate()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_ExpirationDate
    open func get_ExpirationDate() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_DateTimeOffset__get_ExpirationDate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsRevoked()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_IsRevoked
    open func get_IsRevoked() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_bool__get_IsRevoked_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Guid get_KeyId()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_KeyId
    open func get_KeyId() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_Guid__get_KeyId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor get_Descriptor()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKey.get_Descriptor
    open func get_Descriptor() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_IAuthenticatedEncryptorDescriptor__get_Descriptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
} // IKey


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink
    /**
    
            The basic interface for implementing a key escrow sink.
            

    */
open class IKeyEscrowSink
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Store(System.Guid, System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink.Store(System.Guid,System.Xml.Linq.XElement)
    /**
    
            Stores the given key material to the escrow service.
            

    - Parameter keyId: The id of the key being persisted to escrow.
    - Parameter element: The unencrypted key material in XML form.
    */
    open func Store(keyId : dotnet.System.Guid, element : dotnet.System.Xml.Linq.XElement) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink_void__Store_0__2__Guid_XElement(&__thrown, self.get_handle(), keyId.get_handle(), element.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IKeyEscrowSink


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager
    /**
    
            The basic interface for performing key management operations.
            

    */
open class IKeyManager
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.KeyManagement.IKey CreateNewKey(System.DateTimeOffset, System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager.CreateNewKey(System.DateTimeOffset,System.DateTimeOffset)
    /**
    
            Creates a new key with the specified activation and expiration dates and persists
            the new key to the underlying repository.
            

    - Parameter activationDate: The date on which encryptions to this key may begin.
    - Parameter expirationDate: The date after which encryptions to this key may no longer take place.
    - Returns: The newly-created IKey instance.

    */
    open func CreateNewKey(activationDate : dotnet.System.DateTimeOffset, expirationDate : dotnet.System.DateTimeOffset) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_IKey__CreateNewKey_0__2__DateTimeOffset_DateTimeOffset(&__thrown, self.get_handle(), activationDate.get_handle(), expirationDate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey(hndl : __return);
        }
    }
    // System.Collections.Generic.IReadOnlyCollection<Microsoft.AspNetCore.DataProtection.KeyManagement.IKey> GetAllKeys()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager.GetAllKeys
    /**
    
            Fetches all keys from the underlying repository.
            

    - Returns: The collection of all keys.

    */
    open func GetAllKeys() throws -> dotnet.System.Collections.Generic.IReadOnlyCollection_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_System_Collections_Generic_IReadOnlyCollection_Microsoft_AspNetCore_DataProtection_KeyManagement_IKey___GetAllKeys_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyCollection_1(hndl : __return);
        }
    }
    // System.Threading.CancellationToken GetCacheExpirationToken()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager.GetCacheExpirationToken
    /**
    
            Retrieves a token that signals that callers who have cached the return value of
            GetAllKeys should clear their caches. This could be in response to a call to
            CreateNewKey or RevokeKey, or it could be in response to some other external notification.
            Callers who are interested in observing this token should call this method before the
            corresponding call to GetAllKeys.
            

    - Returns: 
            The cache expiration token. When an expiration notification is triggered, any
            tokens previously returned by this method will become canceled, and tokens returned by
            future invocations of this method will themselves not trigger until the next expiration
            event.
            

    */
    open func GetCacheExpirationToken() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_CancellationToken__GetCacheExpirationToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // void RevokeKey(System.Guid, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager.RevokeKey(System.Guid,System.String)
    /**
    
            Revokes a specific key and persists the revocation to the underlying repository.
            

    - Parameter keyId: The id of the key to revoke.
    - Parameter reason: An optional human-readable reason for revocation.
    */
    open func RevokeKey(keyId : dotnet.System.Guid, reason : Optional<dotnet.System.String> = nil) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_void__RevokeKey_0__2__Guid_String(&__thrown, self.get_handle(), keyId.get_handle(), reason?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RevokeAllKeys(System.DateTimeOffset, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyManager.RevokeAllKeys(System.DateTimeOffset,System.String)
    /**
    
            Revokes all keys created before a specified date and persists the revocation to the
            underlying repository.
            

    - Parameter revocationDate: The revocation date. All keys with a creation date before
            this value will be revoked.
    - Parameter reason: An optional human-readable reason for revocation.
    */
    open func RevokeAllKeys(revocationDate : dotnet.System.DateTimeOffset, reason : Optional<dotnet.System.String> = nil) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager_void__RevokeAllKeys_0__2__DateTimeOffset_String(&__thrown, self.get_handle(), revocationDate.get_handle(), reason?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IKeyManager


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions
    /**
    
            Options that control how an  should behave.
            

    */
open class KeyManagementOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.#ctor
    /**
    
            Initializes a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_AutoGenerateKeys()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_AutoGenerateKeys
    open func get_AutoGenerateKeys() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_bool__get_AutoGenerateKeys_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AutoGenerateKeys(bool)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.set_AutoGenerateKeys(System.Boolean)
    open func set_AutoGenerateKeys(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_void__set_AutoGenerateKeys_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_NewKeyLifetime()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_NewKeyLifetime
    open func get_NewKeyLifetime() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_TimeSpan__get_NewKeyLifetime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_NewKeyLifetime(System.TimeSpan)
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration get_AuthenticatedEncryptorConfiguration()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_AuthenticatedEncryptorConfiguration
    open func get_AuthenticatedEncryptorConfiguration() throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_AlgorithmConfiguration__get_AuthenticatedEncryptorConfiguration_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_AuthenticatedEncryptorConfiguration(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.set_AuthenticatedEncryptorConfiguration(Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration)
    open func set_AuthenticatedEncryptorConfiguration(value : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_void__set_AuthenticatedEncryptorConfiguration_0__1__AlgorithmConfiguration(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink> get_KeyEscrowSinks()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_KeyEscrowSinks
    open func get_KeyEscrowSinks() throws -> dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_System_Collections_Generic_IList_Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink___get_KeyEscrowSinks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IList_1(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository get_XmlRepository()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_XmlRepository
    open func get_XmlRepository() throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_IXmlRepository__get_XmlRepository_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_XmlRepository(Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.set_XmlRepository(Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository)
    open func set_XmlRepository(value : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_void__set_XmlRepository_0__1__IXmlRepository(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor get_XmlEncryptor()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_XmlEncryptor
    open func get_XmlEncryptor() throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_IXmlEncryptor__get_XmlEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_XmlEncryptor(Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.set_XmlEncryptor(Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor)
    open func set_XmlEncryptor(value : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_void__set_XmlEncryptor_0__1__IXmlEncryptor(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory> get_AuthenticatedEncryptorFactories()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions.get_AuthenticatedEncryptorFactories
    open func get_AuthenticatedEncryptorFactories() throws -> dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions_System_Collections_Generic_IList_Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory___get_AuthenticatedEncryptorFactories_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IList_1(hndl : __return);
        }
    }
    /**
    
            The  instance that can be used to create
            the  instance.
            

    */
    open var AuthenticatedEncryptorConfiguration : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AlgorithmConfiguration> {
        get {
            return try! get_AuthenticatedEncryptorConfiguration();
        }
        set(v) {
            return try! set_AuthenticatedEncryptorConfiguration(value: v!);
        }
    }
    /**
    
            The list of  that will be used for creating
            s.
            

    */
    open var AuthenticatedEncryptorFactories : dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptorFactory> {
        get {
            return try! get_AuthenticatedEncryptorFactories();
        }
    }
    /**
    
            Specifies whether the data protection system should auto-generate keys.
            

    */
    open var AutoGenerateKeys : Bool {
        get {
            return try! get_AutoGenerateKeys();
        }
        set(v) {
            return try! set_AutoGenerateKeys(value: v);
        }
    }
    /**
    
            The list of  to store the key material in.
            

    */
    open var KeyEscrowSinks : dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink> {
        get {
            return try! get_KeyEscrowSinks();
        }
    }
    /**
    
            Controls the lifetime (number of days before expiration)
            for newly-generated keys.
            

    */
    open var NewKeyLifetime : dotnet.System.TimeSpan {
        get {
            return try! get_NewKeyLifetime();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_NewKeyLifetime(System.TimeSpan)
    }
    /**
    
            The  to use for encrypting XML elements.
            

    */
    open var XmlEncryptor : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor> {
        get {
            return try! get_XmlEncryptor();
        }
        set(v) {
            return try! set_XmlEncryptor(value: v!);
        }
    }
    /**
    
            The  to use for storing and retrieving XML elements.
            

    */
    open var XmlRepository : Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository> {
        get {
            return try! get_XmlRepository();
        }
        set(v) {
            return try! set_XmlRepository(value: v!);
        }
    }
} // KeyManagementOptions


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager
    /**
    
            A key manager backed by an .
            

    */
public final class XmlKeyManager
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>, Microsoft.AspNetCore.DataProtection.Internal.IActivator)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions},Microsoft.AspNetCore.DataProtection.Internal.IActivator)
    /**
    
            Creates an .
            

    - Parameter keyManagementOptions: The  instance that provides the configuration.
    - Parameter activator: The .
    */
    public init(keyManagementOptions : aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>, activator : aspnetcore.Microsoft.AspNetCore.DataProtection.Internal.IActivator) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_ctor_0__2__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions__IActivator(&__thrown, keyManagementOptions.get_handle(), activator.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>, Microsoft.AspNetCore.DataProtection.Internal.IActivator, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions},Microsoft.AspNetCore.DataProtection.Internal.IActivator,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates an .
            

    - Parameter keyManagementOptions: The  instance that provides the configuration.
    - Parameter activator: The .
    - Parameter loggerFactory: The .
    */
    public init(keyManagementOptions : aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>, activator : aspnetcore.Microsoft.AspNetCore.DataProtection.Internal.IActivator, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_ctor_0__3__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_DataProtection_KeyManagement_KeyManagementOptions__IActivator_ILoggerFactory(&__thrown, keyManagementOptions.get_handle(), activator.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.KeyManagement.IKey CreateNewKey(System.DateTimeOffset, System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.CreateNewKey(System.DateTimeOffset,System.DateTimeOffset)
    /**
    */
    public func CreateNewKey(activationDate : dotnet.System.DateTimeOffset, expirationDate : dotnet.System.DateTimeOffset) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_IKey__CreateNewKey_0__2__DateTimeOffset_DateTimeOffset(&__thrown, self.get_handle(), activationDate.get_handle(), expirationDate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey(hndl : __return);
        }
    }
    // System.Collections.Generic.IReadOnlyCollection<Microsoft.AspNetCore.DataProtection.KeyManagement.IKey> GetAllKeys()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.GetAllKeys
    /**
    */
    public func GetAllKeys() throws -> dotnet.System.Collections.Generic.IReadOnlyCollection_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_System_Collections_Generic_IReadOnlyCollection_Microsoft_AspNetCore_DataProtection_KeyManagement_IKey___GetAllKeys_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyCollection_1(hndl : __return);
        }
    }
    // System.Threading.CancellationToken GetCacheExpirationToken()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.GetCacheExpirationToken
    /**
    */
    public func GetCacheExpirationToken() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_CancellationToken__GetCacheExpirationToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // void RevokeAllKeys(System.DateTimeOffset, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.RevokeAllKeys(System.DateTimeOffset,System.String)
    /**
    */
    public func RevokeAllKeys(revocationDate : dotnet.System.DateTimeOffset, reason : Optional<dotnet.System.String> = nil) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_void__RevokeAllKeys_0__2__DateTimeOffset_String(&__thrown, self.get_handle(), revocationDate.get_handle(), reason?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void RevokeKey(System.Guid, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager.RevokeKey(System.Guid,System.String)
    /**
    */
    public func RevokeKey(keyId : dotnet.System.Guid, reason : Optional<dotnet.System.String> = nil) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_XmlKeyManager_void__RevokeKey_0__2__Guid_String(&__thrown, self.get_handle(), keyId.get_handle(), reason?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // XmlKeyManager


}
// Microsoft.AspNetCore.DataProtection.KeyManagement.Internal
extension Microsoft.AspNetCore.DataProtection.KeyManagement.Internal {
// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing
    /**
    
            Wraps both a keyring and its expiration policy.
            

    */
public final class CacheableKeyRing
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_CacheableKeyRing_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // CacheableKeyRing


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution
// boxed value type
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
public final class DefaultKeyResolution
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_DefaultKeyResolution_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_DefaultKeyResolution_implicit_ctor();
            super.init(hndl: h);
    }
} // DefaultKeyResolution


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class ICacheableKeyRingProvider
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_ICacheableKeyRingProvider
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_ICacheableKeyRingProvider_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing GetCacheableKeyRing(System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.ICacheableKeyRingProvider.GetCacheableKeyRing(System.DateTimeOffset)
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
    open func GetCacheableKeyRing(now : dotnet.System.DateTimeOffset) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_ICacheableKeyRingProvider_CacheableKeyRing__GetCacheableKeyRing_0__1__DateTimeOffset(&__thrown, self.get_handle(), now.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.CacheableKeyRing(hndl : __return);
        }
    }
} // ICacheableKeyRingProvider


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IDefaultKeyResolver
    /**
    
            Implements policy for resolving the default key from a candidate keyring.
            

    */
open class IDefaultKeyResolver
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IDefaultKeyResolver
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IDefaultKeyResolver_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution ResolveDefaultKeyPolicy(System.DateTimeOffset, System.Collections.Generic.IEnumerable<Microsoft.AspNetCore.DataProtection.KeyManagement.IKey>)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IDefaultKeyResolver.ResolveDefaultKeyPolicy(System.DateTimeOffset,System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.DataProtection.KeyManagement.IKey})
    /**
    
            Locates the default key from the keyring.
            

    */
    open func ResolveDefaultKeyPolicy(now : dotnet.System.DateTimeOffset, allKeys : dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IDefaultKeyResolver_DefaultKeyResolution__ResolveDefaultKeyPolicy_0__2__DateTimeOffset_System_Collections_Generic_IEnumerable_Microsoft_AspNetCore_DataProtection_KeyManagement_IKey_(&__thrown, self.get_handle(), now.get_handle(), allKeys.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.DefaultKeyResolution(hndl : __return);
        }
    }
} // IDefaultKeyResolver


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IInternalXmlKeyManager
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.KeyManagement.IKey CreateNewKey(System.Guid, System.DateTimeOffset, System.DateTimeOffset, System.DateTimeOffset)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.CreateNewKey(System.Guid,System.DateTimeOffset,System.DateTimeOffset,System.DateTimeOffset)
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
    open func CreateNewKey(keyId : dotnet.System.Guid, creationDate : dotnet.System.DateTimeOffset, activationDate : dotnet.System.DateTimeOffset, expirationDate : dotnet.System.DateTimeOffset) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager_IKey__CreateNewKey_0__4__Guid_DateTimeOffset_DateTimeOffset_DateTimeOffset(&__thrown, self.get_handle(), keyId.get_handle(), creationDate.get_handle(), activationDate.get_handle(), expirationDate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKey(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor DeserializeDescriptorFromKeyElement(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.DeserializeDescriptorFromKeyElement(System.Xml.Linq.XElement)
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
    open func DeserializeDescriptorFromKeyElement(keyElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager_IAuthenticatedEncryptorDescriptor__DeserializeDescriptorFromKeyElement_0__1__XElement(&__thrown, self.get_handle(), keyElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.IAuthenticatedEncryptorDescriptor(hndl : __return);
        }
    }
    // void RevokeSingleKey(System.Guid, System.DateTimeOffset, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IInternalXmlKeyManager.RevokeSingleKey(System.Guid,System.DateTimeOffset,System.String)
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
    open func RevokeSingleKey(keyId : dotnet.System.Guid, revocationDate : dotnet.System.DateTimeOffset, reason : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager_void__RevokeSingleKey_0__3__Guid_DateTimeOffset_String(&__thrown, self.get_handle(), keyId.get_handle(), revocationDate.get_handle(), reason?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IInternalXmlKeyManager


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing
    /**
    
            The basic interface for accessing a read-only keyring.
            

    */
open class IKeyRing
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor GetAuthenticatedEncryptorByKeyId(System.Guid, ref bool)
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing.GetAuthenticatedEncryptorByKeyId(System.Guid,System.Boolean@)
    /**
    
            Returns an encryptor instance for the given key, or 'null' if the key with the
            specified id cannot be found in the keyring.
            

    */
    open func GetAuthenticatedEncryptorByKeyId(keyId : dotnet.System.Guid, isRevoked : inout Bool) throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
            var _tmp_out_isRevoked = Swift.Int32(isRevoked ? 1 : 0);
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing_IAuthenticatedEncryptor__GetAuthenticatedEncryptorByKeyId_0__2__Guid_outbool(&__thrown, self.get_handle(), keyId.get_handle(), &_tmp_out_isRevoked);
        let _tmp2_isRevoked = (_tmp_out_isRevoked) != 0;
            isRevoked = _tmp2_isRevoked;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor get_DefaultAuthenticatedEncryptor()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing.get_DefaultAuthenticatedEncryptor
    open func get_DefaultAuthenticatedEncryptor() throws -> Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing_IAuthenticatedEncryptor__get_DefaultAuthenticatedEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.IAuthenticatedEncryptor(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Guid get_DefaultKeyId()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing.get_DefaultKeyId
    open func get_DefaultKeyId() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing_Guid__get_DefaultKeyId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
} // IKeyRing


// type: Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRingProvider
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IKeyRingProvider
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRingProvider
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRingProvider_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing GetCurrentKeyRing()
// docid: M:Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRingProvider.GetCurrentKeyRing
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
    open func GetCurrentKeyRing() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRingProvider_IKeyRing__GetCurrentKeyRing_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.Internal.IKeyRing(hndl : __return);
        }
    }
} // IKeyRingProvider


}


// Microsoft.AspNetCore.DataProtection.Repositories
extension Microsoft.AspNetCore.DataProtection.Repositories {
// type: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository
    /**
    
            An XML repository backed by a file system.
            

    */
open class FileSystemXmlRepository
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.DirectoryInfo, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.#ctor(System.IO.DirectoryInfo,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a  with keys stored at the given directory.
            

    - Parameter directory: The directory in which to persist key material.
    - Parameter loggerFactory: The .
    */
    public init(directory : dotnet.System.IO.DirectoryInfo, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_ctor_0__2__DirectoryInfo_ILoggerFactory(&__thrown, directory.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement> GetAllElements()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.GetAllElements
    /**
    */
    open func GetAllElements() throws -> dotnet.System.Collections.Generic.IReadOnlyCollection_1<dotnet.System.Xml.Linq.XElement> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_System_Collections_Generic_IReadOnlyCollection_System_Xml_Linq_XElement___GetAllElements_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyCollection_1(hndl : __return);
        }
    }
    // void StoreElement(System.Xml.Linq.XElement, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.StoreElement(System.Xml.Linq.XElement,System.String)
    /**
    */
    open func StoreElement(element : dotnet.System.Xml.Linq.XElement, friendlyName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_void__StoreElement_0__2__XElement_String(&__thrown, self.get_handle(), element.get_handle(), friendlyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.DirectoryInfo get_DefaultKeyStorageDirectory()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.get_DefaultKeyStorageDirectory
    open class func get_DefaultKeyStorageDirectory() throws -> Optional<dotnet.System.IO.DirectoryInfo> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_DirectoryInfo__get_DefaultKeyStorageDirectory_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.DirectoryInfo(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.IO.DirectoryInfo get_Directory()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository.get_Directory
    open func get_Directory() throws -> dotnet.System.IO.DirectoryInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_FileSystemXmlRepository_DirectoryInfo__get_Directory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.DirectoryInfo(hndl : __return);
        }
    }
    /**
    
            The default key storage directory.
            On Windows, this currently corresponds to "Environment.SpecialFolder.LocalApplication/ASP.NET/DataProtection-Keys".
            On Linux and macOS, this currently corresponds to "$HOME/.aspnet/DataProtection-Keys".
            

    */
    public static var DefaultKeyStorageDirectory : Optional<dotnet.System.IO.DirectoryInfo> {
        get {
            return try! get_DefaultKeyStorageDirectory();
        }
    }
    /**
    
            The directory into which key material will be written.
            

    */
    open var Directory : dotnet.System.IO.DirectoryInfo {
        get {
            return try! get_Directory();
        }
    }
} // FileSystemXmlRepository


// type: Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository
    /**
    
            The basic interface for storing and retrieving XML elements.
            

    */
open class IXmlRepository
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement> GetAllElements()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository.GetAllElements
    /**
    
            Gets all top-level XML elements in the repository.
            

    */
    open func GetAllElements() throws -> dotnet.System.Collections.Generic.IReadOnlyCollection_1<dotnet.System.Xml.Linq.XElement> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository_System_Collections_Generic_IReadOnlyCollection_System_Xml_Linq_XElement___GetAllElements_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyCollection_1(hndl : __return);
        }
    }
    // void StoreElement(System.Xml.Linq.XElement, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.IXmlRepository.StoreElement(System.Xml.Linq.XElement,System.String)
    /**
    
            Adds a top-level XML element to the repository.
            

    - Parameter element: The element to add.
    - Parameter friendlyName: An optional name to be associated with the XML element.
            For instance, if this repository stores XML files on disk, the friendly name may
            be used as part of the file name. Repository implementations are not required to
            observe this parameter even if it has been provided by the caller.
    */
    open func StoreElement(element : dotnet.System.Xml.Linq.XElement, friendlyName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository_void__StoreElement_0__2__XElement_String(&__thrown, self.get_handle(), element.get_handle(), friendlyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IXmlRepository


// type: Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository
    /**
    
            An XML repository backed by the Windows registry.
            

    */
open class RegistryXmlRepository
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Win32.RegistryKey, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.#ctor(Microsoft.Win32.RegistryKey,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a  with keys stored in the given registry key.
            

    - Parameter registryKey: The registry key in which to persist key material.
    - Parameter loggerFactory: The .
    */
    public init(registryKey : dotnet.Microsoft.Win32.RegistryKey, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_ctor_0__2__RegistryKey_ILoggerFactory(&__thrown, registryKey.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IReadOnlyCollection<System.Xml.Linq.XElement> GetAllElements()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.GetAllElements
    /**
    */
    open func GetAllElements() throws -> dotnet.System.Collections.Generic.IReadOnlyCollection_1<dotnet.System.Xml.Linq.XElement> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_System_Collections_Generic_IReadOnlyCollection_System_Xml_Linq_XElement___GetAllElements_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IReadOnlyCollection_1(hndl : __return);
        }
    }
    // void StoreElement(System.Xml.Linq.XElement, System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.StoreElement(System.Xml.Linq.XElement,System.String)
    /**
    */
    open func StoreElement(element : dotnet.System.Xml.Linq.XElement, friendlyName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_void__StoreElement_0__2__XElement_String(&__thrown, self.get_handle(), element.get_handle(), friendlyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Win32.RegistryKey get_DefaultRegistryKey()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.get_DefaultRegistryKey
    open class func get_DefaultRegistryKey() throws -> Optional<dotnet.Microsoft.Win32.RegistryKey> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_RegistryKey__get_DefaultRegistryKey_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.Microsoft.Win32.RegistryKey(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Win32.RegistryKey get_RegistryKey()
// docid: M:Microsoft.AspNetCore.DataProtection.Repositories.RegistryXmlRepository.get_RegistryKey
    open func get_RegistryKey() throws -> dotnet.Microsoft.Win32.RegistryKey {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_Repositories_RegistryXmlRepository_RegistryKey__get_RegistryKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.RegistryKey(hndl : __return);
        }
    }
    /**
    
            The default key storage directory, which currently corresponds to
            "HKLM\SOFTWARE\Microsoft\ASP.NET\4.0.30319.0\AutoGenKeys\{SID}".
            

    */
    public static var DefaultRegistryKey : Optional<dotnet.Microsoft.Win32.RegistryKey> {
        get {
            return try! get_DefaultRegistryKey();
        }
    }
    /**
    
            The registry key into which key material will be written.
            

    */
    open var RegistryKey : dotnet.Microsoft.Win32.RegistryKey {
        get {
            return try! get_RegistryKey();
        }
    }
} // RegistryXmlRepository


}

// Microsoft.AspNetCore.DataProtection.XmlEncryption
extension Microsoft.AspNetCore.DataProtection.XmlEncryption {
// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateResolver
    /**
    
            A default implementation of  that looks in the current user
            and local machine certificate stores.
            

    */
open class CertificateResolver
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_ICertificateResolver
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateResolver_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateResolver.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateResolver_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate2 ResolveCertificate(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateResolver.ResolveCertificate(System.String)
    /**
    
            Locates an  given its thumbprint.
            

    - Parameter thumbprint: The thumbprint (as a hex string) of the certificate to resolve.
    - Returns: The resolved , or null if the certificate cannot be found.

    */
    open func ResolveCertificate(thumbprint : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateResolver_X509Certificate2__ResolveCertificate_0__1__String(&__thrown, self.get_handle(), thumbprint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // CertificateResolver


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor
    /**
    
            An  that can perform XML encryption by using an X.509 certificate.
            

    */
public final class CertificateXmlEncryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateXmlEncryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.#ctor(System.String,Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a  given a certificate's thumbprint, an
             that can be used to resolve the certificate, and
            an .
            

    */
    public init(thumbprint : dotnet.System.String, certificateResolver : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateXmlEncryptor_ctor_0__3__String_ICertificateResolver_ILoggerFactory(&__thrown, thumbprint.get_handle(), certificateResolver.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.X509Certificates.X509Certificate2, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a  given an  instance
            and an .
            

    */
    public init(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateXmlEncryptor_ctor_0__2__X509Certificate2_ILoggerFactory(&__thrown, certificate.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo Encrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.CertificateXmlEncryptor.Encrypt(System.Xml.Linq.XElement)
    /**
    
            Encrypts the specified  with an X.509 certificate.
            

    - Parameter plaintextElement: The plaintext to encrypt.
    - Returns: 
            An  that contains the encrypted value of
             along with information about how to
            decrypt it.
            

    */
    public func Encrypt(plaintextElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_CertificateXmlEncryptor_EncryptedXmlInfo__Encrypt_0__1__XElement(&__thrown, self.get_handle(), plaintextElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo(hndl : __return);
        }
    }
} // CertificateXmlEncryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags
    /**
    
            Flags used to control the creation of protection descriptors.
            

    */
public struct DpapiNGProtectionDescriptorFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGProtectionDescriptorFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags None
    /**
    
            No special handling is necessary.
            

    */
    public static var None : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags(val: Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGProtectionDescriptorFlags_get_None());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags NamedDescriptor
    /**
    
            The provided descriptor is a reference to a full descriptor stored
            in the system registry.
            

    */
    public static var NamedDescriptor : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags(val: Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGProtectionDescriptorFlags_get_NamedDescriptor());
            return __return;
        }
    }
    // static field: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags MachineKey
    /**
    
            When combined with , uses the HKLM registry
            instead of the HKCU registry when locating the full descriptor.
            

    */
    public static var MachineKey : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags {
        get {
        let __return = aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags(val: Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGProtectionDescriptorFlags_get_MachineKey());
            return __return;
        }
    }
} // DpapiNGProtectionDescriptorFlags


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor
    /**
    
            An  that decrypts XML elements that were encrypted with .
            

    */
public final class DpapiNGXmlDecryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlDecryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.#ctor
    /**
    
            Creates a new instance of a .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlDecryptor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.#ctor(System.IServiceProvider)
    /**
    
            Creates a new instance of a .
            

    - Parameter services: An optional  to provide ancillary services.
    */
    public init(services : Optional<dotnet.System.IServiceProvider>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlDecryptor_ctor_0__1__IServiceProvider(&__thrown, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Xml.Linq.XElement Decrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlDecryptor.Decrypt(System.Xml.Linq.XElement)
    /**
    
            Decrypts the specified XML element.
            

    - Parameter encryptedElement: An encrypted XML element.
    - Returns: The decrypted form of .

    */
    public func Decrypt(encryptedElement : dotnet.System.Xml.Linq.XElement) throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlDecryptor_XElement__Decrypt_0__1__XElement(&__thrown, self.get_handle(), encryptedElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
} // DpapiNGXmlDecryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor
    /**
    
            A class that can encrypt XML elements using Windows DPAPI:NG.
            

    */
public final class DpapiNGXmlEncryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlEncryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor.#ctor(System.String,Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a new instance of a .
            

    - Parameter protectionDescriptorRule: The rule string from which to create the protection descriptor.
    - Parameter flags: Flags controlling the creation of the protection descriptor.
    - Parameter loggerFactory: The .
    */
    public init(protectionDescriptorRule : dotnet.System.String, flags : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlEncryptor_ctor_0__3__String_DpapiNGProtectionDescriptorFlags_ILoggerFactory(&__thrown, protectionDescriptorRule.get_handle(), flags.get_value(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo Encrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGXmlEncryptor.Encrypt(System.Xml.Linq.XElement)
    /**
    
            Encrypts the specified .
            

    - Parameter plaintextElement: The plaintext to encrypt.
    - Returns: 
            An  that contains the encrypted value of
             along with information about how to
            decrypt it.
            

    */
    public func Encrypt(plaintextElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiNGXmlEncryptor_EncryptedXmlInfo__Encrypt_0__1__XElement(&__thrown, self.get_handle(), plaintextElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo(hndl : __return);
        }
    }
} // DpapiNGXmlEncryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor
    /**
    
            An  that decrypts XML elements that were encrypted with .
            

    */
public final class DpapiXmlDecryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlDecryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.#ctor
    /**
    
            Creates a new instance of a .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlDecryptor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.#ctor(System.IServiceProvider)
    /**
    
            Creates a new instance of a .
            

    - Parameter services: An optional  to provide ancillary services.
    */
    public init(services : Optional<dotnet.System.IServiceProvider>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlDecryptor_ctor_0__1__IServiceProvider(&__thrown, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Xml.Linq.XElement Decrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor.Decrypt(System.Xml.Linq.XElement)
    /**
    
            Decrypts the specified XML element.
            

    - Parameter encryptedElement: An encrypted XML element.
    - Returns: The decrypted form of .

    */
    public func Decrypt(encryptedElement : dotnet.System.Xml.Linq.XElement) throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlDecryptor_XElement__Decrypt_0__1__XElement(&__thrown, self.get_handle(), encryptedElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
} // DpapiXmlDecryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor
    /**
    
            An  that encrypts XML by using Windows DPAPI.
            

    */
public final class DpapiXmlEncryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlEncryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(bool, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor.#ctor(System.Boolean,Microsoft.Extensions.Logging.ILoggerFactory)
    /**
    
            Creates a  given a protection scope and an .
            

    - Parameter protectToLocalMachine: 'true' if the data should be decipherable by anybody on the local machine,
            'false' if the data should only be decipherable by the current Windows user account.
    - Parameter loggerFactory: The .
    */
    public init(protectToLocalMachine : Bool, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlEncryptor_ctor_0__2__bool_ILoggerFactory(&__thrown, Swift.Int32(protectToLocalMachine ? 1 : 0), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo Encrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlEncryptor.Encrypt(System.Xml.Linq.XElement)
    /**
    
            Encrypts the specified .
            

    - Parameter plaintextElement: The plaintext to encrypt.
    - Returns: 
            An  that contains the encrypted value of
             along with information about how to
            decrypt it.
            

    */
    public func Encrypt(plaintextElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_DpapiXmlEncryptor_EncryptedXmlInfo__Encrypt_0__1__XElement(&__thrown, self.get_handle(), plaintextElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo(hndl : __return);
        }
    }
} // DpapiXmlEncryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor
    /**
    
            An  that decrypts XML elements by using the  class.
            

    */
public final class EncryptedXmlDecryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlDecryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.#ctor
    /**
    
            Creates a new instance of an .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlDecryptor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.#ctor(System.IServiceProvider)
    /**
    
            Creates a new instance of an .
            

    - Parameter services: An optional  to provide ancillary services.
    */
    public init(services : Optional<dotnet.System.IServiceProvider>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlDecryptor_ctor_0__1__IServiceProvider(&__thrown, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Xml.Linq.XElement Decrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlDecryptor.Decrypt(System.Xml.Linq.XElement)
    /**
    
            Decrypts the specified XML element.
            

    - Parameter encryptedElement: An encrypted XML element.
    - Returns: The decrypted form of .

    */
    public func Decrypt(encryptedElement : dotnet.System.Xml.Linq.XElement) throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlDecryptor_XElement__Decrypt_0__1__XElement(&__thrown, self.get_handle(), encryptedElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
} // EncryptedXmlDecryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo
    /**
    
            Wraps an  that contains a blob of encrypted XML
            and information about the class which can be used to decrypt it.
            

    */
public final class EncryptedXmlInfo
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Xml.Linq.XElement, System.Type)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo.#ctor(System.Xml.Linq.XElement,System.Type)
    /**
    
            Creates an instance of an .
            

    - Parameter encryptedElement: A piece of encrypted XML.
    - Parameter decryptorType: The class whose 
            method can be used to decrypt .
    */
    public init(encryptedElement : dotnet.System.Xml.Linq.XElement, decryptorType : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlInfo_ctor_0__2__XElement_Type(&__thrown, encryptedElement.get_handle(), decryptorType.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_DecryptorType()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo.get_DecryptorType
    public func get_DecryptorType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlInfo_Type__get_DecryptorType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // [IsSpecialName] System.Xml.Linq.XElement get_EncryptedElement()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo.get_EncryptedElement
    public func get_EncryptedElement() throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_EncryptedXmlInfo_XElement__get_EncryptedElement_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
    /**
    
            The class whose  method can be used to
            decrypt the value stored in .
            

    */
    public var DecryptorType : dotnet.System.Type_ {
        get {
            return try! get_DecryptorType();
        }
    }
    /**
    
            A piece of encrypted XML.
            

    */
    public var EncryptedElement : dotnet.System.Xml.Linq.XElement {
        get {
            return try! get_EncryptedElement();
        }
    }
} // EncryptedXmlInfo


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver
    /**
    
            Provides services for locating  instances.
            

    */
open class ICertificateResolver
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_ICertificateResolver
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_ICertificateResolver_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Security.Cryptography.X509Certificates.X509Certificate2 ResolveCertificate(System.String)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.ICertificateResolver.ResolveCertificate(System.String)
    /**
    
            Locates an  given its thumbprint.
            

    - Parameter thumbprint: The thumbprint (as a hex string) of the certificate to resolve.
    - Returns: The resolved , or null if the certificate cannot be found.

    */
    open func ResolveCertificate(thumbprint : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_ICertificateResolver_X509Certificate2__ResolveCertificate_0__1__String(&__thrown, self.get_handle(), thumbprint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ICertificateResolver


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlDecryptor
    /**
    
            The basic interface for decrypting an XML element.
            

    */
open class IXmlDecryptor
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Xml.Linq.XElement Decrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlDecryptor.Decrypt(System.Xml.Linq.XElement)
    /**
    
            Decrypts the specified XML element.
            

    - Parameter encryptedElement: An encrypted XML element.
    - Returns: The decrypted form of .

    */
    open func Decrypt(encryptedElement : dotnet.System.Xml.Linq.XElement) throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor_XElement__Decrypt_0__1__XElement(&__thrown, self.get_handle(), encryptedElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
} // IXmlDecryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor
    /**
    
            The basic interface for encrypting XML elements.
            

    */
open class IXmlEncryptor
    :
    SGBridgeGenericValue,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo Encrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.IXmlEncryptor.Encrypt(System.Xml.Linq.XElement)
    /**
    
            Encrypts the specified .
            

    - Parameter plaintextElement: The plaintext to encrypt.
    - Returns: 
            An  that contains the encrypted value of
             along with information about how to
            decrypt it.
            

    */
    open func Encrypt(plaintextElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor_EncryptedXmlInfo__Encrypt_0__1__XElement(&__thrown, self.get_handle(), plaintextElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo(hndl : __return);
        }
    }
} // IXmlEncryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlDecryptor
    /**
    
            An  that decrypts XML elements with a null decryptor.
            

    */
public final class NullXmlDecryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlDecryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlDecryptor.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlDecryptor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Xml.Linq.XElement Decrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlDecryptor.Decrypt(System.Xml.Linq.XElement)
    /**
    
            Decrypts the specified XML element.
            

    - Parameter encryptedElement: An encrypted XML element.
    - Returns: The decrypted form of .

    */
    public func Decrypt(encryptedElement : dotnet.System.Xml.Linq.XElement) throws -> dotnet.System.Xml.Linq.XElement {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlDecryptor_XElement__Decrypt_0__1__XElement(&__thrown, self.get_handle(), encryptedElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Xml.Linq.XElement(hndl : __return);
        }
    }
} // NullXmlDecryptor


// type: Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor
    /**
    
            An  that encrypts XML elements with a null encryptor.
            

    */
public final class NullXmlEncryptor
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlEncryptor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor.#ctor
    /**
    
            Creates a new instance of .
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlEncryptor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IServiceProvider)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor.#ctor(System.IServiceProvider)
    /**
    
            Creates a new instance of .
            

    - Parameter services: An optional  to provide ancillary services.
    */
    public init(services : Optional<dotnet.System.IServiceProvider>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlEncryptor_ctor_0__1__IServiceProvider(&__thrown, services?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo Encrypt(System.Xml.Linq.XElement)
// docid: M:Microsoft.AspNetCore.DataProtection.XmlEncryption.NullXmlEncryptor.Encrypt(System.Xml.Linq.XElement)
    /**
    
            Encrypts the specified  with a null encryptor, i.e.,
            by returning the original value of  unencrypted.
            

    - Parameter plaintextElement: The plaintext to echo back.
    - Returns: 
            An  that contains the null-encrypted value of
             along with information about how to
            decrypt it.
            

    */
    public func Encrypt(plaintextElement : dotnet.System.Xml.Linq.XElement) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_DataProtection_XmlEncryption_NullXmlEncryptor_EncryptedXmlInfo__Encrypt_0__1__XElement(&__thrown, self.get_handle(), plaintextElement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.EncryptedXmlInfo(hndl : __return);
        }
    }
} // NullXmlEncryptor


}



// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions
public struct DataProtectionServiceCollectionExtensions {
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection)
// docid: M:Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions.AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection)
    /**
    
            Adds data protection services to the specified .
            

    - Parameter services: The  to add services to.
    */
    public static func AddDataProtection(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_DataProtectionServiceCollectionExtensions_IDataProtectionBuilder__AddDataProtection_0__1__IServiceCollection(&__thrown, services.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.DataProtection.DataProtectionOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions.AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{Microsoft.AspNetCore.DataProtection.DataProtectionOptions})
    /**
    
            Adds data protection services to the specified .
            

    - Parameter services: The  to add services to.
    - Parameter setupAction: An  to configure the provided .
    - Returns: A reference to this instance after the operation has completed.

    */
    public static func AddDataProtection(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_DataProtectionServiceCollectionExtensions_IDataProtectionBuilder__AddDataProtection_0__2__IServiceCollection_System_Action_Microsoft_AspNetCore_DataProtection_DataProtectionOptions_(&__thrown, services.get_handle(), setupAction.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func AddDataProtection(services : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection, setupAction : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>(setupAction);
        return try AddDataProtection(services: services, setupAction: del_setupAction);
    }
} // DataProtectionServiceCollectionExtensions


}



public protocol Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptor
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_ConfigurationModel_IAuthenticatedEncryptorDescriptorDeserializer
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptor
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_AuthenticatedEncryption_IAuthenticatedEncryptorFactory
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_IPersistedDataProtector
    :
    Microsoft_AspNetCore_DataProtection_IDataProtector
{
}

public protocol Microsoft_AspNetCore_DataProtection_ISecret
    :
    System_IDisposable
{
}

public protocol Microsoft_AspNetCore_DataProtection_Internal_IActivator
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_IKey
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyEscrowSink
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_IKeyManager
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_ICacheableKeyRingProvider
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IDefaultKeyResolver
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IInternalXmlKeyManager
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRing
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_KeyManagement_Internal_IKeyRingProvider
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_Repositories_IXmlRepository
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_XmlEncryption_ICertificateResolver
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlDecryptor
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_AspNetCore_DataProtection_XmlEncryption_IXmlEncryptor
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD void MarkAsRequiresEncryption(System.Xml.Linq.XElement)
extension dotnet.System.Xml.Linq.XElement {
    public func MarkAsRequiresEncryption() throws {
        try aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.XmlExtensions.MarkAsRequiresEncryption(element: self);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder SetApplicationName(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func SetApplicationName(applicationName : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.SetApplicationName(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), applicationName: applicationName);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func AddKeyEscrowSink(sink : aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), sink: sink);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink<TImplementation>(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
// TODO COPE extension method (unused generic param) Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink<TImplementation>(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyEscrowSink(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Func<System.IServiceProvider,Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func AddKeyEscrowSink(factory : dotnet.System.Func_2<dotnet.System.IServiceProvider,aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), factory: factory);
    }
    // delegate closure overload
    public func AddKeyEscrowSink(factory : @escaping (Optional<dotnet.System.IServiceProvider>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_factory = try dotnet.System.Func_2<dotnet.System.IServiceProvider,aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.IKeyEscrowSink>(factory);
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyEscrowSink(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), factory: del_factory);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddKeyManagementOptions(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Action<Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func AddKeyManagementOptions(setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyManagementOptions(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), setupAction: setupAction);
    }
    // delegate closure overload
    public func AddKeyManagementOptions(setupAction : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.KeyManagement.KeyManagementOptions>(setupAction);
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.AddKeyManagementOptions(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), setupAction: del_setupAction);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder DisableAutomaticKeyGeneration(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func DisableAutomaticKeyGeneration() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.DisableAutomaticKeyGeneration(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder PersistKeysToFileSystem(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.IO.DirectoryInfo)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func PersistKeysToFileSystem(directory : dotnet.System.IO.DirectoryInfo) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToFileSystem(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), directory: directory);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder PersistKeysToRegistry(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.Win32.RegistryKey)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func PersistKeysToRegistry(registryKey : dotnet.Microsoft.Win32.RegistryKey) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.PersistKeysToRegistry(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), registryKey: registryKey);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Security.Cryptography.X509Certificates.X509Certificate2)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithCertificate(certificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithCertificate(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), certificate: certificate);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithCertificate(thumbprint : dotnet.System.String) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithCertificate(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), thumbprint: thumbprint);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UnprotectKeysWithAnyCertificate(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.Security.Cryptography.X509Certificates.X509Certificate2[])
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UnprotectKeysWithAnyCertificate(certificates : dotnet.System_Arr<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UnprotectKeysWithAnyCertificate(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), certificates: certificates);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithDpapi() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapi(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapi(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, bool)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithDpapi(protectToLocalMachine : Bool) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapi(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), protectToLocalMachine: protectToLocalMachine);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithDpapiNG() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapiNG(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder ProtectKeysWithDpapiNG(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.String, Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func ProtectKeysWithDpapiNG(protectionDescriptorRule : dotnet.System.String, flags : aspnetcore.Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiNGProtectionDescriptorFlags) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.ProtectKeysWithDpapiNG(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), protectionDescriptorRule: protectionDescriptorRule, flags: flags);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder SetDefaultKeyLifetime(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.TimeSpan)
// TODO COPE extension method (span) Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder SetDefaultKeyLifetime(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, System.TimeSpan)

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UseCryptographicAlgorithms(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCryptographicAlgorithms(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), configuration: configuration);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UseCustomCryptographicAlgorithms(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngCbcAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), configuration: configuration);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UseCustomCryptographicAlgorithms(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.CngGcmAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), configuration: configuration);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseCustomCryptographicAlgorithms(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder, Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UseCustomCryptographicAlgorithms(configuration : aspnetcore.Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.ManagedAuthenticatedEncryptorConfiguration) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseCustomCryptographicAlgorithms(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())), configuration: configuration);
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder UseEphemeralDataProtectionProvider(Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder)
extension Microsoft_AspNetCore_DataProtection_IDataProtectionBuilder {
    public func UseEphemeralDataProtectionProvider() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionBuilderExtensions.UseEphemeralDataProtectionProvider(builder: aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD System.String GetApplicationUniqueIdentifier(System.IServiceProvider)
extension System_IServiceProvider {
    public func GetApplicationUniqueIdentifier() throws -> Optional<dotnet.System.String> {
        return try aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionUtilityExtensions.GetApplicationUniqueIdentifier(services: dotnet.System.IServiceProvider(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddDataProtection() throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions.AddDataProtection(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder AddDataProtection(Microsoft.Extensions.DependencyInjection.IServiceCollection, System.Action<Microsoft.AspNetCore.DataProtection.DataProtectionOptions>)
extension Microsoft_Extensions_DependencyInjection_IServiceCollection {
    public func AddDataProtection(setupAction : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions.AddDataProtection(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: setupAction);
    }
    // delegate closure overload
    public func AddDataProtection(setupAction : @escaping (Optional<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.DataProtection.IDataProtectionBuilder {
        let del_setupAction = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.DataProtection.DataProtectionOptions>(setupAction);
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.DataProtectionServiceCollectionExtensions.AddDataProtection(services: aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection(hndl: __copy_handle(self.get_handle())), setupAction: del_setupAction);
    }
}

