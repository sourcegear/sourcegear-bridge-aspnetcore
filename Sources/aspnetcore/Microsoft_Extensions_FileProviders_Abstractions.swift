// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.FileProviders
extension Microsoft.Extensions.FileProviders {
// type: Microsoft.Extensions.FileProviders.IDirectoryContents
    /**
    
            Represents a directory's content in the file provider.
            

    */
open class IDirectoryContents
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileProviders_IDirectoryContents
{
    public typealias T_IEnumerable_1 = aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo;
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_IDirectoryContents_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.IDirectoryContents.get_Exists
    open func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IDirectoryContents_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IDirectoryContents


// type: Microsoft.Extensions.FileProviders.IFileInfo
    /**
    
            Represents a file in the given file provider.
            

    */
open class IFileInfo
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileProviders_IFileInfo
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_IFileInfo_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.IO.Stream CreateReadStream()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.CreateReadStream
    /**
    
            Return file contents as readonly stream. Caller should dispose stream when complete.
            

    - Returns: The file stream

    */
    open func CreateReadStream() throws -> Optional<dotnet.System.IO.Stream> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_Stream__CreateReadStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.Stream(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_Exists
    open func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsDirectory()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_IsDirectory
    open func get_IsDirectory() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_bool__get_IsDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_LastModified()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_LastModified
    open func get_LastModified() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_DateTimeOffset__get_LastModified_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_Length
    open func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_PhysicalPath()
// docid: M:Microsoft.Extensions.FileProviders.IFileInfo.get_PhysicalPath
    open func get_PhysicalPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileInfo_String__get_PhysicalPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IFileInfo


// type: Microsoft.Extensions.FileProviders.IFileProvider
    /**
    
            A read-only file provider abstraction.
            

    */
open class IFileProvider
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileProviders_IFileProvider
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_IFileProvider_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.Extensions.FileProviders.IDirectoryContents GetDirectoryContents(System.String)
// docid: M:Microsoft.Extensions.FileProviders.IFileProvider.GetDirectoryContents(System.String)
    /**
    
            Enumerate a directory at the given path, if any.
            

    - Parameter subpath: Relative path that identifies the directory.
    - Returns: Returns the contents of the directory.

    */
    open func GetDirectoryContents(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileProvider_IDirectoryContents__GetDirectoryContents_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileProviders.IFileInfo GetFileInfo(System.String)
// docid: M:Microsoft.Extensions.FileProviders.IFileProvider.GetFileInfo(System.String)
    /**
    
            Locate a file at the given path.
            

    - Parameter subpath: Relative path that identifies the file.
    - Returns: The file information. Caller must check Exists property.

    */
    open func GetFileInfo(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileProvider_IFileInfo__GetFileInfo_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Primitives.IChangeToken Watch(System.String)
// docid: M:Microsoft.Extensions.FileProviders.IFileProvider.Watch(System.String)
    /**
    
            Creates a  for the specified .
            

    - Parameter filter: Filter string used to determine what files or folders to monitor. Example: (ASTERISK)(ASTERISK)/(ASTERISK).cs, (ASTERISK).(ASTERISK), subFolder/(ASTERISK)(ASTERISK)/(ASTERISK).cshtml.
    - Returns: An  that is notified when a file matching  is added, modified or deleted.

    */
    open func Watch(filter : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_IFileProvider_IChangeToken__Watch_0__1__String(&__thrown, self.get_handle(), filter?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Primitives.IChangeToken(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IFileProvider


// type: Microsoft.Extensions.FileProviders.NotFoundDirectoryContents
    /**
    
            Represents a non-existing directory
            

    */
open class NotFoundDirectoryContents
    :
    dotnet.System.Object,
    System_Collections_IEnumerable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_NotFoundDirectoryContents_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundDirectoryContents.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_NotFoundDirectoryContents_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IEnumerator<Microsoft.Extensions.FileProviders.IFileInfo> GetEnumerator()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundDirectoryContents.GetEnumerator
    /**
    Returns an enumerator that iterates through the collection.

    - Returns: An enumerator to an empty collection.

    */
    open /* method final */ func GetEnumerator() throws -> Optional<dotnet.System.Collections.Generic.IEnumerator_1<aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundDirectoryContents_System_Collections_Generic_IEnumerator_Microsoft_Extensions_FileProviders_IFileInfo___GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerator_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundDirectoryContents.get_Exists
    open /* method final */ func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundDirectoryContents_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileProviders.NotFoundDirectoryContents get_Singleton()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundDirectoryContents.get_Singleton
    open class func get_Singleton() throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.NotFoundDirectoryContents> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundDirectoryContents_NotFoundDirectoryContents__get_Singleton_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.NotFoundDirectoryContents(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Always false.
            

    */
    public var Exists : Bool {
        get {
            return try! get_Exists();
        }
    }
    /**
    
            A shared instance of 
            

    */
    public static var Singleton : Optional<aspnetcore.Microsoft.Extensions.FileProviders.NotFoundDirectoryContents> {
        get {
            return try! get_Singleton();
        }
    }
} // NotFoundDirectoryContents


// type: Microsoft.Extensions.FileProviders.NotFoundFileInfo
    /**
    
            Represents a non-existing file.
            

    */
open class NotFoundFileInfo
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileProviders_IFileInfo
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_NotFoundFileInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String)
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.#ctor(System.String)
    /**
    
            Initializes an instance of .
            

    - Parameter name: The name of the file that could not be found
    */
    public init(name : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_NotFoundFileInfo_ctor_0__1__String(&__thrown, name?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IO.Stream CreateReadStream()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.CreateReadStream
    /**
    
            Always throws. A stream cannot be created for non-existing file.
            

    - Returns: Does not return

    */
    open /* method final */ func CreateReadStream() throws -> Optional<dotnet.System.IO.Stream> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_Stream__CreateReadStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IO.Stream(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Exists()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_Exists
    open /* method final */ func get_Exists() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_bool__get_Exists_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsDirectory()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_IsDirectory
    open /* method final */ func get_IsDirectory() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_bool__get_IsDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.DateTimeOffset get_LastModified()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_LastModified
    open /* method final */ func get_LastModified() throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_DateTimeOffset__get_LastModified_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_Length
    open /* method final */ func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_Name
    open /* method final */ func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_PhysicalPath()
// docid: M:Microsoft.Extensions.FileProviders.NotFoundFileInfo.get_PhysicalPath
    open /* method final */ func get_PhysicalPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NotFoundFileInfo_String__get_PhysicalPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Always false.
            

    */
    public var Exists : Bool {
        get {
            return try! get_Exists();
        }
    }
    /**
    
            Always false.
            

    */
    public var IsDirectory : Bool {
        get {
            return try! get_IsDirectory();
        }
    }
    /**
    
            Returns .
            

    */
    public var LastModified : dotnet.System.DateTimeOffset {
        get {
            return try! get_LastModified();
        }
    }
    /**
    
            Always equals -1.
            

    */
    public var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    */
    public var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    
            Always null.
            

    */
    public var PhysicalPath : Optional<dotnet.System.String> {
        get {
            return try! get_PhysicalPath();
        }
    }
} // NotFoundFileInfo


// type: Microsoft.Extensions.FileProviders.NullChangeToken
    /**
    
            An empty change token that doesn't raise any change callbacks.
            

    */
open class NullChangeToken
    :
    dotnet.System.Object,
    Microsoft_Extensions_Primitives_IChangeToken
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_NullChangeToken_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.IDisposable RegisterChangeCallback(System.Action<System.Object>, System.Object)
// docid: M:Microsoft.Extensions.FileProviders.NullChangeToken.RegisterChangeCallback(System.Action{System.Object},System.Object)
    /**
    
            Always returns an empty disposable object. Callbacks will never be called.
            

    - Parameter callback: This parameter is ignored
    - Parameter state: This parameter is ignored
    - Returns: A disposable object that noops on dispose.

    */
    open /* method final */ func RegisterChangeCallback(callback : Optional<dotnet.System.Action_1<dotnet.System.Object>>, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IDisposable> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullChangeToken_IDisposable__RegisterChangeCallback_0__2__System_Action_object__Object(&__thrown, self.get_handle(), (callback?.get_handle()), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IDisposable(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func RegisterChangeCallback(callback : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IDisposable> {
        let del_callback = try dotnet.System.Action_1<dotnet.System.Object>(callback);
        return try RegisterChangeCallback(callback: del_callback, state: state);
    }
    // [IsSpecialName] bool get_ActiveChangeCallbacks()
// docid: M:Microsoft.Extensions.FileProviders.NullChangeToken.get_ActiveChangeCallbacks
    open /* method final */ func get_ActiveChangeCallbacks() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullChangeToken_bool__get_ActiveChangeCallbacks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HasChanged()
// docid: M:Microsoft.Extensions.FileProviders.NullChangeToken.get_HasChanged
    open /* method final */ func get_HasChanged() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullChangeToken_bool__get_HasChanged_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileProviders.NullChangeToken get_Singleton()
// docid: M:Microsoft.Extensions.FileProviders.NullChangeToken.get_Singleton
    open class func get_Singleton() throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.NullChangeToken> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullChangeToken_NullChangeToken__get_Singleton_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.NullChangeToken(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Always false.
            

    */
    public var ActiveChangeCallbacks : Bool {
        get {
            return try! get_ActiveChangeCallbacks();
        }
    }
    /**
    
            Always false.
            

    */
    public var HasChanged : Bool {
        get {
            return try! get_HasChanged();
        }
    }
    /**
    
            A singleton instance of 
            

    */
    public static var Singleton : Optional<aspnetcore.Microsoft.Extensions.FileProviders.NullChangeToken> {
        get {
            return try! get_Singleton();
        }
    }
} // NullChangeToken


// type: Microsoft.Extensions.FileProviders.NullFileProvider
    /**
    
            An empty file provider with no contents.
            

    */
open class NullFileProvider
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileProviders_IFileProvider
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileProviders_NullFileProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileProviders.NullFileProvider.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileProviders_NullFileProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.FileProviders.IDirectoryContents GetDirectoryContents(System.String)
// docid: M:Microsoft.Extensions.FileProviders.NullFileProvider.GetDirectoryContents(System.String)
    /**
    
            Enumerate a non-existent directory.
            

    - Parameter subpath: A path under the root directory. This parameter is ignored.
    - Returns: A  that does not exist and does not contain any contents.

    */
    open /* method final */ func GetDirectoryContents(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullFileProvider_IDirectoryContents__GetDirectoryContents_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IDirectoryContents(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileProviders.IFileInfo GetFileInfo(System.String)
// docid: M:Microsoft.Extensions.FileProviders.NullFileProvider.GetFileInfo(System.String)
    /**
    
            Locate a non-existent file.
            

    - Parameter subpath: A path under the root directory.
    - Returns: A  representing a non-existent file at the given path.

    */
    open /* method final */ func GetFileInfo(subpath : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullFileProvider_IFileInfo__GetFileInfo_0__1__String(&__thrown, self.get_handle(), subpath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Primitives.IChangeToken Watch(System.String)
// docid: M:Microsoft.Extensions.FileProviders.NullFileProvider.Watch(System.String)
    /**
    
            Returns a  that monitors nothing.
            

    - Parameter filter: Filter string used to determine what files or folders to monitor. This parameter is ignored.
    - Returns: A  that does not register callbacks.

    */
    open /* method final */ func Watch(filter : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Primitives.IChangeToken> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileProviders_NullFileProvider_IChangeToken__Watch_0__1__String(&__thrown, self.get_handle(), filter?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Primitives.IChangeToken(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // NullFileProvider


}



public protocol Microsoft_Extensions_FileProviders_IDirectoryContents
    :
    System_Collections_Generic_IEnumerable_1
    where
        T_IEnumerable_1 == aspnetcore.Microsoft.Extensions.FileProviders.IFileInfo
{
}

public protocol Microsoft_Extensions_FileProviders_IFileInfo
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_FileProviders_IFileProvider
    :
    SGBridgeGetHandle
{
}

