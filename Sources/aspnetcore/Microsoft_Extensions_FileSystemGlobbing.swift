// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.FileSystemGlobbing
extension Microsoft.Extensions.FileSystemGlobbing {
// type: Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch
// boxed value type
    /**
    
            Represents a file that was matched by searching using a globbing pattern
            

    */
public final class FilePatternMatch
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    
            The path to the file matched, relative to the beginning of the matching search pattern.
            

    */
    public var Path : Optional<dotnet.System.String> {
        get {
            return try! get_Path();
        }
    }
    /**
    
            The subpath to the file matched, relative to the first wildcard in the matching search pattern.
            

    */
    public var Stem : Optional<dotnet.System.String> {
        get {
            return try! get_Stem();
        }
    }
    // .ctor(System.String, System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.#ctor(System.String,System.String)
    /**
    
            Initializes new instance of 
            

    - Parameter path: The path to the file matched, relative to the beginning of the matching search pattern.
    - Parameter stem: The subpath to the file matched, relative to the first wildcard in the matching search pattern.
    */
    public init(path : Optional<dotnet.System.String>, stem : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_ctor_0__2__String_String(&__thrown, path?.get_handle() ?? nil, stem?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Equals(Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch)
    /**
    
            Determines if the specified match is equivalent to the current match using a case-insensitive comparison.
            

    - Parameter other: The other match to be compared
    - Returns: True if  and  are equal using case-insensitive comparison

    */
    public func Equals(other : aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_bool__Equals_0__1__FilePatternMatch(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Object)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.Equals(System.Object)
    /**
    
            Determines if the specified object is equivalent to the current match using a case-insensitive comparison.
            

    - Parameter obj: The object to be compared
    - Returns: True when 

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.GetHashCode
    /**
    
            Gets a hash for the file pattern match.
            

    - Returns: Some number

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Path()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.get_Path
    public func get_Path() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_String__get_Path_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Stem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch.get_Stem
    public func get_Stem() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_String__get_Stem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // FilePatternMatch


// type: Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo
    /**
    
            Avoids using disk for uses like Pattern Matching.
            

    */
open class InMemoryDirectoryInfo
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Collections.Generic.IEnumerable<System.String>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})
    /**
    
            Creates a new InMemoryDirectoryInfo with the root directory and files given.
            

    - Parameter rootDir: The root directory that this FileSystem will use.
    - Parameter files: Collection of file names. If relative paths  will be prepended to the paths.
    */
    public init(rootDir : Optional<dotnet.System.String>, files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_ctor_0__2__String_System_Collections_Generic_IEnumerable_string_(&__thrown, rootDir?.get_handle() ?? nil, (files?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase> EnumerateFileSystemInfos()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.EnumerateFileSystemInfos
    /**
    */
    open override func EnumerateFileSystemInfos() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase___EnumerateFileSystemInfos_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase GetDirectory(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.GetDirectory(System.String)
    /**
    */
    open override func GetDirectory(path : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_DirectoryInfoBase__GetDirectory_0__1__String(&__thrown, self.get_handle(), path?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase GetFile(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.GetFile(System.String)
    /**
    
            Returns an instance of  that matches the  given.
            

    - Parameter path: The filename.
    - Returns: Instance of  if the file exists, null otherwise.

    */
    open override func GetFile(path : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_FileInfoBase__GetFile_0__1__String(&__thrown, self.get_handle(), path?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_FullName()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.get_FullName
    open override func get_FullName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_String__get_FullName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.get_Name
    open override func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase get_ParentDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo.get_ParentDirectory
    open override func get_ParentDirectory() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_InMemoryDirectoryInfo_DirectoryInfoBase__get_ParentDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    */
    open override var FullName : Optional<dotnet.System.String> {
        get {
            return try! get_FullName();
        }
    }
    /**
    */
    open override var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    */
    open override var ParentDirectory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        get {
            return try! get_ParentDirectory();
        }
    }
} // InMemoryDirectoryInfo


// type: Microsoft.Extensions.FileSystemGlobbing.Matcher
    /**
    
            Searches the file system for files with names that match specified patterns.
            

    */
open class Matcher
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Matcher_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Matcher.#ctor
    /**
    
            Initializes an instance of  using case-insensitive matching
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Matcher_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.StringComparison)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Matcher.#ctor(System.StringComparison)
    /**
    
            Initializes an instance of  using the string comparison method specified
            

    - Parameter comparisonType: The  to use
    */
    public init(comparisonType : dotnet.System.StringComparison) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Matcher_ctor_0__1__StringComparison(&__thrown, comparisonType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Matcher AddExclude(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Matcher.AddExclude(System.String)
    /**
    
                
                Add a file name pattern for files the matcher should exclude from the results. Patterns are relative to the
                root directory given when  is called.
                
                
                Use the forward slash '/' to represent directory separator. Use '(ASTERISK)' to represent wildcards in file and
                directory names. Use '(ASTERISK)(ASTERISK)' to represent arbitrary directory depth. Use '..' to represent a parent directory.
                
            

    - Parameter pattern: The globbing pattern
    - Returns: The matcher

    */
    open func AddExclude(pattern : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Matcher_Matcher__AddExclude_0__1__String(&__thrown, self.get_handle(), pattern?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Matcher AddInclude(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Matcher.AddInclude(System.String)
    /**
    
                
                Add a file name pattern that the matcher should use to discover files. Patterns are relative to the root
                directory given when  is called.
                
                
                Use the forward slash '/' to represent directory separator. Use '(ASTERISK)' to represent wildcards in file and
                directory names. Use '(ASTERISK)(ASTERISK)' to represent arbitrary directory depth. Use '..' to represent a parent directory.
                
            

    - Parameter pattern: The globbing pattern
    - Returns: The matcher

    */
    open func AddInclude(pattern : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Matcher_Matcher__AddInclude_0__1__String(&__thrown, self.get_handle(), pattern?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Execute(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Matcher.Execute(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    /**
    
            Searches the directory specified for all files matching patterns added to this instance of 
            

    - Parameter directoryInfo: The root directory for the search
    - Returns: Always returns instance of , even if not files were matched

    */
    open func Execute(directoryInfo : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Matcher_PatternMatchingResult__Execute_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directoryInfo?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // Matcher


// type: Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions
public struct MatcherExtensions {
    // void AddExcludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>[])
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddExcludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.Collections.Generic.IEnumerable`1[])
    public static func AddExcludePatterns(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, excludePatternsGroups : Optional<dotnet.System_Arr<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_void__AddExcludePatterns_0__2__Matcher_System_Collections_Generic_IEnumerable_string_Array(&__thrown, matcher?.get_handle() ?? nil, (excludePatternsGroups?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddIncludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>[])
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddIncludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.Collections.Generic.IEnumerable`1[])
    public static func AddIncludePatterns(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, includePatternsGroups : Optional<dotnet.System_Arr<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_void__AddIncludePatterns_0__2__Matcher_System_Collections_Generic_IEnumerable_string_Array(&__thrown, matcher?.get_handle() ?? nil, (includePatternsGroups?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.Generic.IEnumerable<System.String> GetResultsInFullPath(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.GetResultsInFullPath(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.String)
    /**
    
            Searches the directory specified for all files matching patterns added to this instance of 
            

    - Parameter matcher: The matcher
    - Parameter directoryPath: The root directory for the search
    - Returns: Absolute file paths of all files matched. Empty enumerable if no files matched given patterns.

    */
    public static func GetResultsInFullPath(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, directoryPath : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_System_Collections_Generic_IEnumerable_string___GetResultsInFullPath_0__2__Matcher_String(&__thrown, matcher?.get_handle() ?? nil, directoryPath?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.Collections.Generic.IEnumerable{System.String})
    /**
    
            Matches the files passed in with the patterns in the matcher without going to disk.
            

    - Parameter matcher: The matcher that holds the patterns and pattern matching type.
    - Parameter files: The files to run the matcher against.
    - Returns: The match results.

    */
    public static func Match(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_PatternMatchingResult__Match_0__2__Matcher_System_Collections_Generic_IEnumerable_string_(&__thrown, matcher?.get_handle() ?? nil, (files?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.String)
    /**
    
            Matches the file passed in with the patterns in the matcher without going to disk.
            

    - Parameter matcher: The matcher that holds the patterns and pattern matching type.
    - Parameter file: The file to run the matcher against.
    - Returns: The match results.

    */
    public static func Match(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, file : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_PatternMatchingResult__Match_0__2__Matcher_String(&__thrown, matcher?.get_handle() ?? nil, file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String, System.Collections.Generic.IEnumerable<System.String>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.String,System.Collections.Generic.IEnumerable{System.String})
    /**
    
            Matches the files passed in with the patterns in the matcher without going to disk.
            

    - Parameter matcher: The matcher that holds the patterns and pattern matching type.
    - Parameter rootDir: The root directory for the matcher to match the files from.
    - Parameter files: The files to run the matcher against.
    - Returns: The match results.

    */
    public static func Match(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, rootDir : Optional<dotnet.System.String>, files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_PatternMatchingResult__Match_0__3__Matcher_String_System_Collections_Generic_IEnumerable_string_(&__thrown, matcher?.get_handle() ?? nil, rootDir?.get_handle() ?? nil, (files?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String, System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(Microsoft.Extensions.FileSystemGlobbing.Matcher,System.String,System.String)
    /**
    
            Matches the file passed in with the patterns in the matcher without going to disk.
            

    - Parameter matcher: The matcher that holds the patterns and pattern matching type.
    - Parameter rootDir: The root directory for the matcher to match the file from.
    - Parameter file: The file to run the matcher against.
    - Returns: The match results.

    */
    public static func Match(matcher : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher>, rootDir : Optional<dotnet.System.String>, file : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_MatcherExtensions_PatternMatchingResult__Match_0__3__Matcher_String_String(&__thrown, matcher?.get_handle() ?? nil, rootDir?.get_handle() ?? nil, file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // MatcherExtensions


// type: Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult
    /**
    
            Represents a collection of 
            

    */
open class PatternMatchingResult
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch})
    /**
    
            Initializes the result with a collection of 
            

    - Parameter files: A collection of 
    */
    public init(files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_ctor_0__1__System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_(&__thrown, (files?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>, bool)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch},System.Boolean)
    /**
    
            Initializes the result with a collection of 
            

    - Parameter files: A collection of 
    - Parameter hasMatches: A value that determines if  has any matches.
    */
    public init(files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>>, hasMatches : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_ctor_0__2__System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch__bool(&__thrown, (files?.get_handle()), Swift.Int32(hasMatches ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch> get_Files()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.get_Files
    open func get_Files() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch___get_Files_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Files(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.set_Files(System.Collections.Generic.IEnumerable{Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch})
    open func set_Files(value : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_void__set_Files_0__1__System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_FilePatternMatch_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_HasMatches()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult.get_HasMatches
    open func get_HasMatches() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_PatternMatchingResult_bool__get_HasMatches_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    
            A collection of 
            

    */
    open var Files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch>> {
        get {
            return try! get_Files();
        }
        set(v) {
            return try! set_Files(value: v!);
        }
    }
    /**
    
            Gets a value that determines if this instance of  has any matches.
            

    */
    open var HasMatches : Bool {
        get {
            return try! get_HasMatches();
        }
    }
} // PatternMatchingResult


}
// Microsoft.Extensions.FileSystemGlobbing.Abstractions
extension Microsoft.Extensions.FileSystemGlobbing.Abstractions {
// type: Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
    /**
    
            Represents a directory
            

    */
open class DirectoryInfoBase
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoBase_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase> EnumerateFileSystemInfos()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.EnumerateFileSystemInfos
    /**
    
            Enumerates all files and directories in the directory.
            

    - Returns: Collection of files and directories

    */
    open func EnumerateFileSystemInfos() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoBase_System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase___EnumerateFileSystemInfos_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase GetDirectory(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.GetDirectory(System.String)
    /**
    
            Returns an instance of  that represents a subdirectory
            

    - Parameter path: The directory name
    - Returns: Instance of  even if directory does not exist

    */
    open func GetDirectory(path : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoBase_DirectoryInfoBase__GetDirectory_0__1__String(&__thrown, self.get_handle(), path?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase GetFile(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase.GetFile(System.String)
    /**
    
            Returns an instance of  that represents a file in the directory
            

    - Parameter path: The file name
    - Returns: Instance of  even if file does not exist

    */
    open func GetFile(path : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoBase_FileInfoBase__GetFile_0__1__String(&__thrown, self.get_handle(), path?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // DirectoryInfoBase


// type: Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper
    /**
    
            Wraps an instance of  and provides implementation of
            .
            

    */
open class DirectoryInfoWrapper
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.DirectoryInfo)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.#ctor(System.IO.DirectoryInfo)
    /**
    
            Initializes an instance of .
            

    - Parameter directoryInfo: The .
    */
    public init(directoryInfo : Optional<dotnet.System.IO.DirectoryInfo>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_ctor_0__1__DirectoryInfo(&__thrown, directoryInfo?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase> EnumerateFileSystemInfos()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.EnumerateFileSystemInfos
    /**
    */
    open override func EnumerateFileSystemInfos() throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase___EnumerateFileSystemInfos_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase GetDirectory(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.GetDirectory(System.String)
    /**
    
            Returns an instance of  that represents a subdirectory.
            

    - Parameter name: The directory name
    - Returns: The directory

    */
    open func GetDirectory(name : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_DirectoryInfoBase__GetDirectory_0__1__String(&__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase GetFile(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.GetFile(System.String)
    /**
    */
    open func GetFile(name : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_FileInfoBase__GetFile_0__1__String(&__thrown, self.get_handle(), name?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_FullName()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.get_FullName
    open override func get_FullName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_String__get_FullName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.get_Name
    open override func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase get_ParentDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper.get_ParentDirectory
    open override func get_ParentDirectory() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_DirectoryInfoWrapper_DirectoryInfoBase__get_ParentDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            Returns the full path to the directory.
            

    */
    open override var FullName : Optional<dotnet.System.String> {
        get {
            return try! get_FullName();
        }
    }
    /**
    */
    open override var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    
            Returns the parent directory.
            

    */
    open override var ParentDirectory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        get {
            return try! get_ParentDirectory();
        }
    }
} // DirectoryInfoWrapper


// type: Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase
    /**
    
            Represents a file
            

    */
open class FileInfoBase
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoBase_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // FileInfoBase


// type: Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper
    /**
    
            Wraps an instance of  to provide implementation of .
            

    */
open class FileInfoWrapper
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoWrapper_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.FileInfo)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.#ctor(System.IO.FileInfo)
    /**
    
            Initializes instance of  to wrap the specified object .
            

    - Parameter fileInfo: The 
    */
    public init(fileInfo : Optional<dotnet.System.IO.FileInfo>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoWrapper_ctor_0__1__FileInfo(&__thrown, fileInfo?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_FullName()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.get_FullName
    open override func get_FullName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoWrapper_String__get_FullName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.get_Name
    open override func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoWrapper_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase get_ParentDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper.get_ParentDirectory
    open override func get_ParentDirectory() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileInfoWrapper_DirectoryInfoBase__get_ParentDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            The full path of the file. (Overrides ).
            

    */
    open override var FullName : Optional<dotnet.System.String> {
        get {
            return try! get_FullName();
        }
    }
    /**
    
            The file name. (Overrides ).
            

    */
    open override var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    
            The directory containing the file. (Overrides ).
            

    */
    open override var ParentDirectory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        get {
            return try! get_ParentDirectory();
        }
    }
} // FileInfoWrapper


// type: Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase
    /**
    
            Shared abstraction for files and directories
            

    */
open class FileSystemInfoBase
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.String get_FullName()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.get_FullName
    open func get_FullName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase_String__get_FullName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.get_Name
    open func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase get_ParentDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase.get_ParentDirectory
    open func get_ParentDirectory() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Abstractions_FileSystemInfoBase_DirectoryInfoBase__get_ParentDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            A string containing the full path of the file or directory
            

    */
    open var FullName : Optional<dotnet.System.String> {
        get {
            return try! get_FullName();
        }
    }
    /**
    
            A string containing the name of the file or directory
            

    */
    open var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    
            The parent directory for the current file or directory
            

    */
    open var ParentDirectory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase> {
        get {
            return try! get_ParentDirectory();
        }
    }
} // FileSystemInfoBase


}

// Microsoft.Extensions.FileSystemGlobbing.Internal
extension Microsoft.Extensions.FileSystemGlobbing.Internal {
// type: Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class ILinearPattern
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileSystemGlobbing_Internal_ILinearPattern,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_ILinearPattern_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment> get_Segments()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern.get_Segments
    open func get_Segments() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_ILinearPattern_System_Collections_Generic_IList_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment___get_Segments_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ILinearPattern


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IPathSegment
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment.Match(System.String)
    open func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment.get_CanProduceStem
    open func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // IPathSegment


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IPattern
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext CreatePatternContextForExclude()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern.CreatePatternContextForExclude
    open func CreatePatternContextForExclude() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern_IPatternContext__CreatePatternContextForExclude_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext CreatePatternContextForInclude()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern.CreatePatternContextForInclude
    open func CreatePatternContextForInclude() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern_IPatternContext__CreatePatternContextForInclude_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IPattern


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IPatternContext
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,bool>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Declare(System.Action{Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,System.Boolean})
    open func Declare(onDeclare : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_void__Declare_0__1__System_Action_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool_(&__thrown, self.get_handle(), (onDeclare?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Declare(onDeclare : @escaping (Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>, Bool) throws -> Void) throws {
        let del_onDeclare = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Swift.Bool>(onDeclare);
        return try Declare(onDeclare: del_onDeclare);
    }
    // void PopDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.PopDirectory
    open func PopDirectory() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_void__PopDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open func PushDirectory(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_void__PushDirectory_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_bool__Test_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
    open func Test(file : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase>) throws -> aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext_PatternTestResult__Test_0__1__FileInfoBase(&__thrown, self.get_handle(), file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl : __return);
        }
    }
} // IPatternContext


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class IRaggedPattern
    :
    SGBridgeGenericValue,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
{
    open class func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // [IsSpecialName] System.Collections.Generic.IList<System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>> get_Contains()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.get_Contains
    open func get_Contains() throws -> Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern_System_Collections_Generic_IList_System_Collections_Generic_System_Collections_Generic_IList_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment____get_Contains_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment> get_EndsWith()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.get_EndsWith
    open func get_EndsWith() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern_System_Collections_Generic_IList_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment___get_EndsWith_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment> get_Segments()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.get_Segments
    open func get_Segments() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern_System_Collections_Generic_IList_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment___get_Segments_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment> get_StartsWith()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern.get_StartsWith
    open func get_StartsWith() throws -> Optional<dotnet.System.Collections.Generic.IList_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern_System_Collections_Generic_IList_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment___get_StartsWith_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // IRaggedPattern


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class MatcherContext
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_MatcherContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern>, System.Collections.Generic.IEnumerable<Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern>, Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase, System.StringComparison)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern},System.Collections.Generic.IEnumerable{Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern},Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase,System.StringComparison)
    public init(includePatterns : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern>>, excludePatterns : Optional<dotnet.System.Collections.Generic.IEnumerable_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern>>, directoryInfo : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>, comparison : dotnet.System.StringComparison) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_MatcherContext_ctor_0__4__System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern__System_Collections_Generic_IEnumerable_Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern__DirectoryInfoBase_StringComparison(&__thrown, (includePatterns?.get_handle()), (excludePatterns?.get_handle()), directoryInfo?.get_handle() ?? nil, comparison.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Execute()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext.Execute
    open func Execute() throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_MatcherContext_PatternMatchingResult__Execute_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // MatcherContext


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult
// boxed value type
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
public final class PatternTestResult
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Failed
    public class var Failed : aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        get {
        let __return = aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl: Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_get_Failed());
            return __return;
        }
    }
    public var IsSuccessful : Bool {
        get {
            return try! get_IsSuccessful();
        }
    }
    public var Stem : Optional<dotnet.System.String> {
        get {
            return try! get_Stem();
        }
    }
    public override init() {
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_implicit_ctor();
            super.init(hndl: h);
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Success(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.Success(System.String)
    public class func Success(stem : Optional<dotnet.System.String>) throws -> aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_PatternTestResult__Success_0__1__String(&__thrown, stem?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsSuccessful()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.get_IsSuccessful
    public func get_IsSuccessful() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_bool__get_IsSuccessful_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Stem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult.get_Stem
    public func get_Stem() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternTestResult_String__get_Stem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // PatternTestResult


}
// Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments
extension Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments {
// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment
open class CurrentPathSegment
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_CurrentPathSegment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_CurrentPathSegment_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.Match(System.String)
    open /* method final */ func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_CurrentPathSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment.get_CanProduceStem
    open /* method final */ func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_CurrentPathSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public var CanProduceStem : Bool {
        get {
            return try! get_CanProduceStem();
        }
    }
} // CurrentPathSegment


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment
open class LiteralPathSegment
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.StringComparison)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.#ctor(System.String,System.StringComparison)
    public init(value : Optional<dotnet.System.String>, comparisonType : dotnet.System.StringComparison) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_ctor_0__2__String_StringComparison(&__thrown, value?.get_handle() ?? nil, comparisonType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Equals(System.Object)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.Equals(System.Object)
    open override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.GetHashCode
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.Match(System.String)
    open /* method final */ func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.get_CanProduceStem
    open /* method final */ func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Value()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment.get_Value
    open func get_Value() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_LiteralPathSegment_String__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    public var CanProduceStem : Bool {
        get {
            return try! get_CanProduceStem();
        }
    }
    open var Value : Optional<dotnet.System.String> {
        get {
            return try! get_Value();
        }
    }
} // LiteralPathSegment


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment
open class ParentPathSegment
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_ParentPathSegment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_ParentPathSegment_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.Match(System.String)
    open /* method final */ func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_ParentPathSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment.get_CanProduceStem
    open /* method final */ func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_ParentPathSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public var CanProduceStem : Bool {
        get {
            return try! get_CanProduceStem();
        }
    }
} // ParentPathSegment


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment
open class RecursiveWildcardSegment
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_RecursiveWildcardSegment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_RecursiveWildcardSegment_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.Match(System.String)
    open /* method final */ func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_RecursiveWildcardSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment.get_CanProduceStem
    open /* method final */ func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_RecursiveWildcardSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public var CanProduceStem : Bool {
        get {
            return try! get_CanProduceStem();
        }
    }
} // RecursiveWildcardSegment


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment
open class WildcardPathSegment
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment MatchAll
    open class var MatchAll : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment> {
        get {
        let __h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_get_MatchAll();
        let __return = (__h != nil) ? aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment(hndl: __h!) : nil;
            return __return;
        }
    }
    // .ctor(System.String, System.Collections.Generic.List<System.String>, System.String, System.StringComparison)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.#ctor(System.String,System.Collections.Generic.List{System.String},System.String,System.StringComparison)
    public init(beginsWith : Optional<dotnet.System.String>, contains : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.String>>, endsWith : Optional<dotnet.System.String>, comparisonType : dotnet.System.StringComparison) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_ctor_0__4__String_System_Collections_Generic_List_string__String_StringComparison(&__thrown, beginsWith?.get_handle() ?? nil, (contains?.get_handle()), endsWith?.get_handle() ?? nil, comparisonType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Match(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.Match(System.String)
    open /* method final */ func Match(value : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_bool__Match_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_BeginsWith()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.get_BeginsWith
    open func get_BeginsWith() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_String__get_BeginsWith_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_CanProduceStem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.get_CanProduceStem
    open /* method final */ func get_CanProduceStem() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_bool__get_CanProduceStem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Collections.Generic.List<System.String> get_Contains()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.get_Contains
    open func get_Contains() throws -> Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_System_Collections_Generic_List_string___get_Contains_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.List_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_EndsWith()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment.get_EndsWith
    open func get_EndsWith() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PathSegments_WildcardPathSegment_String__get_EndsWith_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    open var BeginsWith : Optional<dotnet.System.String> {
        get {
            return try! get_BeginsWith();
        }
    }
    public var CanProduceStem : Bool {
        get {
            return try! get_CanProduceStem();
        }
    }
    open var Contains : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.String>> {
        get {
            return try! get_Contains();
        }
    }
    open var EndsWith : Optional<dotnet.System.String> {
        get {
            return try! get_EndsWith();
        }
    }
} // WildcardPathSegment


}

// Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts
extension Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts {
// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear
open class PatternContextLinear
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear_FrameData>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
    public init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_ctor_0__1__ILinearPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open override func PushDirectory(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_void__PushDirectory_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
    open override func Test(file : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase>) throws -> aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_PatternTestResult__Test_0__1__FileInfoBase(&__thrown, self.get_handle(), file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl : __return);
        }
    }
} // PatternContextLinear


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear+FrameData
// boxed value type
public final class PatternContextLinear_FrameData
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_FrameData_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public var Stem : Optional<dotnet.System.String> {
        get {
            return try! get_Stem();
        }
    }
    public var StemItems : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        get {
            return try! get_StemItems();
        }
    }
    public override init() {
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_FrameData_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.String get_Stem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.get_Stem
    public func get_Stem() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_FrameData_String__get_Stem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<System.String> get_StemItems()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear.FrameData.get_StemItems
    public func get_StemItems() throws -> Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinear_FrameData_System_Collections_Generic_IList_string___get_StemItems_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // PatternContextLinear_FrameData


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude
open class PatternContextLinearExclude
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearExclude_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
    public override init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearExclude_ctor_0__1__ILinearPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open override func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearExclude_bool__Test_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // PatternContextLinearExclude


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude
open class PatternContextLinearInclude
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearInclude_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern)
    public override init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearInclude_ctor_0__1__ILinearPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,bool>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.Declare(System.Action{Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,System.Boolean})
    open func Declare(onDeclare : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearInclude_void__Declare_0__1__System_Action_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool_(&__thrown, self.get_handle(), (onDeclare?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Declare(onDeclare : @escaping (Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>, Bool) throws -> Void) throws {
        let del_onDeclare = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Swift.Bool>(onDeclare);
        return try Declare(onDeclare: del_onDeclare);
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open override func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextLinearInclude_bool__Test_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // PatternContextLinearInclude


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged
open class PatternContextRagged
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext_1<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged_FrameData>
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
    public init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_ctor_0__1__IRaggedPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void PopDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.PopDirectory
    open override func PopDirectory() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_void__PopDirectory_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open /* method final */ override func PushDirectory(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_void__PushDirectory_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
    open override func Test(file : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase>) throws -> aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_PatternTestResult__Test_0__1__FileInfoBase(&__thrown, self.get_handle(), file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl : __return);
        }
    }
} // PatternContextRagged


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged+FrameData
// boxed value type
public final class PatternContextRagged_FrameData
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_FrameData_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public var Stem : Optional<dotnet.System.String> {
        get {
            return try! get_Stem();
        }
    }
    public var StemItems : Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        get {
            return try! get_StemItems();
        }
    }
    public override init() {
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_FrameData_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.String get_Stem()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.get_Stem
    public func get_Stem() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_FrameData_String__get_Stem_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Collections.Generic.IList<System.String> get_StemItems()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged.FrameData.get_StemItems
    public func get_StemItems() throws -> Optional<dotnet.System.Collections.Generic.IList_1<dotnet.System.String>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRagged_FrameData_System_Collections_Generic_IList_string___get_StemItems_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IList_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // PatternContextRagged_FrameData


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude
open class PatternContextRaggedExclude
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedExclude_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
    public override init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedExclude_ctor_0__1__IRaggedPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open override func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedExclude_bool__Test_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // PatternContextRaggedExclude


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude
open class PatternContextRaggedInclude
    :
    aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedInclude_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.#ctor(Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern)
    public override init(pattern : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedInclude_ctor_0__1__IRaggedPattern(&__thrown, pattern?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,bool>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.Declare(System.Action{Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,System.Boolean})
    open func Declare(onDeclare : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedInclude_void__Declare_0__1__System_Action_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool_(&__thrown, self.get_handle(), (onDeclare?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Declare(onDeclare : @escaping (Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>, Bool) throws -> Void) throws {
        let del_onDeclare = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Swift.Bool>(onDeclare);
        return try Declare(onDeclare: del_onDeclare);
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open override func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContextRaggedInclude_bool__Test_0__1__DirectoryInfoBase(&__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // PatternContextRaggedInclude


// type: Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1
open class PatternContext_1<TFrame : SGBridgeGenericValue>
    :
    dotnet.System.Object,
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_get_type_handle(TFrame.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Declare(System.Action<Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,bool>)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1.Declare(System.Action{Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,System.Boolean})
    open func Declare(declare : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Bool>>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_void__Declare_0__1__System_Action_Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment_bool_(TFrame.get_type_handle(), &__thrown, self.get_handle(), (declare?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func Declare(declare : @escaping (Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment>, Bool) throws -> Void) throws {
        let del_declare = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment,Swift.Bool>(declare);
        return try Declare(declare: del_declare);
    }
    // void PopDirectory()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1.PopDirectory
    open func PopDirectory() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_void__PopDirectory_0__0(TFrame.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1.PushDirectory(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open func PushDirectory(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_void__PushDirectory_0__1__DirectoryInfoBase(TFrame.get_type_handle(), &__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase)
    open func Test(directory : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_bool__Test_0__1__DirectoryInfoBase(TFrame.get_type_handle(), &__thrown, self.get_handle(), directory?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1.Test(Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase)
    open func Test(file : Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase>) throws -> aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_PatternContexts_PatternContext_1_PatternTestResult__Test_0__1__FileInfoBase(TFrame.get_type_handle(), &__thrown, self.get_handle(), file?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult(hndl : __return);
        }
    }
} // PatternContext_1


}

// Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns
extension Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns {
// type: Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder
open class PatternBuilder
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_FileSystemGlobbing_Internal_Patterns_PatternBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_Patterns_PatternBuilder_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.StringComparison)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.#ctor(System.StringComparison)
    public init(comparisonType : dotnet.System.StringComparison) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_FileSystemGlobbing_Internal_Patterns_PatternBuilder_ctor_0__1__StringComparison(&__thrown, comparisonType.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern Build(System.String)
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.Build(System.String)
    open func Build(pattern : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_Patterns_PatternBuilder_IPattern__Build_0__1__String(&__thrown, self.get_handle(), pattern?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.StringComparison get_ComparisonType()
// docid: M:Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder.get_ComparisonType
    open func get_ComparisonType() throws -> dotnet.System.StringComparison {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_FileSystemGlobbing_Internal_Patterns_PatternBuilder_StringComparison__get_ComparisonType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.StringComparison(val: __return);
        }
    }
    open var ComparisonType : dotnet.System.StringComparison {
        get {
            return try! get_ComparisonType();
        }
    }
} // PatternBuilder


}





public protocol Microsoft_Extensions_FileSystemGlobbing_Internal_ILinearPattern
    :
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
{
}

public protocol Microsoft_Extensions_FileSystemGlobbing_Internal_IPathSegment
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_FileSystemGlobbing_Internal_IPatternContext
    :
    SGBridgeGetHandle
{
}

public protocol Microsoft_Extensions_FileSystemGlobbing_Internal_IRaggedPattern
    :
    Microsoft_Extensions_FileSystemGlobbing_Internal_IPattern
{
}

// EXTENSION METHOD void AddExcludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>[])
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func AddExcludePatterns(excludePatternsGroups : Optional<dotnet.System_Arr<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>>) throws {
        try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddExcludePatterns(matcher: self, excludePatternsGroups: excludePatternsGroups);
    }
}

// EXTENSION METHOD void AddIncludePatterns(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>[])
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func AddIncludePatterns(includePatternsGroups : Optional<dotnet.System_Arr<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>>) throws {
        try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.AddIncludePatterns(matcher: self, includePatternsGroups: includePatternsGroups);
    }
}

// EXTENSION METHOD System.Collections.Generic.IEnumerable<System.String> GetResultsInFullPath(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String)
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func GetResultsInFullPath(directoryPath : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>> {
        return try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.GetResultsInFullPath(matcher: self, directoryPath: directoryPath);
    }
}

// EXTENSION METHOD Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.Collections.Generic.IEnumerable<System.String>)
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func Match(files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        return try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(matcher: self, files: files);
    }
}

// EXTENSION METHOD Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String)
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func Match(file : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        return try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(matcher: self, file: file);
    }
}

// EXTENSION METHOD Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String, System.Collections.Generic.IEnumerable<System.String>)
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func Match(rootDir : Optional<dotnet.System.String>, files : Optional<dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        return try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(matcher: self, rootDir: rootDir, files: files);
    }
}

// EXTENSION METHOD Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult Match(Microsoft.Extensions.FileSystemGlobbing.Matcher, System.String, System.String)
extension aspnetcore.Microsoft.Extensions.FileSystemGlobbing.Matcher {
    public func Match(rootDir : Optional<dotnet.System.String>, file : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult> {
        return try aspnetcore.Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions.Match(matcher: self, rootDir: rootDir, file: file);
    }
}

