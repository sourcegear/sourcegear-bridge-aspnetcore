// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.AspNetCore
// Microsoft.AspNetCore.Hosting
extension Microsoft.AspNetCore.Hosting {
// type: Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions
public struct WebHostBuilderSocketExtensions {
    // Microsoft.AspNetCore.Hosting.IWebHostBuilder UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
// docid: M:Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions.UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
    /**
    
            Specify Sockets as the transport to be used by Kestrel.
            

    - Parameter hostBuilder: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder to configure.
            
    - Returns: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder.
            

    */
    public static func UseSockets(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_WebHostBuilderSocketExtensions_IWebHostBuilder__UseSockets_0__1__IWebHostBuilder(&__thrown, hostBuilder.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl : __return);
        }
    }
    // Microsoft.AspNetCore.Hosting.IWebHostBuilder UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder, System.Action<Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>)
// docid: M:Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions.UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder,System.Action{Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions})
    /**
    
            Specify Sockets as the transport to be used by Kestrel.
            

    - Parameter hostBuilder: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder to configure.
            
    - Parameter configureOptions: 
            A callback to configure Libuv options.
            
    - Returns: 
            The Microsoft.AspNetCore.Hosting.IWebHostBuilder.
            

    */
    public static func UseSockets(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder, configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Hosting_WebHostBuilderSocketExtensions_IWebHostBuilder__UseSockets_0__2__IWebHostBuilder_System_Action_Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_(&__thrown, hostBuilder.get_handle(), configureOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UseSockets(hostBuilder : aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder, configureOptions : @escaping (aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>(configureOptions);
        return try UseSockets(hostBuilder: hostBuilder, configureOptions: del_configureOptions);
    }
} // WebHostBuilderSocketExtensions


}

// Microsoft.AspNetCore.Server
// Microsoft.AspNetCore.Server.Kestrel
// Microsoft.AspNetCore.Server.Kestrel.Transport
// Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets
extension Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets {
// type: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionContextFactory
    /**
    
            A factory for socket based connections contexts.
            

    */
public final class SocketConnectionContextFactory
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionContextFactory_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionContextFactory_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions, Microsoft.Extensions.Logging.ILogger)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionContextFactory.#ctor(Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions,Microsoft.Extensions.Logging.ILogger)
    /**
    
            Creates the .
            

    - Parameter options: The options.
    - Parameter logger: The logger.
    */
    public init(options : aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions, logger : aspnetcore.Microsoft.Extensions.Logging.ILogger) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionContextFactory_ctor_0__2__SocketConnectionFactoryOptions_ILogger(&__thrown, options.get_handle(), logger.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.AspNetCore.Connections.ConnectionContext Create(System.Net.Sockets.Socket)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionContextFactory.Create(System.Net.Sockets.Socket)
    /**
    
            Create a  for a socket.
            

    - Parameter socket: The socket for the connection.
    - Returns: 

    */
    public func Create(socket : dotnet.System.Net.Sockets.Socket) throws -> aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionContextFactory_ConnectionContext__Create_0__1__Socket(&__thrown, self.get_handle(), socket.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.AspNetCore.Connections.ConnectionContext(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionContextFactory.Dispose
    /**
    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionContextFactory_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SocketConnectionContextFactory


// type: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions
    /**
    
            Options for .
            

    */
open class SocketConnectionFactoryOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.#ctor
    /**
    
            Create a new instance.
            

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_IOQueueCount()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.get_IOQueueCount
    open func get_IOQueueCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_i32__get_IOQueueCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_IOQueueCount(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.set_IOQueueCount(System.Int32)
    open func set_IOQueueCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_void__set_IOQueueCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_WaitForDataBeforeAllocatingBuffer()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.get_WaitForDataBeforeAllocatingBuffer
    open func get_WaitForDataBeforeAllocatingBuffer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_bool__get_WaitForDataBeforeAllocatingBuffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_WaitForDataBeforeAllocatingBuffer(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.set_WaitForDataBeforeAllocatingBuffer(System.Boolean)
    open func set_WaitForDataBeforeAllocatingBuffer(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_void__set_WaitForDataBeforeAllocatingBuffer_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxReadBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.get_MaxReadBufferSize
    open func get_MaxReadBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_System_Nullable_i64___get_MaxReadBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxReadBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.set_MaxReadBufferSize(System.Nullable{System.Int64})
    open func set_MaxReadBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_void__set_MaxReadBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxWriteBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.get_MaxWriteBufferSize
    open func get_MaxWriteBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_System_Nullable_i64___get_MaxWriteBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxWriteBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.set_MaxWriteBufferSize(System.Nullable{System.Int64})
    open func set_MaxWriteBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_void__set_MaxWriteBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UnsafePreferInlineScheduling()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.get_UnsafePreferInlineScheduling
    open func get_UnsafePreferInlineScheduling() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_bool__get_UnsafePreferInlineScheduling_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UnsafePreferInlineScheduling(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketConnectionFactoryOptions.set_UnsafePreferInlineScheduling(System.Boolean)
    open func set_UnsafePreferInlineScheduling(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketConnectionFactoryOptions_void__set_UnsafePreferInlineScheduling_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The number of I/O queues used to process requests. Set to 0 to directly schedule I/O to the ThreadPool.
            

    */
    open var IOQueueCount : Swift.Int32 {
        get {
            return try! get_IOQueueCount();
        }
        set(v) {
            return try! set_IOQueueCount(value: v);
        }
    }
    /**
    
            Gets or sets the maximum unconsumed incoming bytes the transport will buffer.
            

    */
    open var MaxReadBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxReadBufferSize();
        }
        set(v) {
            return try! set_MaxReadBufferSize(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum outgoing bytes the transport will buffer before applying write backpressure.
            

    */
    open var MaxWriteBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxWriteBufferSize();
        }
        set(v) {
            return try! set_MaxWriteBufferSize(value: v!);
        }
    }
    /**
    
            Inline application and transport continuations instead of dispatching to the threadpool.
            

    */
    open var UnsafePreferInlineScheduling : Bool {
        get {
            return try! get_UnsafePreferInlineScheduling();
        }
        set(v) {
            return try! set_UnsafePreferInlineScheduling(value: v);
        }
    }
    /**
    
            Wait until there is data available to allocate a buffer. Setting this to false can increase throughput at the cost of increased memory usage.
            

    */
    open var WaitForDataBeforeAllocatingBuffer : Bool {
        get {
            return try! get_WaitForDataBeforeAllocatingBuffer();
        }
        set(v) {
            return try! set_WaitForDataBeforeAllocatingBuffer(value: v);
        }
    }
} // SocketConnectionFactoryOptions


// type: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportFactory
    /**
    
            A factory for socket based connections.
            

    */
public final class SocketTransportFactory
    :
    dotnet.System.Object,
    Microsoft_AspNetCore_Connections_IConnectionListenerFactory
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportFactory_get_type_handle();
    }
    public class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportFactory_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportFactory.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions},Microsoft.Extensions.Logging.ILoggerFactory)
    public init(options : aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>, loggerFactory : aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportFactory_ctor_0__2__Microsoft_Extensions_Options_IOptions_Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions__ILoggerFactory(&__thrown, options.get_handle(), loggerFactory.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.ValueTask<Microsoft.AspNetCore.Connections.IConnectionListener> BindAsync(System.Net.EndPoint, System.Threading.CancellationToken)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportFactory.BindAsync(System.Net.EndPoint,System.Threading.CancellationToken)
    public func BindAsync(endpoint : dotnet.System.Net.EndPoint, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<aspnetcore.Microsoft.AspNetCore.Connections.IConnectionListener> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportFactory_System_Threading_Tasks_ValueTask_Microsoft_AspNetCore_Connections_IConnectionListener___BindAsync_0__2__EndPoint_CancellationToken(&__thrown, self.get_handle(), endpoint.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // SocketTransportFactory


// type: Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions
    /**
    
            Options for socket based transports.
            

    */
open class SocketTransportOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_get_type_handle();
    }
    open class override func AsType() -> dotnet.System.Type_ {
        return dotnet.System.Type_(hndl: __copy_handle(get_type_handle()));
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public convenience init (cast h_cast: NonnullHandle) throws {
        var __thrown : NullableHandle = nil;
        let h_res = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_cast(&__thrown,h_cast);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            self.init(hndl: h_res);
        }
    }
    // .ctor()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Net.Sockets.Socket CreateDefaultBoundListenSocket(System.Net.EndPoint)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.CreateDefaultBoundListenSocket(System.Net.EndPoint)
    /**
    
            Creates a default instance of  for the given 
            that can be used by a connection listener to listen for inbound requests. 
            is called by this method.
            

    - Parameter endpoint: 
            An .
            
    - Returns: 
            A  instance.
            

    */
    open class func CreateDefaultBoundListenSocket(endpoint : dotnet.System.Net.EndPoint) throws -> dotnet.System.Net.Sockets.Socket {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_Socket__CreateDefaultBoundListenSocket_0__1__EndPoint(&__thrown, endpoint.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Sockets.Socket(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_IOQueueCount()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_IOQueueCount
    open func get_IOQueueCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_i32__get_IOQueueCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_IOQueueCount(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_IOQueueCount(System.Int32)
    open func set_IOQueueCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_IOQueueCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_WaitForDataBeforeAllocatingBuffer()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_WaitForDataBeforeAllocatingBuffer
    open func get_WaitForDataBeforeAllocatingBuffer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_bool__get_WaitForDataBeforeAllocatingBuffer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_WaitForDataBeforeAllocatingBuffer(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_WaitForDataBeforeAllocatingBuffer(System.Boolean)
    open func set_WaitForDataBeforeAllocatingBuffer(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_WaitForDataBeforeAllocatingBuffer_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_NoDelay()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_NoDelay
    open func get_NoDelay() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_bool__get_NoDelay_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_NoDelay(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_NoDelay(System.Boolean)
    open func set_NoDelay(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_NoDelay_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_Backlog()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_Backlog
    open func get_Backlog() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_i32__get_Backlog_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Backlog(System.Int32)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_Backlog(System.Int32)
    open func set_Backlog(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_Backlog_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxReadBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_MaxReadBufferSize
    open func get_MaxReadBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_System_Nullable_i64___get_MaxReadBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxReadBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_MaxReadBufferSize(System.Nullable{System.Int64})
    open func set_MaxReadBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_MaxReadBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Nullable<System.Int64> get_MaxWriteBufferSize()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_MaxWriteBufferSize
    open func get_MaxWriteBufferSize() throws -> Optional<Swift.Int64> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_System_Nullable_i64___get_MaxWriteBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? System_Int64_unbox(__return!) : nil;
        }
    }
    // [IsSpecialName] void set_MaxWriteBufferSize(System.Nullable<System.Int64>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_MaxWriteBufferSize(System.Nullable{System.Int64})
    open func set_MaxWriteBufferSize(value : Optional<Swift.Int64>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_MaxWriteBufferSize_0__1__System_Nullable_i64_(&__thrown, self.get_handle(), (value != nil) ? System_Int64_box(value!) : nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UnsafePreferInlineScheduling()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_UnsafePreferInlineScheduling
    open func get_UnsafePreferInlineScheduling() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_bool__get_UnsafePreferInlineScheduling_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UnsafePreferInlineScheduling(bool)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_UnsafePreferInlineScheduling(System.Boolean)
    open func set_UnsafePreferInlineScheduling(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_UnsafePreferInlineScheduling_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Func<System.Net.EndPoint,System.Net.Sockets.Socket> get_CreateBoundListenSocket()
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.get_CreateBoundListenSocket
    open func get_CreateBoundListenSocket() throws -> dotnet.System.Func_2<dotnet.System.Net.EndPoint,dotnet.System.Net.Sockets.Socket> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_System_Func_System_Net_EndPoint_System_Net_Sockets_Socket___get_CreateBoundListenSocket_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Func_2(hndl : __return);
        }
    }
    // [IsSpecialName] void set_CreateBoundListenSocket(System.Func<System.Net.EndPoint,System.Net.Sockets.Socket>)
// docid: M:Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions.set_CreateBoundListenSocket(System.Func{System.Net.EndPoint,System.Net.Sockets.Socket})
    open func set_CreateBoundListenSocket(value : dotnet.System.Func_2<dotnet.System.Net.EndPoint,dotnet.System.Net.Sockets.Socket>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_AspNetCore_Server_Kestrel_Transport_Sockets_SocketTransportOptions_void__set_CreateBoundListenSocket_0__1__System_Func_System_Net_EndPoint_System_Net_Sockets_Socket_(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_CreateBoundListenSocket(value : @escaping (dotnet.System.Net.EndPoint) throws -> dotnet.System.Net.Sockets.Socket) throws {
        let del_value = try dotnet.System.Func_2<dotnet.System.Net.EndPoint,dotnet.System.Net.Sockets.Socket>(value);
        return try set_CreateBoundListenSocket(value: del_value);
    }
    /**
    
            The maximum length of the pending connection queue.
            

    */
    open var Backlog : Swift.Int32 {
        get {
            return try! get_Backlog();
        }
        set(v) {
            return try! set_Backlog(value: v);
        }
    }
    /**
    
            A function used to create a new  to listen with. If
            not set,  is used.
            

    */
    open var CreateBoundListenSocket : dotnet.System.Func_2<dotnet.System.Net.EndPoint,dotnet.System.Net.Sockets.Socket> {
        get {
            return try! get_CreateBoundListenSocket();
        }
        set(v) {
            return try! set_CreateBoundListenSocket(value: v);
        }
    }
    /**
    
            The number of I/O queues used to process requests. Set to 0 to directly schedule I/O to the ThreadPool.
            

    */
    open var IOQueueCount : Swift.Int32 {
        get {
            return try! get_IOQueueCount();
        }
        set(v) {
            return try! set_IOQueueCount(value: v);
        }
    }
    /**
    
            Gets or sets the maximum unconsumed incoming bytes the transport will buffer.
            

    */
    open var MaxReadBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxReadBufferSize();
        }
        set(v) {
            return try! set_MaxReadBufferSize(value: v!);
        }
    }
    /**
    
            Gets or sets the maximum outgoing bytes the transport will buffer before applying write backpressure.
            

    */
    open var MaxWriteBufferSize : Optional<Swift.Int64> {
        get {
            return try! get_MaxWriteBufferSize();
        }
        set(v) {
            return try! set_MaxWriteBufferSize(value: v!);
        }
    }
    /**
    
            Set to false to enable Nagle's algorithm for all connections.
            

    */
    open var NoDelay : Bool {
        get {
            return try! get_NoDelay();
        }
        set(v) {
            return try! set_NoDelay(value: v);
        }
    }
    /**
    
            Inline application and transport continuations instead of dispatching to the threadpool.
            

    */
    open var UnsafePreferInlineScheduling : Bool {
        get {
            return try! get_UnsafePreferInlineScheduling();
        }
        set(v) {
            return try! set_UnsafePreferInlineScheduling(value: v);
        }
    }
    /**
    
            Wait until there is data available to allocate a buffer. Setting this to false can increase throughput at the cost of increased memory usage.
            

    */
    open var WaitForDataBeforeAllocatingBuffer : Bool {
        get {
            return try! get_WaitForDataBeforeAllocatingBuffer();
        }
        set(v) {
            return try! set_WaitForDataBeforeAllocatingBuffer(value: v);
        }
    }
} // SocketTransportOptions


}






// EXTENSION METHOD Microsoft.AspNetCore.Hosting.IWebHostBuilder UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder)
extension Microsoft_AspNetCore_Hosting_IWebHostBuilder {
    public func UseSockets() throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions.UseSockets(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.AspNetCore.Hosting.IWebHostBuilder UseSockets(Microsoft.AspNetCore.Hosting.IWebHostBuilder, System.Action<Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>)
extension Microsoft_AspNetCore_Hosting_IWebHostBuilder {
    public func UseSockets(configureOptions : dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions.UseSockets(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseSockets(configureOptions : @escaping (aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions) throws -> Void) throws -> aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.SocketTransportOptions>(configureOptions);
        return try aspnetcore.Microsoft.AspNetCore.Hosting.WebHostBuilderSocketExtensions.UseSockets(hostBuilder: aspnetcore.Microsoft.AspNetCore.Hosting.IWebHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions);
    }
}

