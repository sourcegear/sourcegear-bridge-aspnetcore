// this file is automatically generated with SourceGear Bridge

import jumptable_dotnet;
import jumptable_aspnetcore;
import dotnet;

// Microsoft
// Microsoft.Extensions
// Microsoft.Extensions.DependencyInjection
extension Microsoft.Extensions.DependencyInjection {
// type: Microsoft.Extensions.DependencyInjection.OptionsBuilderExtensions
public struct OptionsBuilderExtensions {
    // Microsoft.Extensions.Options.OptionsBuilder<TOptions> ValidateOnStart<TOptions>(Microsoft.Extensions.Options.OptionsBuilder<TOptions>)
// docid: M:Microsoft.Extensions.DependencyInjection.OptionsBuilderExtensions.ValidateOnStart``1(Microsoft.Extensions.Options.OptionsBuilder{``0})
    /**
    
            Enforces options validation check on start rather than in runtime.
            

    - Parameter optionsBuilder: The  to configure options instance.
    - Returns: The  so that additional calls can be chained.

    */
    public static func ValidateOnStart<UTOptions : SGBridgeGenericValue>(optionsBuilder : aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<UTOptions>) throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<UTOptions>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_DependencyInjection_OptionsBuilderExtensions_Microsoft_Extensions_Options_OptionsBuilder_UTOptions___ValidateOnStart_1__1__Microsoft_Extensions_Options_OptionsBuilder_UTOptions_(UTOptions.get_type_handle(), &__thrown, nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // OptionsBuilderExtensions


}

// Microsoft.Extensions.Hosting
extension Microsoft.Extensions.Hosting {
// type: Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior
    /**
    
            Specifies a behavior that the  will honor if an
            unhandled exception occurs in one of its  instances.
            

    */
public struct BackgroundServiceExceptionBehavior : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_BackgroundServiceExceptionBehavior_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior StopHost
    /**
    
            Stops the  instance.
            

    */
    public static var StopHost : aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior(val: Microsoft_Extensions_Hosting_BackgroundServiceExceptionBehavior_get_StopHost());
            return __return;
        }
    }
    // static field: Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior Ignore
    /**
    
            Ignore exceptions thrown in .
            

    */
    public static var Ignore : aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior {
        get {
        let __return = aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior(val: Microsoft_Extensions_Hosting_BackgroundServiceExceptionBehavior_get_Ignore());
            return __return;
        }
    }
} // BackgroundServiceExceptionBehavior


// type: Microsoft.Extensions.Hosting.ConsoleLifetimeOptions
open class ConsoleLifetimeOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_ConsoleLifetimeOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Hosting.ConsoleLifetimeOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_ConsoleLifetimeOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_SuppressStatusMessages()
// docid: M:Microsoft.Extensions.Hosting.ConsoleLifetimeOptions.get_SuppressStatusMessages
    open func get_SuppressStatusMessages() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_ConsoleLifetimeOptions_bool__get_SuppressStatusMessages_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_SuppressStatusMessages(bool)
// docid: M:Microsoft.Extensions.Hosting.ConsoleLifetimeOptions.set_SuppressStatusMessages(System.Boolean)
    open func set_SuppressStatusMessages(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_ConsoleLifetimeOptions_void__set_SuppressStatusMessages_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            Indicates if host lifetime status messages should be suppressed such as on startup.
            The default is false.
            

    */
    open var SuppressStatusMessages : Bool {
        get {
            return try! get_SuppressStatusMessages();
        }
        set(v) {
            return try! set_SuppressStatusMessages(value: v);
        }
    }
} // ConsoleLifetimeOptions


// type: Microsoft.Extensions.Hosting.Host
public struct Host {
    // Microsoft.Extensions.Hosting.IHostBuilder CreateDefaultBuilder()
// docid: M:Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder
    /**
    
            Initializes a new instance of the  class with pre-configured defaults.
            

    - Returns: The initialized .

    */
    public static func CreateDefaultBuilder() throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Host_IHostBuilder__CreateDefaultBuilder_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder CreateDefaultBuilder(System.String[])
// docid: M:Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder(System.String[])
    /**
    
            Initializes a new instance of the  class with pre-configured defaults.
            

    - Parameter args: The command line args.
    - Returns: The initialized .

    */
    public static func CreateDefaultBuilder(args : Optional<dotnet.System_Arr<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Host_IHostBuilder__CreateDefaultBuilder_0__1__StringArray(&__thrown, (args?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // Host


// type: Microsoft.Extensions.Hosting.HostBuilder
    /**
    
            A program initialization utility.
            

    */
open class HostBuilder
    :
    dotnet.System.Object,
    Microsoft_Extensions_Hosting_IHostBuilder
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_HostBuilder_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_HostBuilder_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // Microsoft.Extensions.Hosting.IHost Build()
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.Build
    /**
    
            Run the given actions to initialize the host. This can only be called once.
            

    - Returns: An initialized 

    */
    open /* method final */ func Build() throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHost> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHost__Build_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHost(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureAppConfiguration(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Configuration.IConfigurationBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.ConfigureAppConfiguration(System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Configuration.IConfigurationBuilder})
    /**
    
            Sets up the configuration for the remainder of the build process and application. This can be called multiple times and
            the results will be additive. The results will be available at  for
            subsequent operations, as well as in .
            

    - Parameter configureDelegate: The delegate for configuring the  that will be used
            to construct the  for the host.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func ConfigureAppConfiguration(configureDelegate : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__ConfigureAppConfiguration_0__1__System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_Configuration_IConfigurationBuilder_(&__thrown, self.get_handle(), (configureDelegate?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func ConfigureAppConfiguration(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>(configureDelegate);
        return try ConfigureAppConfiguration(configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureContainer<TContainerBuilder>(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,TContainerBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.ConfigureContainer``1(System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,``0})
    /**
    
            Enables configuring the instantiated dependency container. This can be called multiple times and
            the results will be additive.
            

    - Parameter configureDelegate: The delegate for configuring the  that will be used
            to construct the  for the host.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(configureDelegate : dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,UTContainerBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__ConfigureContainer_1__1__System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_UTContainerBuilder_(UTContainerBuilder.get_type_handle(), &__thrown, self.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, UTContainerBuilder) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,UTContainerBuilder>(configureDelegate);
        return try ConfigureContainer(configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureHostConfiguration(System.Action<Microsoft.Extensions.Configuration.IConfigurationBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.ConfigureHostConfiguration(System.Action{Microsoft.Extensions.Configuration.IConfigurationBuilder})
    /**
    
            Set up the configuration for the builder itself. This will be used to initialize the 
            for use later in the build process. This can be called multiple times and the results will be additive.
            

    - Parameter configureDelegate: The delegate for configuring the  that will be used
            to construct the  for the host.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func ConfigureHostConfiguration(configureDelegate : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__ConfigureHostConfiguration_0__1__System_Action_Microsoft_Extensions_Configuration_IConfigurationBuilder_(&__thrown, self.get_handle(), (configureDelegate?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func ConfigureHostConfiguration(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>(configureDelegate);
        return try ConfigureHostConfiguration(configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureServices(System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.IServiceCollection>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.ConfigureServices(System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.IServiceCollection})
    /**
    
            Adds services to the container. This can be called multiple times and the results will be additive.
            

    - Parameter configureDelegate: The delegate for configuring the  that will be used
            to construct the  for the host.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func ConfigureServices(configureDelegate : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__ConfigureServices_0__1__System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_DependencyInjection_IServiceCollection_(&__thrown, self.get_handle(), (configureDelegate?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func ConfigureServices(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>(configureDelegate);
        return try ConfigureServices(configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseServiceProviderFactory<TContainerBuilder>(Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TContainerBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.UseServiceProviderFactory``1(Microsoft.Extensions.DependencyInjection.IServiceProviderFactory{``0})
    /**
    
            Overrides the factory used to create the service provider.
            

    - Parameter factory: A factory used for creating service providers.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func UseServiceProviderFactory<UTContainerBuilder : SGBridgeGenericValue>(factory : aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceProviderFactory_1<UTContainerBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__UseServiceProviderFactory_1__1__Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_UTContainerBuilder_(UTContainerBuilder.get_type_handle(), &__thrown, self.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseServiceProviderFactory<TContainerBuilder>(System.Func<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.IServiceProviderFactory<TContainerBuilder>>)
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.UseServiceProviderFactory``1(System.Func{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.IServiceProviderFactory{``0}})
    /**
    
            Overrides the factory used to create the service provider.
            

    - Parameter factory: A factory used for creating service providers.
    - Returns: The same instance of the  for chaining.

    */
    open /* method final */ func UseServiceProviderFactory<UTContainerBuilder : SGBridgeGenericValue>(factory : Optional<dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceProviderFactory_1<UTContainerBuilder>>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_IHostBuilder__UseServiceProviderFactory_1__1__System_Func_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_DependencyInjection_Microsoft_Extensions_DependencyInjection_IServiceProviderFactory_UTContainerBuilder__(UTContainerBuilder.get_type_handle(), &__thrown, self.get_handle(), (factory?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    open /* method final */ func UseServiceProviderFactory<UTContainerBuilder : SGBridgeGenericValue>(factory : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>) throws -> aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceProviderFactory_1<UTContainerBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_factory = try dotnet.System.Func_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceProviderFactory_1<UTContainerBuilder>>(factory);
        return try UseServiceProviderFactory(factory: del_factory);
    }
    // [IsSpecialName] System.Collections.Generic.IDictionary<System.Object,System.Object> get_Properties()
// docid: M:Microsoft.Extensions.Hosting.HostBuilder.get_Properties
    open /* method final */ func get_Properties() throws -> Optional<dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostBuilder_System_Collections_Generic_IDictionary_object_object___get_Properties_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.IDictionary_2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    
            A central location for sharing state between components during the host building process.
            

    */
    public var Properties : Optional<dotnet.System.Collections.Generic.IDictionary_2<dotnet.System.Object,dotnet.System.Object>> {
        get {
            return try! get_Properties();
        }
    }
} // HostBuilder


// type: Microsoft.Extensions.Hosting.HostOptions
    /**
    
            Options for 
            

    */
open class HostOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_HostOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Hosting.HostOptions.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_HostOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.TimeSpan get_ShutdownTimeout()
// docid: M:Microsoft.Extensions.Hosting.HostOptions.get_ShutdownTimeout
    open func get_ShutdownTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostOptions_TimeSpan__get_ShutdownTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_ShutdownTimeout(System.TimeSpan)
    // [IsSpecialName] Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior get_BackgroundServiceExceptionBehavior()
// docid: M:Microsoft.Extensions.Hosting.HostOptions.get_BackgroundServiceExceptionBehavior
    open func get_BackgroundServiceExceptionBehavior() throws -> aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostOptions_BackgroundServiceExceptionBehavior__get_BackgroundServiceExceptionBehavior_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior(val: __return);
        }
    }
    // [IsSpecialName] void set_BackgroundServiceExceptionBehavior(Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior)
// docid: M:Microsoft.Extensions.Hosting.HostOptions.set_BackgroundServiceExceptionBehavior(Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior)
    open func set_BackgroundServiceExceptionBehavior(value : aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_HostOptions_void__set_BackgroundServiceExceptionBehavior_0__1__BackgroundServiceExceptionBehavior(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
            The behavior the  will follow when any of
            its  instances throw an unhandled exception.
            

    */
    open var BackgroundServiceExceptionBehavior : aspnetcore.Microsoft.Extensions.Hosting.BackgroundServiceExceptionBehavior {
        get {
            return try! get_BackgroundServiceExceptionBehavior();
        }
        set(v) {
            return try! set_BackgroundServiceExceptionBehavior(value: v);
        }
    }
    /**
    
            The default timeout for .
            

    */
    open var ShutdownTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_ShutdownTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_ShutdownTimeout(System.TimeSpan)
    }
} // HostOptions


// type: Microsoft.Extensions.Hosting.HostingHostBuilderExtensions
public struct HostingHostBuilderExtensions {
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureAppConfiguration(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Configuration.IConfigurationBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureAppConfiguration(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Configuration.IConfigurationBuilder})
    /**
    
            Sets up the configuration for the remainder of the build process and application. This can be called multiple times and
            the results will be additive. The results will be available at  for
            subsequent operations, as well as in .
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureDelegate: The delegate for configuring the  that will be used
            to construct the  for the host.
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureAppConfiguration(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureAppConfiguration_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Configuration_IConfigurationBuilder_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureDelegate?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureAppConfiguration(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>(configureDelegate);
        return try ConfigureAppConfiguration(hostBuilder: hostBuilder, configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureContainer<TContainerBuilder>(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<TContainerBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureContainer``1(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{``0})
    /**
    
            Enables configuring the instantiated dependency container. This can be called multiple times and
            the results will be additive.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureDelegate: The delegate for configuring the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : dotnet.System.Action_1<UTContainerBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureContainer_1__2__IHostBuilder_System_Action_UTContainerBuilder_(UTContainerBuilder.get_type_handle(), &__thrown, hostBuilder?.get_handle() ?? nil, nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : @escaping (UTContainerBuilder) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<UTContainerBuilder>(configureDelegate);
        return try ConfigureContainer(hostBuilder: hostBuilder, configureDelegate: del_configureDelegate);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureDefaults(Microsoft.Extensions.Hosting.IHostBuilder, System.String[])
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureDefaults(Microsoft.Extensions.Hosting.IHostBuilder,System.String[])
    /**
    
            Configures an existing  instance with pre-configured defaults. This will overwrite
            previously configured values and is intended to be called before additional configuration calls.
            

    - Parameter builder: The existing builder to configure.
    - Parameter args: The command line args.
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureDefaults(builder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, args : Optional<dotnet.System_Arr<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureDefaults_0__2__IHostBuilder_StringArray(&__thrown, builder?.get_handle() ?? nil, (args?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Hosting.HostOptions>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Hosting.HostOptions})
    /**
    
            Adds a delegate for configuring the  of the .
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureOptions: The delegate for configuring the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureHostOptions(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureHostOptions_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_Hosting_HostOptions_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureOptions?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureHostOptions(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Hosting.HostOptions>(configureOptions);
        return try ConfigureHostOptions(hostBuilder: hostBuilder, configureOptions: del_configureOptions);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostOptions>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.HostOptions})
    /**
    
            Adds a delegate for configuring the  of the .
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureOptions: The delegate for configuring the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureHostOptions(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureHostOptions_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_HostOptions_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureOptions?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureHostOptions(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>(configureOptions);
        return try ConfigureHostOptions(hostBuilder: hostBuilder, configureOptions: del_configureOptions);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Logging.ILoggingBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Logging.ILoggingBuilder})
    /**
    
            Adds a delegate for configuring the provided . This may be called multiple times.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureLogging: The delegate that configures the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureLogging(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureLogging : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureLogging_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_Logging_ILoggingBuilder_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureLogging?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureLogging(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureLogging : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureLogging = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configureLogging);
        return try ConfigureLogging(hostBuilder: hostBuilder, configureLogging: del_configureLogging);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Logging.ILoggingBuilder>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Logging.ILoggingBuilder})
    /**
    
            Adds a delegate for configuring the provided . This may be called multiple times.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureLogging: The delegate that configures the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureLogging(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureLogging : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureLogging_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Logging_ILoggingBuilder_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureLogging?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureLogging(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureLogging : @escaping (Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureLogging = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configureLogging);
        return try ConfigureLogging(hostBuilder: hostBuilder, configureLogging: del_configureLogging);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder ConfigureServices(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureServices(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.DependencyInjection.IServiceCollection})
    /**
    
            Adds services to the container. This can be called multiple times and the results will be additive.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureDelegate: The delegate for configuring the .
    - Returns: The same instance of the  for chaining.

    */
    public static func ConfigureServices(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__ConfigureServices_0__2__IHostBuilder_System_Action_Microsoft_Extensions_DependencyInjection_IServiceCollection_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureDelegate?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func ConfigureServices(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>(configureDelegate);
        return try ConfigureServices(hostBuilder: hostBuilder, configureDelegate: del_configureDelegate);
    }
    // System.Threading.Tasks.Task RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.ConsoleLifetimeOptions},System.Threading.CancellationToken)
    /**
    
            Enables console support, builds and starts the host, and waits for Ctrl+C or SIGTERM to shut down.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureOptions: The delegate for configuring the .
    - Parameter cancellationToken: A  that can be used to cancel the console.
    - Returns: A  that only completes when the token is triggered or shutdown is triggered.

    */
    public static func RunConsoleAsync(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_Task__RunConsoleAsync_0__3__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_ConsoleLifetimeOptions__CancellationToken(&__thrown, hostBuilder?.get_handle() ?? nil, (configureOptions?.get_handle()), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func RunConsoleAsync(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>) throws -> Void, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>(configureOptions);
        return try RunConsoleAsync(hostBuilder: hostBuilder, configureOptions: del_configureOptions, cancellationToken: cancellationToken);
    }
    // System.Threading.Tasks.Task RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder, System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder,System.Threading.CancellationToken)
    /**
    
            Enables console support, builds and starts the host, and waits for Ctrl+C or SIGTERM to shut down.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter cancellationToken: A  that can be used to cancel the console.
    - Returns: A  that only completes when the token is triggered or shutdown is triggered.

    */
    public static func RunConsoleAsync(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_Task__RunConsoleAsync_0__2__IHostBuilder_CancellationToken(&__thrown, hostBuilder?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder)
    /**
    
            Listens for Ctrl+C or SIGTERM and calls  to start the shutdown process.
            This will unblock extensions like RunAsync and WaitForShutdownAsync.
            

    - Parameter hostBuilder: The  to configure.
    - Returns: The same instance of the  for chaining.

    */
    public static func UseConsoleLifetime(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseConsoleLifetime_0__1__IHostBuilder(&__thrown, hostBuilder?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.ConsoleLifetimeOptions})
    /**
    
            Listens for Ctrl+C or SIGTERM and calls  to start the shutdown process.
            This will unblock extensions like RunAsync and WaitForShutdownAsync.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configureOptions: The delegate for configuring the .
    - Returns: The same instance of the  for chaining.

    */
    public static func UseConsoleLifetime(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseConsoleLifetime_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_ConsoleLifetimeOptions_(&__thrown, hostBuilder?.get_handle() ?? nil, (configureOptions?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func UseConsoleLifetime(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>(configureOptions);
        return try UseConsoleLifetime(hostBuilder: hostBuilder, configureOptions: del_configureOptions);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseContentRoot(Microsoft.Extensions.Hosting.IHostBuilder, System.String)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseContentRoot(Microsoft.Extensions.Hosting.IHostBuilder,System.String)
    /**
    
            Specify the content root directory to be used by the host. To avoid the content root directory being
            overwritten by a default value, ensure this is called after defaults are configured.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter contentRoot: Path to root directory of the application.
    - Returns: The .

    */
    public static func UseContentRoot(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, contentRoot : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseContentRoot_0__2__IHostBuilder_String(&__thrown, hostBuilder?.get_handle() ?? nil, contentRoot?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.DependencyInjection.ServiceProviderOptions})
    /**
    
            Specify the  to be the default one.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configure: 
    - Returns: The .

    */
    public static func UseDefaultServiceProvider(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseDefaultServiceProvider_0__2__IHostBuilder_System_Action_Microsoft_Extensions_DependencyInjection_ServiceProviderOptions_(&__thrown, hostBuilder?.get_handle() ?? nil, (configure?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func UseDefaultServiceProvider(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>(configure);
        return try UseDefaultServiceProvider(hostBuilder: hostBuilder, configure: del_configure);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder,System.Action{Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.ServiceProviderOptions})
    /**
    
            Specify the  to be the default one.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter configure: The delegate that configures the .
    - Returns: The .

    */
    public static func UseDefaultServiceProvider(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configure : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseDefaultServiceProvider_0__2__IHostBuilder_System_Action_Microsoft_Extensions_Hosting_HostBuilderContext_Microsoft_Extensions_DependencyInjection_ServiceProviderOptions_(&__thrown, hostBuilder?.get_handle() ?? nil, (configure?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // delegate closure overload
    public static func UseDefaultServiceProvider(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configure = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>(configure);
        return try UseDefaultServiceProvider(hostBuilder: hostBuilder, configure: del_configure);
    }
    // Microsoft.Extensions.Hosting.IHostBuilder UseEnvironment(Microsoft.Extensions.Hosting.IHostBuilder, System.String)
// docid: M:Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseEnvironment(Microsoft.Extensions.Hosting.IHostBuilder,System.String)
    /**
    
            Specify the environment to be used by the host. To avoid the environment being overwritten by a default
            value, ensure this is called after defaults are configured.
            

    - Parameter hostBuilder: The  to configure.
    - Parameter environment: The environment to host the application in.
    - Returns: The .

    */
    public static func UseEnvironment(hostBuilder : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder>, environment : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_HostingHostBuilderExtensions_IHostBuilder__UseEnvironment_0__2__IHostBuilder_String(&__thrown, hostBuilder?.get_handle() ?? nil, environment?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // HostingHostBuilderExtensions


}
// Microsoft.Extensions.Hosting.Internal
extension Microsoft.Extensions.Hosting.Internal {
// type: Microsoft.Extensions.Hosting.Internal.ApplicationLifetime
    /**
    
            Allows consumers to perform cleanup during a graceful shutdown.
            

    */
open class ApplicationLifetime
    :
    dotnet.System.Object,
    Microsoft_Extensions_Hosting_IApplicationLifetime,
    Microsoft_Extensions_Hosting_IHostApplicationLifetime
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Logging.ILogger<Microsoft.Extensions.Hosting.Internal.ApplicationLifetime>)
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.#ctor(Microsoft.Extensions.Logging.ILogger{Microsoft.Extensions.Hosting.Internal.ApplicationLifetime})
    public init(logger : Optional<aspnetcore.Microsoft.Extensions.Logging.ILogger_1<aspnetcore.Microsoft.Extensions.Hosting.Internal.ApplicationLifetime>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_ctor_0__1__Microsoft_Extensions_Logging_ILogger_Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_(&__thrown, (logger?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void NotifyStarted()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.NotifyStarted
    /**
    
            Signals the ApplicationStarted event and blocks until it completes.
            

    */
    open func NotifyStarted() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_void__NotifyStarted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void NotifyStopped()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.NotifyStopped
    /**
    
            Signals the ApplicationStopped event and blocks until it completes.
            

    */
    open func NotifyStopped() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_void__NotifyStopped_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void StopApplication()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.StopApplication
    /**
    
            Signals the ApplicationStopping event and blocks until it completes.
            

    */
    open /* method final */ func StopApplication() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_void__StopApplication_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ApplicationStarted()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.get_ApplicationStarted
    open /* method final */ func get_ApplicationStarted() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_CancellationToken__get_ApplicationStarted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ApplicationStopped()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.get_ApplicationStopped
    open /* method final */ func get_ApplicationStopped() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_CancellationToken__get_ApplicationStopped_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    // [IsSpecialName] System.Threading.CancellationToken get_ApplicationStopping()
// docid: M:Microsoft.Extensions.Hosting.Internal.ApplicationLifetime.get_ApplicationStopping
    open /* method final */ func get_ApplicationStopping() throws -> dotnet.System.Threading.CancellationToken {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_ApplicationLifetime_CancellationToken__get_ApplicationStopping_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.CancellationToken(hndl : __return);
        }
    }
    /**
    
            Triggered when the application host has fully started and is about to wait
            for a graceful shutdown.
            

    */
    public var ApplicationStarted : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_ApplicationStarted();
        }
    }
    /**
    
            Triggered when the application host is performing a graceful shutdown.
            All requests should be complete at this point. Shutdown will block
            until this event completes.
            

    */
    public var ApplicationStopped : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_ApplicationStopped();
        }
    }
    /**
    
            Triggered when the application host is performing a graceful shutdown.
            Request may still be in flight. Shutdown will block until this event completes.
            

    */
    public var ApplicationStopping : dotnet.System.Threading.CancellationToken {
        get {
            return try! get_ApplicationStopping();
        }
    }
} // ApplicationLifetime


// type: Microsoft.Extensions.Hosting.Internal.ConsoleLifetime
    /**
    
            Listens for Ctrl+C or SIGTERM and initiates shutdown.
            

    */
open class ConsoleLifetime
    :
    dotnet.System.Object,
    Microsoft_Extensions_Hosting_IHostLifetime,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>, Microsoft.Extensions.Hosting.IHostEnvironment, Microsoft.Extensions.Hosting.IHostApplicationLifetime, Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Hosting.HostOptions>)
// docid: M:Microsoft.Extensions.Hosting.Internal.ConsoleLifetime.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Hosting.ConsoleLifetimeOptions},Microsoft.Extensions.Hosting.IHostEnvironment,Microsoft.Extensions.Hosting.IHostApplicationLifetime,Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Hosting.HostOptions})
    public init(options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>, environment : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostEnvironment>, applicationLifetime : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostApplicationLifetime>, hostOptions : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_ctor_0__4__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Hosting_ConsoleLifetimeOptions__IHostEnvironment_IHostApplicationLifetime_Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Hosting_HostOptions_(&__thrown, (options?.get_handle()), environment?.get_handle() ?? nil, applicationLifetime?.get_handle() ?? nil, (hostOptions?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>, Microsoft.Extensions.Hosting.IHostEnvironment, Microsoft.Extensions.Hosting.IHostApplicationLifetime, Microsoft.Extensions.Options.IOptions<Microsoft.Extensions.Hosting.HostOptions>, Microsoft.Extensions.Logging.ILoggerFactory)
// docid: M:Microsoft.Extensions.Hosting.Internal.ConsoleLifetime.#ctor(Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Hosting.ConsoleLifetimeOptions},Microsoft.Extensions.Hosting.IHostEnvironment,Microsoft.Extensions.Hosting.IHostApplicationLifetime,Microsoft.Extensions.Options.IOptions{Microsoft.Extensions.Hosting.HostOptions},Microsoft.Extensions.Logging.ILoggerFactory)
    public init(options : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>, environment : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostEnvironment>, applicationLifetime : Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostApplicationLifetime>, hostOptions : Optional<aspnetcore.Microsoft.Extensions.Options.IOptions_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>, loggerFactory : Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggerFactory>) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_ctor_0__5__Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Hosting_ConsoleLifetimeOptions__IHostEnvironment_IHostApplicationLifetime_Microsoft_Extensions_Options_IOptions_Microsoft_Extensions_Hosting_HostOptions__ILoggerFactory(&__thrown, (options?.get_handle()), environment?.get_handle() ?? nil, applicationLifetime?.get_handle() ?? nil, (hostOptions?.get_handle()), loggerFactory?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Dispose()
// docid: M:Microsoft.Extensions.Hosting.Internal.ConsoleLifetime.Dispose
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task StopAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Hosting.Internal.ConsoleLifetime.StopAsync(System.Threading.CancellationToken)
    open /* method final */ func StopAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_Task__StopAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.Task WaitForStartAsync(System.Threading.CancellationToken)
// docid: M:Microsoft.Extensions.Hosting.Internal.ConsoleLifetime.WaitForStartAsync(System.Threading.CancellationToken)
    open /* method final */ func WaitForStartAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_ConsoleLifetime_Task__WaitForStartAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Threading.Tasks.Task(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ConsoleLifetime


// type: Microsoft.Extensions.Hosting.Internal.HostingEnvironment
    /**
    
            This API supports infrastructure and is not intended to be used
            directly from your code. This API may change or be removed in future releases.
            

    */
open class HostingEnvironment
    :
    dotnet.System.Object,
    Microsoft_Extensions_Hosting_IHostEnvironment,
    Microsoft_Extensions_Hosting_IHostingEnvironment
{
    open class override func get_type_handle() -> TypeHandle {
        return Microsoft_Extensions_Hosting_Internal_HostingEnvironment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.#ctor
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Extensions_Hosting_Internal_HostingEnvironment_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_ApplicationName()
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.get_ApplicationName
    open /* method final */ func get_ApplicationName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_HostingEnvironment_String__get_ApplicationName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ApplicationName(System.String)
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.set_ApplicationName(System.String)
    open /* method final */ func set_ApplicationName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_HostingEnvironment_void__set_ApplicationName_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Extensions.FileProviders.IFileProvider get_ContentRootFileProvider()
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.get_ContentRootFileProvider
    open /* method final */ func get_ContentRootFileProvider() throws -> Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileProvider> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_HostingEnvironment_IFileProvider__get_ContentRootFileProvider_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return aspnetcore.Microsoft.Extensions.FileProviders.IFileProvider(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ContentRootFileProvider(Microsoft.Extensions.FileProviders.IFileProvider)
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.set_ContentRootFileProvider(Microsoft.Extensions.FileProviders.IFileProvider)
    open /* method final */ func set_ContentRootFileProvider(value : Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileProvider>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_HostingEnvironment_void__set_ContentRootFileProvider_0__1__IFileProvider(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_ContentRootPath()
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.get_ContentRootPath
    open /* method final */ func get_ContentRootPath() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_HostingEnvironment_String__get_ContentRootPath_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ContentRootPath(System.String)
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.set_ContentRootPath(System.String)
    open /* method final */ func set_ContentRootPath(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_HostingEnvironment_void__set_ContentRootPath_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_EnvironmentName()
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.get_EnvironmentName
    open /* method final */ func get_EnvironmentName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Extensions_Hosting_Internal_HostingEnvironment_String__get_EnvironmentName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_EnvironmentName(System.String)
// docid: M:Microsoft.Extensions.Hosting.Internal.HostingEnvironment.set_EnvironmentName(System.String)
    open /* method final */ func set_EnvironmentName(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        Microsoft_Extensions_Hosting_Internal_HostingEnvironment_void__set_EnvironmentName_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public var ApplicationName : Optional<dotnet.System.String> {
        get {
            return try! get_ApplicationName();
        }
        set(v) {
            return try! set_ApplicationName(value: v!);
        }
    }
    public var ContentRootFileProvider : Optional<aspnetcore.Microsoft.Extensions.FileProviders.IFileProvider> {
        get {
            return try! get_ContentRootFileProvider();
        }
        set(v) {
            return try! set_ContentRootFileProvider(value: v!);
        }
    }
    public var ContentRootPath : Optional<dotnet.System.String> {
        get {
            return try! get_ContentRootPath();
        }
        set(v) {
            return try! set_ContentRootPath(value: v!);
        }
    }
    public var EnvironmentName : Optional<dotnet.System.String> {
        get {
            return try! get_EnvironmentName();
        }
        set(v) {
            return try! set_EnvironmentName(value: v!);
        }
    }
} // HostingEnvironment


}




// EXTENSION METHOD Microsoft.Extensions.Options.OptionsBuilder<TOptions> ValidateOnStart<TOptions>(Microsoft.Extensions.Options.OptionsBuilder<TOptions>)
extension aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1 {
    public func ValidateOnStart() throws -> Optional<aspnetcore.Microsoft.Extensions.Options.OptionsBuilder_1<TOptions>> {
        return try aspnetcore.Microsoft.Extensions.DependencyInjection.OptionsBuilderExtensions.ValidateOnStart(optionsBuilder: self);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureAppConfiguration(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Configuration.IConfigurationBuilder>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureAppConfiguration(configureDelegate : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureAppConfiguration(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: configureDelegate);
    }
    // delegate closure overload
    public func ConfigureAppConfiguration(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Configuration.IConfigurationBuilder>(configureDelegate);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureAppConfiguration(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: del_configureDelegate);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureContainer<TContainerBuilder>(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<TContainerBuilder>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(configureDelegate : dotnet.System.Action_1<UTContainerBuilder>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureContainer(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: configureDelegate);
    }
    // delegate closure overload
    public func ConfigureContainer<UTContainerBuilder : SGBridgeGenericValue>(configureDelegate : @escaping (UTContainerBuilder) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<UTContainerBuilder>(configureDelegate);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureContainer(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: del_configureDelegate);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureDefaults(Microsoft.Extensions.Hosting.IHostBuilder, System.String[])
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureDefaults(args : Optional<dotnet.System_Arr<dotnet.System.String>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureDefaults(builder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), args: args);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Hosting.HostOptions>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureHostOptions(configureOptions : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions);
    }
    // delegate closure overload
    public func ConfigureHostOptions(configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Hosting.HostOptions>(configureOptions);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureHostOptions(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostOptions>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureHostOptions(configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions);
    }
    // delegate closure overload
    public func ConfigureHostOptions(configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.HostOptions>(configureOptions);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureHostOptions(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.Logging.ILoggingBuilder>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureLogging(configureLogging : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureLogging: configureLogging);
    }
    // delegate closure overload
    public func ConfigureLogging(configureLogging : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureLogging = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configureLogging);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureLogging: del_configureLogging);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureLogging(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Logging.ILoggingBuilder>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureLogging(configureLogging : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureLogging: configureLogging);
    }
    // delegate closure overload
    public func ConfigureLogging(configureLogging : @escaping (Optional<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureLogging = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Logging.ILoggingBuilder>(configureLogging);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureLogging(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureLogging: del_configureLogging);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder ConfigureServices(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func ConfigureServices(configureDelegate : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureServices(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: configureDelegate);
    }
    // delegate closure overload
    public func ConfigureServices(configureDelegate : @escaping (Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureDelegate = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.IServiceCollection>(configureDelegate);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.ConfigureServices(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureDelegate: del_configureDelegate);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>, System.Threading.CancellationToken)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func RunConsoleAsync(configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.RunConsoleAsync(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions, cancellationToken: cancellationToken);
    }
    // delegate closure overload
    public func RunConsoleAsync(configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>) throws -> Void, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>(configureOptions);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.RunConsoleAsync(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions, cancellationToken: cancellationToken);
    }
}

// EXTENSION METHOD System.Threading.Tasks.Task RunConsoleAsync(Microsoft.Extensions.Hosting.IHostBuilder, System.Threading.CancellationToken)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func RunConsoleAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> Optional<dotnet.System.Threading.Tasks.Task> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.RunConsoleAsync(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), cancellationToken: cancellationToken);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseConsoleLifetime() throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseConsoleLifetime(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())));
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseConsoleLifetime(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseConsoleLifetime(configureOptions : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseConsoleLifetime(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: configureOptions);
    }
    // delegate closure overload
    public func UseConsoleLifetime(configureOptions : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configureOptions = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.Hosting.ConsoleLifetimeOptions>(configureOptions);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseConsoleLifetime(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configureOptions: del_configureOptions);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseContentRoot(Microsoft.Extensions.Hosting.IHostBuilder, System.String)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseContentRoot(contentRoot : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseContentRoot(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), contentRoot: contentRoot);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseDefaultServiceProvider(configure : Optional<dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func UseDefaultServiceProvider(configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configure = try dotnet.System.Action_1<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>(configure);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseDefaultServiceProvider(Microsoft.Extensions.Hosting.IHostBuilder, System.Action<Microsoft.Extensions.Hosting.HostBuilderContext,Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseDefaultServiceProvider(configure : Optional<dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configure: configure);
    }
    // delegate closure overload
    public func UseDefaultServiceProvider(configure : @escaping (Optional<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext>, Optional<aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>) throws -> Void) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        let del_configure = try dotnet.System.Action_2<aspnetcore.Microsoft.Extensions.Hosting.HostBuilderContext,aspnetcore.Microsoft.Extensions.DependencyInjection.ServiceProviderOptions>(configure);
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseDefaultServiceProvider(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), configure: del_configure);
    }
}

// EXTENSION METHOD Microsoft.Extensions.Hosting.IHostBuilder UseEnvironment(Microsoft.Extensions.Hosting.IHostBuilder, System.String)
extension Microsoft_Extensions_Hosting_IHostBuilder {
    public func UseEnvironment(environment : Optional<dotnet.System.String>) throws -> Optional<aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder> {
        return try aspnetcore.Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.UseEnvironment(hostBuilder: aspnetcore.Microsoft.Extensions.Hosting.IHostBuilder(hndl: __copy_handle(self.get_handle())), environment: environment);
    }
}

